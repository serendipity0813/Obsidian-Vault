### 사전캠프 11일차 [TIL]

[유니티 강의 4주차 진행 완료]

  

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiiy79pQWpbG1yEShXrSDUmctRz6Lk5twPMLf0hurSvV-QCmMagE6UimHNUH_2pZYbeNz5YvHLEZT_SRuSbngGLGAo7V42W3RT6x9ylgkbW96aCoictPCIs6r_jnR8_roOGXqgcicfalaqFxuyS4e0lZfR86MRgdyHlOHzjnUqX5kqZnGFYP3XS5j5KKPlY/s320/findrtan.png)](https://www.blogger.com/blog/post/edit/3583706664799492072/7875979344193232922#)

  

  

![](https://img1.blogblog.com/img/video_object.png)

  

  

#카드뒤집기 게임 구현 완료

->기본 씬 구성 / 카드 만들기 / 시간 흐르도록 하기

-> 카드 배치하고 이미지 삽입 후 애니메이션 만들기

-> 카드 뒤집기 / 카드 매칭하기 기능 만들기

-> 게임오버와 리트라이 만들기

-> 4주차 숙제 진행

  

#구현시 어려웠던 부분 및 스스로 피드백

-> 리소스 폴더에서 이미지 가져오는 부분에서 유니티에서 

계속 오류가 나옴 (object reference not set to an instance of an object)

-> 구글링으로 오브젝트를 찾을 수 없어 Null 값이 반환되는 오류라는 점 발견

-> 코드 내부에서 Debug.Log 활용하여 중간값 반환에서는 문제 없다는 점 확인

-> 코드 전체에서 문제가 없다는 점을 파악한 후 유니티 프로그램에서 뭔가 잘못한 부분이 있다고 생각하여 잘못된 object가 있거나 이름 등을 따져봄

-> Prefebs 에 카드 오브젝트가 아닌 상위폴더 Cards를 넣어서 오류가 발생

-> 오브젝트를 card로 변경하여 진행하니 정상적으로 실행됨 (약 40분 가량 소요됨)

  

-> 카드 오브젝트에 스크립트 생성 후 버튼 컴포넌트 생성하는 과정에서

card 오브젝트가 아닌 스크립트를 계속 넣어서 함수가 왜 나오지 않는지 고민..

-> 구글링도 해서 여러가지 해결책을 찾아보았지만 원인은 결국 다른 파일을 넣은 점

  

-> 애니메이션 구현 중 bool 함수 true / false 에 따라 다른 애니메이션 구현되도록

트랜지션 활용하여 구현하였지만 애니메이션이 반대로 구현됨

-> 함수와 체크박스를 조금 수정하였더니 정상작동

-> 여러가지 오류를 겪어보니 어떻게 고쳐야 수정이 될 지 프로그램이 조금씩

눈에 들어오기 시작하는 것 같음

  

-> 게임종료 버튼 누른 후 mainscene 불러오기 과정까지는 되지만 시간이 흐르지 않음

-> 버튼에 REGAME 함수를 만들어놓고 그곳에 timescale 코드 작성함

-> gamemanage.cs 의 start 함수로 다시 옮김

  

  

# 구현 내용 중 중요한 부분 

-> 몫 과 나머지를 백터 좌표로 활용하여 카드 위치 세팅해주기

-> 리스트 만들어서 랜덤으로 섞은 후 리소스폴더에서 이미지 가져오기

float x = (i / 4) * 1.4f - 2.1f;

float y = (i % 4) * 1.4f - 3.0f;

newCard.transform.position = new Vector3(x, y, 0);

  

string rtanName = "rtan" + rtans[i].ToString();

newCard.transform.Find("front").GetComponent<SpriteRenderer>().sprite = Resources.Load<Sprite>(rtanName);

-> 대소문자 뿐만 아니라 정확한 오브젝트를 정확한 위치에 넣었는지 다시 한번 체크하기

-> C# 스크립트 내부 오류가 아닌 유니티 상에서의 오류 발생시 특히 확인

  

  firstCard.GetComponent<card>().destroyCard(); 

 secondCard.GetComponent<card>().destroyCard();

-> 오브젝트가 아닌 내부 스크립트 부르기

  

#구현 코드내용 기록

  

->endTxt 코드 구현 내용

public class endTxt : MonoBehaviour

{

    // Start is called before the first frame update

    void Start()

    {

    }

  

    // Update is called once per frame

    void Update()

    {

    }

  

    public void ReGame()

    {

        SceneManager.LoadScene("MainScene");

    }

}

  

-> Cards 코드 구현 내용

using System.Collections;

using System.Collections.Generic;

using UnityEngine;

  

public class card : MonoBehaviour

{

    public Animator anim;

    // Start is called before the first frame update

    void Start()

    {

    }

  

    // Update is called once per frame

    void Update()

    {

    }

  

    public void destroyCard()

    {

        Invoke("destroyCardInvoke", 1.0f);

    }

  

    void destroyCardInvoke()

    {

        Destroy(gameObject);

    }

  

    public void closeCard()

    {

        Invoke("closeCardInvoke", 1.0f);

    }

  

    void closeCardInvoke()

    {

        anim.SetBool("isOpen", false);

        transform.Find("back").gameObject.SetActive(true);

        transform.Find("front").gameObject.SetActive(false);

    }

  

    public void openCard()

    {

        anim.SetBool("isOpen", true);

        transform.Find("front").gameObject.SetActive(true);

        transform.Find("back").gameObject.SetActive(false);

  

        if(GameManager.I.firstCard == null)

        {

            GameManager.I.firstCard = gameObject;

        }

        else

        {

            GameManager.I.secondCard = gameObject;

            GameManager.I.IsMatched();

        }

    }

}

  

-> gamemanager 코드 구현 내용

using System.Collections;

using System.Collections.Generic;

using UnityEngine;

using UnityEngine.UI;

using System.Linq;

  

public class GameManager : MonoBehaviour

{

    // Start is called before the first frame update

    public Text timeTxt;

    public GameObject endTxt;

    public GameObject card;

    float time;

    public static GameManager I;

    public GameObject firstCard;

    public GameObject secondCard;

  

    void Awake()

    {

        I = this;

    }

  

    void Start()

    {

        Time.timeScale = 1.0f;

  

        int[] rtans = { 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7 };

  

        rtans = rtans.OrderBy(item => Random.Range(-1.0f, 1.0f)).ToArray();

  

        for (int i = 0; i < 16; i++)

        {

            GameObject newCard = Instantiate(card);

            newCard.transform.parent = GameObject.Find("cards").transform;

  

            float x = (i / 4) * 1.4f - 2.1f;

            float y = (i % 4) * 1.4f - 3.0f;

            newCard.transform.position = new Vector3(x, y, 0);

  

            string rtanName = "rtan" + rtans[i].ToString();

            newCard.transform.Find("front").GetComponent<SpriteRenderer>().sprite = Resources.Load<Sprite>(rtanName);

        }

    }

  

    // Update is called once per frame

    void Update()

    {

        time += Time.deltaTime;

        timeTxt.text = time.ToString("N2");

  

        if(time > 30)

        {

            Time.timeScale = 0.0f;

            endTxt.SetActive(true);

        }

    }

  

    public void IsMatched()

    {

        string firstCardImage = firstCard.transform.Find("front").GetComponent<SpriteRenderer>().sprite.name;

        string secondCardImage = secondCard.transform.Find("front").GetComponent<SpriteRenderer>().sprite.name;

  

        if (firstCardImage == secondCardImage)

        {

            firstCard.GetComponent<card>().destroyCard();

            secondCard.GetComponent<card>().destroyCard();

  

            int cardsLeft = GameObject.Find("cards").transform.childCount;

            Debug.Log(cardsLeft);

  

            if (cardsLeft < 3)

            {

                Time.timeScale = 0f;

                endTxt.SetActive(true);

            }

        }

        else

        {

            firstCard.GetComponent<card>().closeCard();

            secondCard.GetComponent<card>().closeCard();

        }

        firstCard = null;

        secondCard = null;

    }

}