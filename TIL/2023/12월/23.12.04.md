### 23.12.04 [TIL]

**[ 회고록 ]**

**1. 오늘까지 대부분의 게임 기능 구현은 마무리 하고 내일부터 UI, 디테일, 꾸미기, 버그수정**

**2. 특수 아이템으로 쉴드와, 몬스터 전체 삭제 구현** 

**3. 스크립트 수정하다가 쉴드 기능에서 오류가 생겼는데 수정하다가 하루가 지나감**

****[ Summary ]****

**값타입 - 직관적 / 구조체유사 / int, float / 연두색 / 벡터 / 쿼터니온 / 직접 값 저장, 대입시 값 복사**

**스택 매모리 -> 스코프를 넘어가면 할당이 풀린다**

**참조타입 - 초록색 / 클래스 / 스택은 주소만 저장하고 힙에 저장 / 동적 할당**

**클래스 - 데이터와 메소드를 정의하는 일종의 틀**

**얕은 복사 : 내부의 값이 아닌 참조만 복사함으로서 발생하는 문제**

**값을 복사하는 것이 아닌 같은 곳을 바라보는 문제**

**string은 불변형식이라 문제가 생기지 않음**

**값형식은 문제가 없음**

**나머지는 복사시에 문제가 생길 수 있으니 조심해야함**

**부모 클래스를 상속받은 자식클래스는 부모클래스에 있는 속성, 메소드 사용 가능 / 변경하여 사용도 가능**

**실제로 animal 클래스로 객체가 만들어지는걸 막고 싶다면 추상클래스 사용(abstract) / 인터페이스와 구분이 있지만 명확한 답이 있는것은 아님 / 실수를 막기 위해 사용**

**다운캐스팅 - if문으로 확인한 후 (is로)애니멀을 도그, 캣으로 바꿔주는것 (as로)**

**private - 자기 클래스에만 있도록, 상속 x**

**-상속 접근은 하고 싶다면? protected**

**abstract - 구현 강제 / 실제 내용은 없음**

**virtual - 메소드 임시 구현 / 디폴트 설정**

**overrid - 명확하게 제대로 구현**

**리스코프 치환 원칙 : 객체들은 그건들의 서브타입 객체로 대체될 수 있어야 한다 / 자식 클래스에서 다른 동작을 수행하는 경우, 이는 리스코프 치환 원칙을 위배**

**슈퍼오버라이드 하면 호환x - 최소화할것**

**인터페이스 - 클래스가 구현해야 하는 동작을 정의하는 계약서 / 일관된 동작을 보장 가능 / 태그같은 느낌 / 다형성 / 코드의 재사용성과 유연성을 높일 수 있다.**

******[ TIL - Error, Question, Action, Solve, Feedback ]******

**#태그를 활용하여 다른 게임 오브젝트를 찾아서 조절하는 방법**

**1.**  **GameObject shield = GameObject.FindGameObjectWithTag("Shield");**

**라는 코드를 이용하여 게임 오브젝트를 찾아서 캐싱하기**

**2. GameObject[] mbullet = GameObject.FindGameObjectsWithTag("Mbullet");**

**이런식으로 배열에다가 게임 오브젝트를 저장하여 태그를 가진 모든 오브젝트 파괴도 가능**

**3.  other.GetComponent<Info>().Hp += 20;**

**이런식으로 충돌한 다른 오브젝트의 컴포넌트에 가서 속성 수정하기도 가**

****[ Today Code ]****

****#43. 크기가 작은 부분****

****1. t의 문자열에서 p의 문자열을 빼고 +1 만큼 반복****

****2. t문자열을 0번부터 p문자열 길이만큼 자른 후 숫자로 바꿔주기****

****3. p문자열의 숫자보다 작다면 리턴값 +1****

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiJhQLYPW3m25LE-_ngw4gyZ7FX7wqyhM3ptf34cVLhHh3VVLfMsrnVTcW9cVOcvYZkGSrC4WqDojsI5NRVHtmt9bdgmT1sVM3WZUOd2ftQnBjiM3iKFzPTwdMqFbUYhGfAn6q3GCUOp1rfAtj8GTrQyeD7eGMHGfcnnQso_R8S_aTGsaWUgQsh_QQhR1kK/s320/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-04%20101531.png)](https://www.blogger.com/blog/post/edit/3583706664799492072/7427061120755142868#)

  

****#44. 최소 직사각형****

**1. 1열에는 큰 숫자, 2열에는 작은 숫자만 몰아놓기**

**2. 각 열에서 가장 큰 숫자를 골라주기**

**3. 두 숫자를 곱해서 최소 직사각형 만들기**

**

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEje8k6eDbCclLAh2taT2KM1hfTGJxNquEpCfEnz9D8DfY7lkNs7Z-F9UfnoVO8DkbaXtU-cp3w7yvxmB6HoI8aWMgX5Sj8xMVNHauBt3w6xx0VHVdqFRNi42mniOWSj7H8RKuL-KSIbImhyUG8Ec9Ht69nsYhZJhkKkOv6wjCzcf_lPuMbjsvlkBdM4n3LR/s320/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-04%20101525.png)](https://www.blogger.com/blog/post/edit/3583706664799492072/7427061120755142868#)

#45. 시저암호**

**1. 문자열 하나하나를 char 변수에 저장하기**

**2. 여백이 아나리면 소문자인지, 대문자인지 구분 후**

**3. 아스키코드 숫자로 변환 후 n만큼 더해주기**

**4. 만약 z를 넘어가면 26빼주고 나서 문자로 다시 변환하기**

**5. 만약 여백이라면 그냥 추가해주고 순차적으로 반환값에 추가하기**

**[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjaCfuIKM3EGpDpzRwVZjGPYUVacPnWCdviTZbJsBT4x49ZE3IiPyNgQibuhNdgdzRv-oqd0hdlU53mAXrM27MDoAJ0U8KqRtYNTIivoME-9r_CFizQx31q_GunX4GHKuhOCfm_V9p0wHYk67Rgq-WtQ_M1UTGjSxdxOUzvIGLha380vIkRjuKQ0_-5T4xx/s320/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-12-04%20101518.png)](https://www.blogger.com/blog/post/edit/3583706664799492072/7427061120755142868#)**