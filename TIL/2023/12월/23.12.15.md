
### 유니티 데이터 저장 방식 정리 [[TIL]]

[![](https://blogger.googleusercontent.com/img/a/AVvXsEgOpQMycJ9_080L6-hDI4sC4U-uSQHkObTIhVoYBb9iBsZrb8c6HRzgjVdhIZUupucTY-FgZ7wvefStWQBuACVDnQoMmz-xbnNBy1gLXt2afsw_GDsNTCp7NgR2kDXcZDNRrLUNxL6o2m-J0aDtbzDio8uOouydXUxv-iHDCM-3FjDHoy7q897OjUJDHdyC)](https://www.blogger.com/blog/post/edit/3583706664799492072/7781358465077629711#)

  
  

[데이터 저장]

[#직렬화] -> 객체를 쭉 늘어난 바이트 배열로 만든다(110101...)

역질렬화 -> 바이트 배열을 객체로 바꾸는 것

모든 클래스 직렬화 X (ex. Transform 등)

데이터를 파일에 저장하면 좋은 점

-> 작업량이 줄고 1개의 클래스만 작업하면 된다, 버그 발생 가능성이 낮은 편이다

  

#직렬화 가능 타입

serializable한 요소들로만 만들어 주고 [serializable]을 달아주면 직렬화된다 / 불가능한 요소가 추가되면 x / 가능한 요소들만 담겨있는 클래스도 직렬화 가능

  

#가능한 요소 : 기본 데이터, 열겨형, 특정 unity 타입들

[Serializable]

public class MyClass

{

public int a;

public int b;

}

  

public Transform transform -> x

-> vector2 등으로 바꿔서 써야함

  

  

[PlayerPrefs]

#플레이어 환경설정 등을 저장하는 클래스

-문자열, 실수, 정수 값을 플랫폼 레지스트리에 저장

  

보안에 전혀 문제가 되지 않고 영향도가 높지 않은 부분을 저장하면 좋은 선택이 될 수 있다

  

-> 글자로 묶은 후 저장하고 id를 키로 하고 나머지 정보를 값으로 직렬화 -> Playerprefs 에 넣어버린다

  

-> 직렬화 방식, 역직렬화 방식을 직접 만들 수 있다

  

-> Save 기능은 창밖으로 나가거나 하는 경우에도 저장해주기도 한다 / 하지만 순간 프레임드랍이 있을 수 있다 / 성능상의문제가 있으므로 굳이 할 필요는 없다 

-> 파일 접근은 최소화하자

  

  

[데이터 저장에 많이 쓰이는 메소드/프로퍼티들]

1. persistentDataPath

-> 앱을 지워도 사라지지 않는 경로

- Application.Datapath는 앱 업데이트시 날아가버리는 이슈 있으니 임시로 사용하는걸 권장

  

2.File.Exists

파일 입출력에는 예외처리가 가장 중요

-> 파일의 존재 여부를 파악하는 방법

  

3. File.ReadAllText

->파일의 모든 텍스트를 문자열로 읽어서 string으로 반환

  

4. file.WriteAllText

-> 파일을 만들어서 글을 적어주고 닫아주는 친구

  

  

[CSV]

-> 데이터 저장하고 교환에 사용되는 파일 형식

- 쉼표로 구분되고 각 줄이 하나의 데이터 레코드

- 엑셀이나 메모장 등으로도 파일 확인이 가능

- 기획자와 소통하기 좋은 방안

  

ex) csvFile = Resources/Load<TextAsset>(".File/MyFile");

-for문 사용시 헤더줄 제외를 위해 1부터 쓰는 센스

- split(',') 등을 사용해서 데이터를 자르면서 읽음

- csv를 쓸 때 기획자분들이 많이 실수하는 것은?

데이터에 ., 등을 넣어버리는 경우 - 대참사!

-> ,는 사용하지 못한다고 생각해야함 만약 ,가 필요하면 json으로 넘어가야 한다

  

  

[json]

-> dictionary 형식으로 저장되는 파일

- key / value 형식으로 저장됨

- 직관적으로 저장되고 읽는 것이 강점

- 중괄호의 지옥에 빠질 수 있다는 단점 -> 이쁘게 정리해주는 사이트 따로 있음

ex) 서울2033게임이 json으로 되어있다고 함

  

  

[Scriptable Object]

-특정한 게임 오브젝트나 씬에 종속되지 않고 데이터 저장이 가능하다 (파일 기반이므로)

-글자 뿐만이 아닌 유니티 내부 컴포넌트 등도 저장이 가능

-간단한 데이터 저장에서는 성능적으로 강점을 가지고 있다

-유니티 에디터에서 데이터를 확인 및 수정이 가능하다

  

-> ScriptableObject를 상속받아서 사용

-CreateAssetMenu 해서 생성 가능하도록 추가해야함

  

-> 데이터 저장은 편집할 때나 런타임에 가능 / 에디터에서만 수정이 가능하고 배포된 빌드에서는 스크립터블오브젝트로 데이터 저장 x / 데이터를 수정하는 기능은 사용해서는 안된다 

읽기만 하는 데이터로는 좋음, 수정이 필요한 데이터는 so를 사용x 권장

  

  

 [Binary Formatter]

  

-> 2진수로 데이터가 저장됨 / 읽기 힘들다

- 구조 수정에 어려움이 있을 수 있다 (필드가 추가되거나 등)

- 쓰는 이유는? 성능이 가장 좋기 때문

  

[정리]

간단한 데이터 처리 여부 -> 설정, 단축키, 튜토리얼 진행 여부 등 - PlayerPrefs

기획자와 협업에서 좋은 데이터 처리 - csv

직관적으로 보고 관리하기 좋은 방식 - json

쓰기, 변경기능 제외하고 복잡한 데이터 저장 -> SO

성능이 가장 중요한 데이터 -> binary

  

# 이러한 방식들은 대부분 핸드폰에 저장하는 방식

-> 디바이스 저장이 아닌 서버에 저장해야 한다 (해킹판 등등의 문제)