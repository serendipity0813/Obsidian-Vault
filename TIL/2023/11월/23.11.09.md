### 23.11.09 [TIL]

**[ 일정 및 진행목록 ]**

**-3주차 과제 마무리**

**-4주차 강의 수강**

**-TikTacToe 코드 해설 수강**

**- 개인과제 설계**

**-TIL 작성 및 마무리**

  

****[ TIL - Error, Question / Action / Feedback, Solution ]****

**#현재까지 만들었던 프로젝트 정리**

-> 사전캠프에서 작성했던 코드들과 본 캠프 들어와서 진행한 과제들을 정리하고자 함

-> 하지만 프로젝트 안에 여러 C# 스크립트를 생성하니 MAIN 함수가 겹쳐 실행이 되지 않음

-> visual studio 설정으로 프로젝트 실행 경로를 다중으로 변경하였으나 역시 에러 발생

-> 솔루션 내부에 프로젝트를 추가로 생성한 후 작성한 스크립트를 옮겨 정리

-> 그 후 프로젝트 내부는 1개의 메인함수만 있도록 정리하였고 디버그 실행시 프로젝트 선택도 나눠서 할 수 있도록 설정하였음 (깔끔)

  

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjfLgzt70NtN8-7ARLCa__8f3TVThUInTjEPFqdW5dmUHwUByuVFKItlr5-3JCta5IqY5YTdX94EKGyYhEkxZ51kn1Xyx_zCBxCDezf6If0fVDSaXFC87U-fwRx0-bQOtFVLn8szA4s2l5s1fzrKuTboV_7PAVyI1L2qJzD5xg-pYjkPI9e_nhEq3-yCtX8/s320/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-11-09%20203412.png)](https://www.blogger.com/blog/post/edit/3583706664799492072/7536230499621545794#)

  

  

**# 하나의 프로젝트 에서 다른 스크립트에 작성되어 있는 함수를 불러오고 싶었지만 보안수준의 문제와 다른 namespace 함수 및 클래스가 불러와지지 않아 사용 x**

-> 일단 Main 함수는 1개의 스크립트에 설정하였지만 다른 스크립트에 main 이라고 조금 바꾼 후 디버깅시 이름만 바꿔서 사용하였지만 불편하여 방법을 찾아봄

-> using (namespace 이름) 을 통해 프로젝트의 다른 스크립트 참조 가능한 점 발견

-> 함수를 public static void() 의 식으로 변경한 후 메인함수가 있는 스크립트에서 호출

-> class이름.함수호출 식으로 사용하니 정상적으로 호출 가능

  

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjw0hqFARdVt1CVZd2FQUHatTR61co-lOW6OUYZar3VdCElsDywzSrLp86qwiE8iKzCTeMlZcKM_690oIVtL2wprxgUCVlfXt1YClurRRX_6mwRCartFoJxDWLjZ4XoMxiyCP9pRn_MfRqDkn4T0GsDCWI6R4ntFP_eMSJjE8SkWNBf_io4Pz5j4pxO8rCq/s320/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-11-09%20204125.png)](https://www.blogger.com/blog/post/edit/3583706664799492072/7536230499621545794#)

  

  

****[ TIL - Summary ]****

#인터페이스와 열거형

-> 인터페이스 : 클래스가 구현해야 하는 멤버들을 정의하는 것 

- 다중 상속을 지원하며 추상적인 동작만 정의, 구현 x

vs - 추상 클래스는 일부 동작의 구현을 가지고 추상 메소드 포함 가능 / 단일 상속

-> 열거형 : 서로 관련ㄴ된 상수(정수)들의 집합 정의시 사용

- 코드의 가독성을 높히고 자기 문서화, 스위치 문과의 호환성 등이 장점

  

#예외처리, 값형, 참조형

->예외처리 : try-catch 블록을 사용하여 수행

- try 블록 내에 예외 발생가능 코드 작성 후 catch 블록에서 예외 처리 / finally 는 무조건 실행하지만 생략 가능 (else 와 유사한 역할)

-> 값형 : 변순가 데이터를 저장하는 방식 (직접 저장 / int, float, bool 등등)

-변수가 실제 데이터 보유, 다른 변수에 할당, 전달시 값이 복사

->참조형 : 변수가 데이터에 대한 참조(메모리 주소)를 저장 (포인터와 유사)

- 다른 변수에 할당, 전달시 참조값이 복사됨 (클래스, 배열, 인터페이스 등)

  

#박싱, 언박싱, object

->박싱 : 값형을 참조형으로 변환하는 과정

-참조로 전달되므로 오버헤드가 발생할 수 있음

-가비지 컬렉션의 대상이 될 수 있으므로 메모리 관리에 유의해야

->언박싱 : 박싱된 객체를 다시 값형으로 변환하는 과정

-명시적으로 타입 캐스팅을 해야 함 / 잘못된 형식으로 진행시 런타임 에러 발생

-반복적인 박싱, 언박싱 진행시 성능 저하를 초래할 수 있음

->object : 모든 클래스의 직간접적인 상위 클래스, 모든 클래스는 object 에 상속, 모든 형식 참조 가능

  

#델리게이트, 람다 및 LINQ

->델리게이트 : 메소드를 참조하는 타입 / 함수포인터라는 용어를 사용하기도 함

-메소드를 매개변수로 전달하거나 변수에 할당 가능하며 여러가지 메소드 등록 가능

-자주쓰이는 함수나 소규모 변형이 잦은 함수에 사용하기 좋아 보임

->람다 : 익명 메소드를 만드는 방법 / 델리게이트와 항상 같이 사용

-델리게이트를 사용하여 변수에 할당, 메소드의 매개변수로 전달 가능

- (parameter_list) => expression (일회성 함수 사용시 유용함)

->Func(값 반환), Action(반환X) : 델리게이트를 대체하는 미리 정의된 제네릭 형식

-미리 정의되어 있어 매개변수와 반환 타입을 간결하게 표현 가능

-> LINQ : 프레임워크에서 제공되는 쿼리 언어 확장

-데이터소스에서 데이터를 쿼리하고 조작 / 필터링 / 정렬 / 그룹화 / 조인 등 수행

- var result = from 변수 in 데이터소스 / [where 조건식] / [orderby 정렬식] / [select 식]; 

  

#고급자료형 및 기능

->nullable : null값을 가질 수 있는 값형에 대한 특별한 형식

- null인지 아닌지 확인하고 처리해야 할 때 유용 

-?연산자를 사용하여 선언 (int? nullableInt = null;)

->stringBuilder : 문자열에 대한 추가, 삽입, 치환, 삭제 등의 작업수행을 도와줌

-append() / insert() / replace() / remove() 등의 메소드가 있음

-내부 버퍼를 사용하여 문자열 조작을 수행하여 메모리 할당 및 오버헤드가 크게 감소

  

****[ 회고록 ]****

**-> 전날 상담 일정, 교육 일정, 감기 등으로 집중을 많이 하지 못해 최대한 집중하려고 노력함**

****-> 4주차 강의 수강 완료하였지만 후반부에 내용이 너무 어려워 복습 필요해 보임****

****-> 블로그 정리,  솔루션 정리 어느 정도 마무리 되어 코드 구현에 집중하기로****

****-> 개인과제 설계 및 코드 작성 진행시 4주차 과제와 연관지어 만들어 보려 함****

****[ 코드 구현 ]****

**namespace Note**

**{**

    **internal class Week4**

    **{**

        **//인터페이스와 열거형 실습내용**

        **#region**          

        **public enum Month**

        **{**

            **January = 1,**

            **February,**

            **March,**

            **April,**

            **May,**

            **June,**

            **July,**

            **August,**

            **September,**

            **October,**

            **November,**

            **December**

        **}**

        **//인터페이스 실습**

        **public interface IMovable**

        **{**

            **void Move(int x, int y);**    

        **}**

        **public class Player : IMovable**

        **{**

            **public void Move(int x, int y)**

            **{**

            **}**

            **public void UseItem(IUsable item)**

            **{**

                **item.Use();**

            **}**

            **public void InteractWithItem(IItemPickable item)**

            **{**

                **item.PickUp();**

            **}**

            **public void DropItem(IDroppable item)**

            **{**

                **item.Drop();**

            **}**

        **}**

        **public class Enemy : IMovable**

        **{**

            **public void Move(int x, int y)**

            **{**

            **}**

        **}**

        **public interface IUsable**

        **{**

            **void Use();**

        **}**

        **public class Item : IUsable**

        **{**

            **public string Name { get; set; }**

            **public void Use()**

            **{**

                **Console.WriteLine("아이템 {0}을 사용했습니다.", Name);**

            **}**

        **}**

        **//이중 인터페이스 실습**

        **public interface IItemPickable**

        **{**

            **void PickUp();**

        **}**

        **public interface IDroppable**

        **{**

            **void Drop();**

        **}**

        **public class NewItem : IItemPickable, IDroppable**

        **{**

            **public string Name { get; set; }**

            **public void PickUp()**

            **{**

                **Console.WriteLine("아이템 {0}을 주웠습니다.", Name);**

            **}**

            **public void Drop()**

            **{**

                **Console.WriteLine("아이템 {0}을 버렸습니다.", Name);**

            **}**

        **}**

        **public void UsingItem()**

        **{**

            **IMovable movableObject2 = new Enemy();**

            **movableObject2.Move(1, 2);**

            **Player player = new Player();**

            **Item item = new Item() { Name = "Health Position" };**

            **player.UseItem(item);**

            **NewItem item2 = new NewItem() { Name = "Sword" };**

            **player.InteractWithItem(item2);**

            **player.DropItem(item2);**

        **}**

        **//열거형 실습**

        **public static void SelectMonth(int month)**

        **{**

            **if (month >= (int)Month.January && month <= (int)Month.December)**

            **{**

                **Month selectMonth = (Month)month;**

                **Console.WriteLine("선택한 월은 {0}입니다.", selectMonth);**

            **}**

            **else**

            **{**

                **Console.WriteLine("올바른 월을 입력해주세요.");**

            **}**

        **}**

        **#endregion**

        **//예외처리 / 값형과 참조형 / 박싱과 언박싱 실습내용**

        **#region**

        **//예외처리 실습**

        **public class NegativeNumberException : Exception**

        **{**

            **public NegativeNumberException(string message) : base(message)**

            **{**

            **}**

        **}**

        **public static void Exception()**

        **{**

            **try     //예외처리 시작**

            **{**

                **int number = -10;**

                **//사용자 정의 예외 처리**

                **if (number < 0)**

                **{**

                    **throw new NegativeNumberException("음수는 처리할 수 없습니다.");**

                **}**

            **}**

            **catch (NegativeNumberException ex)**

            **{**

                **Console.WriteLine(ex.Message);**

            **}**

            **catch (Exception ex)**

            **{**

                **Console.WriteLine("예외가 발생했습니다: " + ex.Message);**

            **}**

            **finally     //생략가능, 예외 유무와 관계없이 무조건 실행**

            **{**

                **Console.WriteLine("finally 실행");**

            **}**

        **}**

        **//값형과 참조형 실습**

        **struct MyStruct**

        **{**

            **public int value;**

        **}**

        **public static void Value()**

        **{**

            **MyStruct struct1 = new MyStruct();**

            **struct1.value = 10;**

            **MyStruct struct2 = struct1;**

            **struct2.value = 20;**

            **//값형 출력 결과값, 두 값이 다름**

            **Console.WriteLine($"struct1 value : {struct1.value}.");**

            **Console.WriteLine($"struct2 value : {struct2.value}.");**

        **}**

        **class MyClass**

        **{**

            **public int Value;**

        **}**

        **public static void Reference()**

        **{**

            **MyClass obj1 = new MyClass();**

            **obj1.Value = 10;**

            **MyClass obj2 = obj1;**

            **obj2.Value = 20;**

            **//참조형 출력 결과, 두 값이 같음 -> 같은 주소 참조**

            **Console.WriteLine($"obj1 value : {obj1.Value}.");**

            **Console.WriteLine($"obj2 value : {obj2.Value}.");**

        **}**

        **//박싱, 언박싱 실습**

        **public static void Box()**

        **{**

            **//값형**

            **int x = 10;**

            **int y = x;**

            **y = 20;**

            **Console.WriteLine("x: " + x);**

            **Console.WriteLine("y: " + y);**

            **//참조형**

            **int[] arr1 = new int[] { 1, 2, 3 };**

            **int[] arr2 = arr1;**

            **arr2[0] = 4;**

            **Console.WriteLine("arr1[0] : " + arr1[0]);**

            **Console.WriteLine("arr2[0] : " + arr2[0]);**

            **//박싱과 언박싱**

            **int num1 = 10;**

            **object obj = num1;  //박싱**

            **int num2 = (int)obj;    //언박싱**

            **Console.WriteLine("num1 : " + num1);    //10 출력**

            **Console.WriteLine("num2 : " + num2);    //10 출력**

        **}**

        **#endregion**

        **//Delegate 와 람다 및 LINQ**

        **#region**

        **//Delegate 실습 구현**

        **delegate int Calculate(int x, int y);   //Delegate1 예시**

        **static int Add(int x, int y)        //Delegate1 연결 메소드**

        **{**

            **return x + y;**

        **}**       

        **delegate void MyDelegate(string message);       //Delegate2 예시**

        **static void Method1 (string message0)       //Delegate2 연결 메소드1**

        **{**

            **Console.WriteLine("Method1 : " + message0);**

        **}**

        **static void Method2(string message0)        //Delegate2 연결 메소드2**

        **{**

            **Console.WriteLine("Method2 : " + message0);**

        **}**

        **static void Delegate1()**

        **{**

            **// 메서드 등록**

            **Calculate calc = Add;**

            **// 델리게이트 사용**

            **int result = calc(3, 5);**

            **Console.WriteLine("결과: " + result);**

        **}       //Delegate1 실제 작동 함수**

        **static void Delegate2()**

        **{**

            **MyDelegate myDelegate = Method1;**

            **myDelegate += Method2;**

            **myDelegate("Hello!");**

            **Console.ReadKey();**

        **}       //Delegate2 실제 작동 함수**

        **//<공격 콜백 받기 예제 코드>**

        **// 델리게이트 선언**

        **public delegate void EnemyAttackHandler(float damage);          // 델리게이트 선언**

        **//적 클래스**

        **public class DEnemy**        

        **{**

            **// 공격 이벤트**

            **public event EnemyAttackHandler OnAttack;**

            **// 적의 공격 메서드**

            **public void Attack(float damage)**

            **{**

                **// 이벤트 호출**

                **OnAttack?.Invoke(damage);**

                **// null 조건부 연산자**

                **// null 참조가 아닌 경우에만 멤버에 접근하거나 메서드를 호출**

            **}**

        **}**

        **// 플레이어 클래스**

        **public class DPlayer**

        **{**

            **// 플레이어가 받은 데미지 처리 메서드**

            **public void HandleDamage(float damage)**

            **{**

                **// 플레이어의 체력 감소 등의 처리 로직**

                **Console.WriteLine("플레이어가 {0}의 데미지를 입었습니다.", damage);**

            **}**

        **}**

        **// 게임 실행**

        **public static void Attack()**

        **{**

            **// 적 객체 생성**

            **DEnemy enemy = new DEnemy();**

            **// 플레이어 객체 생성**

            **DPlayer player = new DPlayer();**

            **// 플레이어의 데미지 처리 메서드를 적의 공격 이벤트에 추가**

            **enemy.OnAttack += player.HandleDamage;**

            **// 적의 공격**

            **enemy.Attack(10.0f);**

        **}**

        **//람다 구현 실습**

        **delegate void LambdaDelegate(string message);**

        **public static void Lambda()**

        **{**

            **Calculate calc = (x, y) => x + y;**

            **//델리게이트 인스턴스 생성 및 람다식 할당**

            **LambdaDelegate lambdaDelegate = (message) =>**

            **{**

                **Console.WriteLine($"람다식을 통해 전달된 메시지 : {message}");**

            **};**

            **//델리게이트 호출**

            **lambdaDelegate("안녕하세요 람다입니다 ㅎㅎ");**

            **Console.ReadKey();**

        **}**

        **//<게임 분기 선언 예제 코드>**

        **//Delegate 선언**

        **public delegate void GameEvent();**        

        **//이벤트 매니저 클래스**

        **public class EventManager**

        **{**

            **// 게임 시작 이벤트**

            **public event GameEvent OnGameStart;**

            **// 게임 종료 이벤트**

            **public event GameEvent OnGameEnd;**

            **// 게임 실행**

            **public void RunGame()**

            **{**

                **// 게임 시작 이벤트 호출**

                **OnGameStart?.Invoke();**

                **// 게임 실행 로직**

                **// 게임 종료 이벤트 호출**

                **OnGameEnd?.Invoke();**

            **}**

        **}**

        **// 게임 메시지 클래스**

        **public class GameMessage**

        **{**

            **public void ShowMessage(string message)**

            **{**

                **Console.WriteLine(message);**

            **}**

        **}**

        **// 게임 실행**

        **public static void Event()**

        **{**

            **// 이벤트 매니저 객체 생성**

            **EventManager eventManager = new EventManager();**

            **// 게임 메시지 객체 생성**

            **GameMessage gameMessage = new GameMessage();**

            **// 게임 시작 이벤트에 람다 식으로 메시지 출력 동작 등록**

            **eventManager.OnGameStart += () => gameMessage.ShowMessage("게임이 시작됩니다.");**

            **// 게임 종료 이벤트에 람다 식으로 메시지 출력 동작 등록**

            **eventManager.OnGameEnd += () => gameMessage.ShowMessage("게임이 종료됩니다.");**

            **// 게임 실행**

            **eventManager.RunGame();**

        **}**

        **//Func 와 Action 구현 실습**

        **static int Square(int x, int y)**

        **{**

            **return x * y;**

        **}**

        **static void PrintMessage(string message)**

        **{**

            **Console.WriteLine(message);**

        **}**

        **public static void Func()    //func를 이용한 메소드 호출 함수**

        **{**

            **Func<int, int, int> SquareFunc = Square;**

            **int result = SquareFunc(3, 5);**

            **Console.WriteLine("결과 : " + result);**

        **}**

        **public static void Act()        //act를 이용한 메소드 호출 함수**

        **{**

            **Action<string> printAction = PrintMessage;**

            **printAction("Ready Action!");**

        **}**

        **//<func 와 action 예제 코드>**

        **// 게임 캐릭터 클래스**

        **class GameCharacter**

        **{**

            **private Action<float> healthChangedCallback;**

            **private float health;**

            **public float Health**

            **{**

                **get { return health; }**

                **set**

                **{**

                    **health = value;**

                    **healthChangedCallback?.Invoke(health);**

                **}**

            **}**

            **public void SetHealthChangedCallback(Action<float> callback)**

            **{**

                **healthChangedCallback = callback;**

            **}**

        **}**

        **// 게임 캐릭터 생성 및 상태 변경 감지**

        **public static void Status()**

        **{**

            **GameCharacter character = new GameCharacter();**

            **character.SetHealthChangedCallback(health =>**

            **{**

                **if (health <= 0)**

                **{**

                    **Console.WriteLine("캐릭터 사망!");**

                **}**

            **});**

            **// 캐릭터의 체력 변경**

            **character.Health = 0;**

        **}**

        **//LINQ 실습 코드 구현**

        **public static void LINQ()**

        **{**

            **List<int> numbers = new List<int> { 1, 2, 3, 4, 5};**

            **var everyNumbers = from num in numbers**

                               **where num % 2 == 0**

                               **select num;**

            **foreach (var num in everyNumbers)**

            **{**

                **Console.WriteLine(num);**

            **}**

        **}**

        **public static void StringBuilder()**

        **{**

            **// Nullable 형식 변수 선언**

            **int? nullableInt = null;**

            **double? nullableDouble = 3.14;**

            **bool? nullableBool = true;**

            **// 값 할당 및 접근**

            **nullableInt = 10;**

            **int intValue = nullableInt.Value;**

            **// null 값 검사**

            **if (nullableDouble.HasValue)**

            **{**

                **Console.WriteLine("nullableDouble 값: " + nullableDouble.Value);**

            **}**

            **else**

            **{**

                **Console.WriteLine("nullableDouble은 null입니다.");**

            **}**

            **// null 병합 연산자 사용**

            **// nullableInt ?? 0과 같이 사용되며, nullableInt가 null이면 0을 반환합니다.**

            **int nonNullableInt = nullableInt ?? 0;**

            **bool nonNullableBool = nullableBool ?? false;**

            **Console.WriteLine("nonNullableInt 값: " + nonNullableInt);**

            **Console.WriteLine("nonNullableBool 값: " + nonNullableBool);**

        **}**

        **#endregion**

        **public static void Note4()**

        **{**

            **//Lambda();**

            **//Event();**

            **//Func();**

            **//Act();**

            **//Status();**

            **//LINQ();**

            **//StringBuilder();**

        **}**

    **}**

**}**