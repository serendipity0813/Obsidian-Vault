### 23.11.07 [[TIL]]

**[ 일정 및 진행목록 ]**

**- 오전회의 및 3주차 강의수강**

**- 3주차 과제 알고리즘 도전**

**- 오후 3시 컨벤션 특강**

**- 3주차 과제 알고리즘 해석**

**- TIL 작성 및 강의내용 정리**

[![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj5FJkjFR3o3gKeNKCa4JXQWHDx6r_TtwmtDPH8eqvfSe1bXTzPHnASenTLY99mDxuqypMwIrcR8un6f_iFFhA4fX-n-39jBOZaB6NF2o9AQ6EaiXGELSeQ0jgf0yJ7ycNqjZvOCLDzCwznfg2EXsIHZ-wJYnXGntrfjqzlBXnk_nYE2ElSLgfTgEhypx4D/s320/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-11-07%20215030.png)](https://www.blogger.com/blog/post/edit/3583706664799492072/6645975403202725656#)

                                        

  

****[ Summary / Problem / action / solution / feedback / TIL ]****

  

****# 클래스와 객체, 접근제한자****

****-> 클래스의 구성요소****

****-필드 : 클래스에서 사용되는 변수****

****-메소드 : 클래스에서 수행되는 동작 정의****

****-생성자 : 객체를 초기화하는 역할 / 객체 생성시 자동 초기화****

****-소멸자 : 객체 소멸시 자동 로출 / 메모리나 리소스 해제****

  

-**> 클래스 : 객체 생성을 위한 템플릿, 설계도 역할**

**-속성과 동작을 가지며 속성은 필드로, 동작은 메소드로 표현**

**-객체를 생성하기 위해서는 클래스를 사용하여 인스턴스 만들어야 한다**

**- 클래스는 데이터와 메서드를 하나로 묶은 사용자 정의 타입**

**-> 객체 : 클래스의 인스턴스, 실체화된 형태**

**-객체는 클래스로부터 생성 / 각 객체는 독립적인 상태를 가지며 고유한 데이터를 가진**

**-> 접근제한자 (클래스의 접근 권한을 지정하여 데이터 보호 가능)**

**-클래스, 필드, 메서드 등의 접근 가능한 범위를 지정**

**-> 접근제한자 예시**

**-public : 외부에서 자유롭게 접근 가능**

**-private : 같은 클래스 내부에서 접근 가능**

**- protected : 같은 클래스 내부와 상속받은 클래스 접근 가능**

****# 필드와 메소드 (클래스는 필드와 메소드로 구성)****

**-> 필드 : 클래스 내부에 선언된 변수 / 클래스의 상태를 나타내는 데이터 저장**

**-클래스나 구조체 내에서 객체의 상태(데이터) 저장하는 변수**

**-객체의 특징이나 속성 표현, 클래스의 멤버 변수로 선언**

**-보통 필드는 private 사용 / 직접 접근은 제한하고 프로퍼티로 간접 접근 허용**

**-> 메서드 : 클래스 내부에 선언되는 함수 / 클래스의 동작을 정의하고 실행** 

**-객체의 행동이나 동작 구현 / 클래스의 멤버 함수로 선언**

**-메서드는 입력값을 받아서 처리, 결과값 반환 가능**

**-객체의 상태 변경 / 다른 메서드 호출**

**-보통 public 접근 제한자 사용하여 외부 호출 허용**

**-메서드 호출을 위해선 클래스의 인스턴스 생성 필요 / 인스턴스를 통해 메서드 호출 가능**

****# 생성자 / 소멸자 / 프로퍼티****

**-> 생성자 : 객체가 생성될 때 호출되는 특별한 메소드**

**-클래스의 인스턴스를 초기화, 필요한 초기값 설정**

**-생성자는 클래스와 동일한 이름을 가지며, 반환 타임은 없음**

**-객체를 생성할 때 new 키워드와 함께 호출**

**->생성자의 특징**

**-객체를 초기화하는 과정에서 필요한 작업 수행**

**-여러개 정의할 수 있으며 매개변수의 개수와 타입에 따라 다른 생성자 호출(오버로딩)**

**-기본적으로 매개변수 없는 디폴트 생성자가 자동 생성되지만 직접 정의한 생성자가 있는 경우 디폴트 생성자 생성되지 않음**

**->소멸자 : 객체가 소멸되는 시점에서 자동으로 호출되는 특별한 메소드**

**-객체 사용 종료 후  메모리 해제 시 자동으로 호출 및 정리**

**-클래스와 동일한 이름을 가지며 이름 앞에 ~ 기호**

**-반환 타입이 없고 매개변수를 가질 수 없음**

**-c#은 가비지 컬렉터가 메모리 해제를 담당하므로 소멸자 호출을 일반적으로 권장 X**

**->소멸자의 역할**

**-자원 해제 : 파일, 네트워크, 데이터베이스 등 외부 리소스 연결 해제** 

**-메모리 해제 : 객체가 사용된 메모리 해제 후 자원 정리**

**-로깅 및 디버깅 : 객체가 소멸된 시점 로깅 작업, 디버깅 정보 기록**

**->프로퍼티 : 객체의 필드 값을 읽거나 설정에 사용되는 접근자 메소드의 조합**

**-객체의 필드에 직접 접근하지 않고 간접적으로 값을 성정하거나 읽을 수 있도록 함**

**- 필드에 대한 접근 제어와 데이터 유효성 검사 수행**

**- 객체의 상태를 나타내는 데이터 역할을 하지만 외부 접근 시 추가 로직 수행**

**->프로퍼티 구조**

**-get(반환), set(설정) 접근자로 값을 읽고 설정하는 동작 정의**

**-필요에 따라 하나를 생략하여 읽기 전용, 쓰기 전용 가**

****#상속과 다형성****

****-> 상속 : 기존의 클래스를 확장하거나 재사용하여 새로운 클래스 생성****

**- 자식 클래스는 부모 클래스의 멤버를 상속받아 사용 가능**

**- 상속을 통해 부모 클래스의 기능을 확정하거나 수정하여 새로운 클래스 정의 가능**

**-> 상속의 장점**

**-코드의 재사용성 : 상속을 통해 기존 클래스의 코드 재사용(반복적인 코드 작성 감소)**

**-계층 구조의 표현 : 코드의 구조를 명확하게 표현 가능**

**-유지보수성 향상 : 기존 클래스 수정 필요시 해당 클래스만 수정 / 유지보수성 향상**

**-> 상속의 종류**

**-단일상속 : 하나의 자식 클래스가 하나의 부모 클래스만 상속 (c#은 단일만 지원)**

**-다중상속 : 하나의 자식 클래스가 여러 부모의 클래스 상속**

**-인터페이스 상속 : 클래스가 인터페이스를 상속받는 것 / 인터페이스는 다중 상속 지원 / 클래스는 하나의 클래스와 여러 개의 인터페이스 동시 상속 가능**

**-> 상속의 특징**

**-부모 클래스의 멤버에 접근하여 기능 재사용 가능**

**-자식 클래스는 부모 클래스의 메소드를 재정의 가능 / 다형성 구현** 

**-다수의 계층적인 상속 구조 형성 가능**

**->다형성 : 같은 타입이지만 다양한 동작을 수행할 수 있는 능력**

**-> 가상메소드 : 부모 클래스에서 정의되고 자식 클래스에서 재정의 가능**

**-virtual 키워드로 선언 / override 로 사용**

**->추상클래스 : 직접적으로 인스턴스 사용불가 / 주로 상속을 위한 베이스로 사용**

**-abstract 키워드로 선언 / 추상 메소드 포함 가능**

**-추상메소드 : 구현부가 없는 메소드, 자식 클래스에서 반드시 구현해야 함**

**->오버라이딩 : 부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 재정의**

**-메서드의 이름, 매개변수, 반환타입 동일해야 함**

**->오버로딩 : 동일한 메서드 이름을 가지고 있지만 배개변수의 개수, 타입, 순서가 다른 여러 개의 메서드를 정의하는 것**

**-동일한 이름을 가진 메서드를 다양한 매개변수 조합으로 호출 가**

****# 제너릭 / out / ref****

****->제너릭 : 클래스나 메서드를 일반화시켜 다양한 자료형에 대응할 수 있는 기능****

****-코드의 재사용성이 높아짐****

****-<T> 형태의 키워드로 제너릭 선언****

**-선언 시점이 아닌 사용 시점에서 결정됨**

**-제너릭 클래스나 메소드 사용 시 구체적인 자료형을 넣어야 함**

**->out, ref : 메서드에서 매개변수 전달시 사용**

**-out : 메서드에서 반환 값을 매개변수로 전달하는 경우에 사용**

**-ref : 메서드에서 매개변수를 수정하여 원래 값에 영향을 주는 경우 사용**

**-메서드에서 값을 반환하는 것이 아니라 매개변수를 이용하여 값 전달 가능**

**-값의 변경 가능성 / 성능 이슈 / 변수 변경 여부 주의 필요**

  

****[ 회고록 ]****

****->c언어에서 다루지 못했던 개념이나 새로운 개념들이 나오니 어렵다****

****->강의 내용이 이해가 잘 되지 않아 til 에 개념 1차적으로 정리****

****-추후 블로그에 기초부터 전체까지 정리를 한번 해볼 예정****

****-> 2주차 과제 오류 및 부족한 부분 발견 / 추후 알고리즘 수정 필요****

****-> 3주차 과제가 어려워 새로 구현하는 대신 일단 코드 해석만 하고 넘길 예정****

****- 향후에 관련 문법들 추가 학습 후 나만의 방식으로 재구현 도전해보기**** 

****[ 프로젝트 계획 및 프로그램 구현 ]****

**# 오전회의 진행 후 3주차 강의 수강**

**internal class Program3**

**{**

    **//구조체 예시**

    **struct SPerson**

    **{**

        **//구조체 예시**

        **public string Sname;**

        **public int Sage;**

        **public void SPrintInfo()**

        **{**

            **Console.WriteLine($"Name: {Sname}, Age: {Sage}");**

        **}**

    **}**

    **//클래스 예시**

    **class Person**

    **{**

        **//필드 선언 예시** 

        **public string Cname;**

        **public int Cage;**

        **private string Pname;**

        **private int Page;**

        **//프로퍼티 사용 예시**

        **public string PNAME //Fname의 기능을 외부에서 호출하지만 사용은 FNAME 으로**

        **{**

            **get { return Pname; }   //값을 반환 - 읽기 전용**

            **set { Pname = value; }  //값을 받아와서 저장 - 쓰기 전용**

        **}**

        **public int PAGE**

        **{**

            **get { return Page; }**

            **set { Page = value; }**

        **}**

        **//접근제한자 예시**

        **//public string Nickname;         // 외부에서 자유롭게 접근 가능**

        **//private int Phone;           // 같은 클래스 내부에서만 접근 가능**

        **//protected string Address;  // 같은 클래스 내부와 상속받은 클래스에서만 접근 가능**

        **//디폴트 생성자**

        **public Person()**

        **{**

            **Cname = "UnKnown";**

            **Cage = 0;**

        **}**

        **//매개변수를 받는 생성자**

        **public Person(string newName, int newAge)**

        **{**

            **Cname = newName;**

            **Cage = newAge;**

        **}**

        **//메소드 예시**

        **public void CPrintInfo()**

        **{**

            **Console.WriteLine($"Name: {Cname}, Age : {Cage}");**

        **}**

    **}**

    **// 부모 클래스 (클래스 상속 예시)**

    **public class Animal**

    **{**

        **public string Aname { get; set; }**

        **public int Aage { get; set; }**

        **public void Eat()**

        **{**

            **Console.WriteLine("Animal is eating.");**

        **}**

        **public void Sleep()**

        **{**

            **Console.WriteLine("Animal is sleeping.");**

        **}**

    **}**

    **// 자식 클래스**

    **public class Dog : Animal**

    **{**

        **public void Bark()**

        **{**

            **Console.WriteLine("Dog is bark");**

        **}**

    **}**

    **public class Cat : Animal**

    **{**

        **public void Meow()**

        **{**

            **Console.WriteLine("Cat is meow");**

        **}**

        **public void Sleep() //부모 클래스의 메소드를 숨기고 재정의**

        **{**

            **Console.WriteLine("Cat Sleep");**

        **}**

    **}**

    **//클래스 상속 및 버츄얼 메소드 예시**

    **public class Unit**

    **{**

        **// 버추얼 메소드 예시**

        **public virtual void Move() //자식이 재정의를 할 수 있다**

        **{**

            **Console.WriteLine("두발로 걷기");**

        **}**

        **// 버추얼 -> 실형태가 다를 수 있으니 직접 가서 재정의 확인해봐라**

        **public void Attack()**

        **{**

            **Console.WriteLine("Unit 공격");**

        **}**

    **}**

    **public class Marine : Unit**

    **{**

    **}**

    **public class Zergling : Unit**

    **{**

        **public override void Move()**

        **{**

            **Console.WriteLine("네발로 걷기");**

        **}**

    **}**

    **//추상클래스 예시 - 권한의 차이, 강제성**

    **abstract class Shape**

    **{**

        **public abstract void Draw();**

    **}**

    **class Circle : Shape**

    **{**

        **public override void Draw()**

        **{**

            **Console.WriteLine("Drawing a Circle");**

        **}**

    **}**

    **class Square : Shape**

    **{**

        **public override void Draw()**

        **{**

            **Console.WriteLine("Drawing a Circle");**

        **}**

    **}**

    **class Triangle : Shape**

    **{**

        **public override void Draw()**

        **{**

            **Console.WriteLine("Drawing a Circle");**

        **}**

    **}**

    **//제너릭 예시**

    **class Stack<T> //선입후출 구조**

    **{**

        **private T[] elements;**

        **private int top;**

        **public Stack()**

        **{**

            **elements = new T[100];**

            **top = 0;**

        **}**

        **public void Push(T item)**

        **{**

            **elements[top++] = item;**

        **}**

        **public T Pop()**

        **{**

            **return elements[--top];**

        **}**

    **}**

    **//제너릭 2개 사용 예시**

    **class Pair<T1, T2>  //int**

    **{**

        **public T1 First { get; set; }**

        **public T2 Second { get; set; }**

        **public Pair(T1 first, T2 second)**

        **{**

            **First = first;**

            **Second = second;**

        **}**

        **public void Display()**

        **{**

            **Console.WriteLine($"First: {First}, Second: {Second}");**

        **}**

    **}**

    **// out 키워드 사용 예시**

    **static void Divide(int a, int b, out int quotient, out int remainder)**

    **{**

        **quotient = a / b; ;**

        **remainder = a % b; ;**

    **}**

    **// ref 키워드 사용 예시**

    **static void Swap(ref int a, ref int b)**

    **{**

        **int temp = a;**

        **a = b;**

        **b = temp;**

    **}**

    **static void study3()**

    **{**

        **//구조체 사용**

        **SPerson sperson1;**

        **sperson1.Sname = "structure person";**

        **sperson1.Sage = 11;**

        **sperson1.SPrintInfo();**

        **//클래스 사용 예시**

        **Person person1 = new Person(); // 클래스의 디폴트 인스턴스 생성**

        **Person person2 = new Person("Class person", 22); // 매개변수를 받는 생성자 호출**

        **person2.CPrintInfo(); // 메소드 호출**

        **//프로퍼티 사용 예시**

        **Person person = new Person();**

        **person.PNAME = "Property person";   // FNAME 프로퍼티에 값 설정**

        **person.PAGE = 33;        // FAGE 프로퍼티에 값 설정**

        **Console.WriteLine($"Name: {person.PNAME}, Age: {person.PAGE}");  // FNAME과 FAGE 프로퍼티 값 호출**

        **//클래스 상속 예시1**

        **Dog dog = new Dog();**

        **dog.Aname = "animal dog";**

        **dog.Aage = 44;**

        **dog.Eat();**

        **dog.Sleep();**

        **dog.Bark();**

        **//클래스 상속 예시2**

        **Cat cat = new Cat();**

        **cat.Aname = "animal cat";**

        **cat.Aage = 55;**

        **cat.Eat();**

        **cat.Sleep();**

        **cat.Meow();**

        **//버추얼 메소드 사용 코드**

        **Marine marine = new Marine();**

        **marine.Move();**

        **marine.Attack();**

        **Zergling zergling = new Zergling();**

        **zergling.Move();**

        **zergling.Attack();**

        **// unit은 참조의 형태, 마린과 저글링은 실제 형태**

        **List<Unit> list = new List<Unit>();**

        **list.Add(new Marine());**

        **list.Add(new Zergling());**

        **foreach (Unit unit in list)**

        **{**

            **unit.Move();**

        **}**

        **//추상클래스 사용 코드**

        **List<Shape> Slist = new List<Shape>();**

        **Slist.Add(new Circle());**

        **Slist.Add(new Triangle());**

        **Slist.Add(new Square());**

        **foreach (Shape shape in Slist)**

        **{**

            **shape.Draw();**

        **}**

        **//제너릭 예시 코드**

        **Stack<int> intStack = new Stack<int>();**

        **intStack.Push(1);**

        **intStack.Push(2);**

        **intStack.Push(3);**

        **Console.WriteLine(intStack.Pop());**

        **Pair<int, string> pair1 = new Pair<int, string>(1, "One");**

        **pair1.Display();**

        **Pair<double, bool> pair2 = new Pair<double, bool>(3.14, true);**

        **pair2.Display();**

        **//out 사용 코드**

        **int quotient, remainder;**

        **Divide(7, 3, out quotient, out remainder);**

        **Console.WriteLine($"{quotient}, {remainder}");**

        **//ref 사용 코드**

        **int x = 1, y = 2;**

        **Swap(ref x, ref y);**

        **Console.WriteLine($"{x} {y}");**

    **}**

**# 3주차 과제 중 스네이크 게임 코드 구현    // 현재 코드 해석 진행중**

**public enum Direction   //이동방향 열거**

**{**

    **LEFT,**

    **RIGHT,**

    **UP,** 

    **DOWN**

**}**

**class SnakeGame**

**{**

    **static void Main(string[] args)**

    **{**

    **}**

**}**

**public class Point**

**{**

    **public int x { get; set; }  // x값 받고 기록 및 반환**

    **public int y { get; set; }  // y값 받고 기록 및 반환**

    **public char sym {  get; set; }  // sym값 받고 기록 및 반환**

    **public Point(int _x, int _y, char _sym) // point 클래스 생성**

    **{**

        **x = _x;     // 받은 x, y, sym 값을 클래스의 x, y, sym값에 기록**

        **y = _y;**     

        **sym = _sym;**

    **}**

    **public void Draw()  // 오브젝트 그리는 함수**

    **{**

        **Console.SetCursorPosition(x, y);    // (x,y) 로 콘솔 위치 이동** 

        **Console.Write(sym);     // 해당 위치에 입력받은 심볼 출력**

    **}**

    **public void Clear() // 오브젝트 지우는 함수**

    **{**

        **sym = ' ';      // 심볼을 빈칸(' ') 으로 변경**

        **Draw();         // 드로우 함수 호출 -> 빈칸 심볼 출력**

    **}**

    **public bool IsHit(Point p)**

    **{**

        **return p.x==x && p.y==y;    //??**

    **}**

**}**

**class Snake**

**{**

    **public List<Point> body;    //뱀의 형태를 리스트로 표현**

    **public Direction direction; //뱀의 현재 진행방향 저장**

    **public Snake(Point tail, int length, Direction _direction)  // 뱀의 꼬리위치, 길이, 방향 입력받음**

    **{**

        **direction = _direction;     //뱀의 이동방향을 매개변수로 부터 받음**

        **body = new List<Point>();   //뱀의 형태를 표현할 리스트 생성**

        **for (int i = 0; i < length; i++)    //뱀의 몸 길이만큼 반복**

        **{**

            **Point p = new Point(tail.x, tail.y, '□');   //Point 클래스 생성**

            **body.Add(p);    // 리스트에 데이터 추가**

            **tail.x += 1;    // 꼬리길이 1칸 추가??**

        **}**

    **}**

    **public void Draw()      //뱀을 그리는 함수**

    **{**

        **foreach(Point p in body)   //body 리스트 안의 p를 반복 호출**

        **{**

            **p.Draw();   //호출한 포인트에 Draw 함수 호출하여 심볼그리기**

        **}**

    **}**

    **public void Move()  //뱀 위치 이동 함수**

    **{**

        **Point tail = body.First();  //body 리스트의 첫 번째 값 호출 후 tail 포인트에 삽입**

        **body.Remove(tail);  //리스트에서 tail값 삭제**

        **Point head = GetNextPoint();    //다음 이동 위치 호출 후 head포인트에 삽입**

        **body.Add(head);     //리스트에 head값 추가**

    **}**

    **public Point GetNextPoint()     //다음 위치 값 반환하는 함수**

    **{**

        **Point head = body.Last();   //head 포인트에 body 리스트 중 마지막 값 호출하여 삽입**

        **Point nextPoint = new Point(head.x, head.y, head.sym);  // 다음위치 포인트 생성 및 현재 head 값 입력**

        **switch (direction)  //입력한 방향에 따른 코드 호출**

        **{**

            **case Direction.LEFT:    //왼쪽이면 다음위치 포인트의 x값을 2 감소** 

                **nextPoint.x -= 2;**

                **break;**

            **case Direction.RIGHT:   //오른쪽이면 다음위치 포인트의 x값을 2 감소**

                **nextPoint.x += 2;**

                **break;**

            **case Direction.UP:      //위쪽이면 다음위치 포인트의 y값을 1 감소??**

                **nextPoint.y -= 1;**

                **break;**

            **case Direction.DOWN:    //아래쪽이면 다음위치 포인트의 x값을 2 감??소**

                **nextPoint.y += 1;**

                **break;**

        **}**

        **return nextPoint;   //다음 위치 변환**

    **}**

**}**

**public class FoodCreator    //음식을 랜덤으로 만들어주는 클래스**

**{**

    **int mapWidth;   //게임맵의 가로크기** 

    **int mapHeight;  //게임맵의 세로크기** 

    **char sym;       //음식 심볼 저장용** 

    **Random random = new Random();   //랜덤값 생성**

    **public FoodCreator(int mapWidth, int mapHeight, char sym)   //FoodCreator 클래스 생성**

    **{**

        **this.mapWidth = mapWidth;   //가로, 세로, 심볼 입력받은 후 저장**

        **this.mapHeight = mapHeight;** 

        **this.sym = sym;**

    **}**

    **public Point CreateFood()   //무작위 위치에 음식 생성**

    **{**

        **int x =  random.Next(2, mapWidth - 2);  // 2 부터 가로길이-2 의 x범위중 임의로 선택**

        **x = x % 2 == 1 ? x : x + 1;     //2로 나눈 후 나머지가 1일 때 x값 +1 (짝수로 만들기)** 

        **int y = random.Next(2, mapHeight - 2);  // 2 부터 세로길이-2 의  y범위중 임의로 선택**

        **return new Point(x, y, sym);    //음식이 만들어질 포인트 변환**

    **}**

  

**}**