###### 1. float와 int의 표현 가능한 수의 범위가 다른 이유는 무엇인가요?
- float와 int의 표현 가능한 수의 범위가 다른 이유는 두 데이터 타입의 구조적 차이 때문입니다. int는 4바이트(32비트)로 저장되는데, 이 중 31비트는 값을 표현하는 데 사용되고 나머지 1비트는 부호를 표현하는 데 사용됩니다. 따라서 int는 -2^31 ~ 2^31-1 범위의 정수를 표현할 수 있습니다.
	
- 반면, float는 4바이트(32비트)로 저장되는데, 이 중 8비트는 지수부를, 23비트는 가수부를 표현하는 데 사용됩니다. 지수부는 10진수의 10의 거듭제곱을 나타내고, 가수부는 십진수의 소수점을 나타냅니다. 따라서 float는 1.1754943508222875e-38 ~ 3.4028234663852886e+38 범위의 부동소수점수를 표현할 수 있습니다.

###### 2. 'ref'와 'out'의 사용 시 차이는 무엇인가요?

- 'ref'는 메서드의 호출자에게 파라미터를 참조 형태로 전달한다는 것을 의미합니다. 즉, 메서드 내부에서는 파라미터가 호출자의 변수와 같은 주소를 가리키게 됩니다. 따라서 메서드 내부에서 파라미터를 변경하면 호출자의 변수도 변경됩니다.
	
- 'out'은 메서드의 호출자에게 파라미터를 출력용으로 전달한다는 것을 의미합니다. 즉, 메서드 내부에서 파라미터를 변경할 수는 있지만, 호출자는 파라미터를 읽을 수만 있습니다.

###### 3. 접근제한자란 무엇이며, 각각 어떤 차이가 있는지 비교해서 설명해주세요.
- 접근제한자(Access Modifier)는 클래스, 변수, 메서드, 생성자 등의 멤버에 대한 접근 권한을 제어하는 역할을 합니다. 접근제한자는 클래스 내부에서 선언되는 멤버의 접근 범위를 결정합니다.
- 접근제한자는 크게 **public**, **protected**, **private**, **default**의 네 가지로 구분됩니다.
	- **public**은 모든 클래스에서 접근이 가능합니다.
	- **protected**는 같은 패키지의 클래스와 자식 클래스에서 접근이 가능합니다.
	- **private**는 선언된 클래스 내에서만 접근이 가능합니다.
	- **default**는 같은 패키지의 클래스에서만 접근이 가능합니다.접근제한자(Access Modifier)는 클래스, 변수, 메서드, 생성자 등의 멤버에 대한 접근 권한을 제어하는 역할을 합니다. 접근제한자는 클래스 내부에서 선언되는 멤버의 접근 범위를 결정합니다.
		
###### 4. struct와 class를 비교해서 설명해주세요.
- struct와 class는 모두 사용자 데이터 타입을 정의할 때 사용됩니다. 둘 다 데이터 멤버와 함수를 가질 수 있습니다. 그러나 일반적으로 struct는 데이터의 집합체로 사용되며, class는 객체 지향 프로그래밍에서 객체의 정의를 위해 사용됩니다.

- struct와 class의 차이점은 다음과 같습니다.

| 특징 | struct | class |  |
| ---- | ---- | ---- | ---- |
| 기본 접근 제한자 | public | private |  |
| 메모리 관리 | 값 타입 | 참조 타입 |  |
| 상속 | 불가능 | 가능 |  |
| 포인터 | 가능 | 가능 |  |
| 캡슐화 | 약한 캡슐화 | 강한 캡슐화 |  |

###### 5. 가비지 컬렉터에 대해 설명해주세요
- 가비지 컬렉터(Garbage Collector)는 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요없게 된 영역을 해제하는 기능입니다. 즉, 더 이상 참조하지 않는 객체의 메모리를 자동으로 해제하는 역할을 합니다.
- 가비지 컬렉터는 다음과 같은 방식으로 작동합니다.
	- **참조 계수(Reference Counting)**: 객체의 참조 수를 추적하여, 참조 수가 0이 되면 객체를 가비지로 판단합니다.
	- **세대별 수집(Generational Collection)**: 객체의 생존 기간에 따라 젊은 세대(Young Generation)와 노인 세대(Old Generation)로 나누고, 젊은 세대를 먼저 수집합니다. 젊은 세대는 생존 기간이 짧기 때문에, 가비지 컬렉터의 실행 빈도를 낮출 수 있습니다.
	-  **힙 영역의 분할(Heap Partitioning)**: 힙 영역을 작은 영역으로 분할하고, 각 영역을 독립적으로 수집합니다. 이렇게 하면, 힙 영역 전체를 한 번에 수집하는 것보다 효율적으로 가비지 컬렉터를 실행할 수 있습니다.
	    
###### 6. 가비지 컬렉터를 회피하기 위한 전략은 무엇이 있나요?
- 가비지 컬렉터를 회피하기 위한 전략은 다음과 같습니다.
	- **메모리 할당을 최소화한다.**
	- **참조 관계를 최소화한다.**
	- **큰 객체의 할당을 자제한다.**
	- **수동으로 메모리를 해제한다.**

###### 7. 가비지 컬렉션이란 무엇인지 설명해주세요.
- 5번 문제와 동일
###### 8. 박싱과 언박싱에 대하여 설명해주세요.
- 박싱(boxing)과 언박싱(unboxing)은 값 형식(value type)을 참조 형식(reference type)으로 변환하거나, 반대로 참조 형식을 값 형식으로 변환하는 과정을 의미합니다.
- 값 형식은 메모리 스택(stack)에 저장되는 반면, 참조 형식은 메모리 힙(heap)에 저장됩니다. 값 형식은 값 자체를 복사하여 저장하지만, 참조 형식은 객체의 주소를 저장합니다.
		
    1. (꼬리질문) 박싱, 언박싱을 사용할 때 주의해야 할 점이 있다면 무엇이 있나요?
		    박싱과 언박싱은 성능에 영향을 미칠 수 있습니다. 박싱은 값 형식을 복사하여 저장하기 때문에, 성능이 저하될 수 있습니다. 언박싱은 참조 형식에서 값을 추출하기 때문에, 성능이 저하될 수 있습니다.
			따라서, 박싱과 언박싱을 사용할 때는 성능을 고려해야 합니다. 박싱과 언박싱을 피할 수 있는 경우에는 피하는 것이 좋습니다.
    
###### 9. 배열과 List, ArrayList, Dictionary 의 차이점을 설명해주세요.
- 배열, List, ArrayList, Dictionary는 모두 데이터를 저장하는 자료구조입니다. 그러나, 각 자료구조는 다음과 같은 차이점이 있습니다.

	**배열**

	- 선형 자료구조입니다.
	- 데이터의 타입이 모두 동일해야 합니다.
	- 크기를 미리 지정해야 합니다.
	- 데이터의 삽입과 삭제가 느립니다.
	
	**List**
	
	- 선형 자료구조입니다.
	- 데이터의 타입이 모두 동일하거나, 모두 다를 수 있습니다.
	- 크기를 미리 지정할 필요가 없습니다.
	- 데이터의 삽입과 삭제가 빠릅니다.

	**ArrayList**
	
	- List의 구현체입니다.
	- 데이터의 타입이 모두 동일하거나, 모두 다를 수 있습니다.
	- 크기를 미리 지정할 필요가 없습니다.
	- 데이터의 삽입과 삭제가 빠릅니다.

	**Dictionary**
	
	- 비선형 자료구조입니다.
	- 키와 값으로 구성됩니다.
	- 키의 타입은 고정되어 있지만, 값의 타입은 모두 동일하거나, 모두 다를 수 있습니다.
	- 크기를 미리 지정할 필요가 없습니다.
	- 데이터의 삽입과 삭제가 빠릅니다.

	1. (꼬리질문) Dictionary는 어떻게 구현해야 하나요?
		      
		Dictionary는 키-값 쌍으로 데이터를 저장하는 자료구조입니다. 키의 타입은 고정되어 있지만, 값의 타입은 모두 동일하거나, 모두 다를 수 있습니다.
		
		Dictionary를 구현하기 위해서는 다음과 같은 단계를 거칩니다.
		
		1. 키의 타입과 값의 타입을 지정합니다.
		2. Dictionary 클래스의 인스턴스를 생성합니다.
		3. 키-값 쌍을 추가합니다.
		4. 키-값 쌍을 검색합니다.
		5. 키-값 쌍을 삭제합니다.
	
    2.  (꼬리질문) Dictionary 검색이 빠른 이유는 무엇인가요?
			Dictionary 검색이 빠른 이유는 다음과 같은 이유 때문입니다.
		
		- **해시 테이블을 사용합니다.** 해시 테이블은 키를 해시 함수에 적용하여 고유한 인덱스를 생성하고, 해당 인덱스에 값을 저장하는 자료구조입니다. 키가 주어지면, 해시 함수를 사용하여 인덱스를 빠르게 찾을 수 있습니다.
		- **키의 타입이 고정되어 있습니다.** 키의 타입이 고정되어 있으므로, 해시 함수를 미리 생성하여 사용할 수 있습니다. 이는 검색 속도를 더욱 빠르게 해줍니다.
		
		Dictionary 검색의 시간 복잡도는 O(1)입니다. 이는 최악의 경우에도 O(1)의 시간이 소요된다는 의미입니다. 이는 배열의 경우 최악의 경우 O(n)의 시간이 소요되는 것과 비교하면 매우 빠른 속도입니다.

**차이점 요약**

|특징|배열|List|ArrayList|Dictionary|
|---|---|---|---|---|
|자료구조|선형|선형|선형|비선형|
|데이터 타입|동일|동일 또는 다름|동일 또는 다름|고정 또는 다름|
|크기 지정|필요|필요 없음|필요 없음|필요 없음|
|삽입/삭제 속도|느림|빠름|빠름|빠름|
|사용 예|배열 대용|동적 배열|동적 배열|키-값 저장|

###### 10. 제네릭이란 무엇인가요?

- 제네릭은 컴파일 시점에 타입을 지정하는 기법입니다. 제네릭을 사용하면, 동일한 코드로 다양한 타입의 데이터를 처리할 수 있습니다.

제네릭을 사용하면 다음과 같은 장점이 있습니다.

- **코드의 재사용성을 높일 수 있습니다.** 동일한 코드로 다양한 타입의 데이터를 처리할 수 있으므로, 코드의 재사용성을 높일 수 있습니다.
- **타입 안정성을 높일 수 있습니다.** 제네릭을 사용하면, 컴파일 시점에 타입을 확인할 수 있으므로, 타입 안정성을 높일 수 있습니다.
- **메모리 사용량을 줄일 수 있습니다.** 제네릭을 사용하면, 필요에 따라 메모리를 할당하고 해제할 수 있으므로, 메모리 사용량을 줄일 수 있습니다.

제네릭은 다음과 같은 방법으로 사용됩니다.

- **클래스와 인터페이스에 타입 변수를 선언합니다.**
- **타입 변수를 사용하여 클래스와 인터페이스의 메서드와 속성을 구현합니다.**

예를 들어, 다음과 같이 제네릭 클래스를 선언할 수 있습니다.

C#

```
// 제네릭 클래스
public class GenericClass<T>
{
    // 제네릭 변수 T
    private T data;

    // 생성자
    public GenericClass(T data)
    {
        this.data = data;
    }

    // 메서드
    public T getData()
    {
        return this.data;
    }
}
```

위 클래스는 T라는 타입 변수를 선언합니다. T는 클래스 내에서 다양한 타입으로 사용할 수 있습니다.

다음과 같이 제네릭 클래스를 사용하여 객체를 생성할 수 있습니다.

C#

```
// int 타입의 객체를 생성합니다.
GenericClass<int> intObject = new GenericClass<int>(10);

// string 타입의 객체를 생성합니다.
GenericClass<string> stringObject = new GenericClass<string>("Hello, world!");
```


위 예에서 intObject는 int 타입의 객체이고, stringObject는 string 타입의 객체입니다.

제네릭은 다양한 자료구조와 클래스에서 사용됩니다. 예를 들어, List, Dictionary, LinkedList 등의 자료구조는 제네릭을 사용하여 다양한 타입의 데이터를 처리할 수 있습니다.

###### 11. 델리게이트(Delegate)의 개념에 대해 설명해주세요.
  
델리게이트는 메서드를 참조하는 타입입니다. 델리게이트를 사용하면, 메서드를 함수 포인터처럼 사용할 수 있습니다.

델리게이트를 사용하면 다음과 같은 장점이 있습니다.

- **코드의 재사용성을 높일 수 있습니다.** 델리게이트를 사용하여 메서드를 참조할 수 있으므로, 동일한 메서드를 여러 곳에서 사용할 수 있습니다.
- **코드의 가독성과 유지 보수성을 높일 수 있습니다.** 델리게이트를 사용하여 메서드를 참조할 수 있으므로, 메서드의 호출을 보다 간결하고 직관적으로 표현할 수 있습니다.
- **코드의 유연성을 높일 수 있습니다.** 델리게이트를 사용하여 메서드를 동적으로 바꿀 수 있습니다.

델리게이트는 다음과 같은 방법으로 사용됩니다.

- **델리게이트를 선언합니다.**
- **델리게이트를 초기화합니다.**
- **델리게이트를 사용하여 메서드를 호출합니다.**

예를 들어, 다음과 같이 델리게이트를 선언할 수 있습니다.

C#

```
// 델리게이트를 선언합니다.
public delegate void MyDelegate(int x);
```


위 델리게이트는 매개변수로 int 타입의 x를 가지는 메서드를 참조합니다.

다음과 같이 델리게이트를 초기화할 수 있습니다.

C#

```
// 델리게이트를 초기화합니다.
MyDelegate myDelegate = new MyDelegate(MyMethod);
```


위 예에서 MyMethod는 int 타입의 x를 가지는 메서드입니다. myDelegate는 MyMethod 메서드를 참조합니다.

다음과 같이 델리게이트를 사용하여 메서드를 호출할 수 있습니다.

C#

```
// 델리게이트를 사용하여 메서드를 호출합니다.
myDelegate(10);
```

위 예에서 myDelegate는 MyMethod 메서드를 호출합니다. MyMethod 메서드는 매개변수로 10을 전달받습니다.

델리게이트는 이벤트 처리와 함수 포인터로 많이 사용됩니다.

이벤트 처리에서 델리게이트를 사용하면, 이벤트를 처리할 메서드를 보다 간편하게 지정할 수 있습니다.

함수 포인터로 델리게이트를 사용하면, 함수를 동적으로 바꿀 수 있습니다.

    
###### 12. 'delegate', 'event', 'action', 'func' 간의 차이를 설명해주세요.

**delegate**와 **event**는 모두 메서드를 참조하는 타입이지만, 다음과 같은 차이점이 있습니다.

|특징|delegate|event|
|---|---|---|
|정의 위치|클래스 내부|클래스 내부 또는 인터페이스|
|사용 목적|메서드 참조|이벤트 처리|
|매개변수|제한 없음|제한 없음|
|반환 값|제한 없음|제한 없음|


**delegate**는 클래스 내부에서 정의할 수 있습니다. **delegate**는 메서드를 참조하는 데 사용됩니다. **delegate**는 이벤트 처리 외에도 함수 포인터로 사용할 수 있습니다.

**event**는 클래스 내부 또는 인터페이스에서 정의할 수 있습니다. **event**는 이벤트 처리에 사용됩니다. **event**는 **delegate**를 사용하여 이벤트를 처리할 메서드를 지정합니다.

**action**과 **func**는 모두 **delegate**의 제네릭 버전입니다. **action**은 반환 값이 없는 **delegate**를 나타냅니다. **func**는 반환 값이 있는 **delegate**를 나타냅니다.

**action**과 **func**는 **delegate**와 동일한 방식으로 사용됩니다. **action**은 반환 값이 없는 메서드를 참조하는 데 사용됩니다. **func**는 반환 값이 있는 메서드를 참조하는 데 사용됩니다.

다음은 **delegate**, **event**, **action**, **func**의 사용 예입니다.

C#

```
// delegate
public delegate void MyDelegate(int x);

// event
public event MyDelegate MyEvent;

// action
public delegate void MyAction();

// func
public delegate int MyFunc(int x);
```

위 코드에서 **MyDelegate**는 매개변수로 int 타입의 x를 가지는 메서드를 참조합니다. **MyEvent**는 **MyDelegate**를 사용하여 이벤트를 처리할 메서드를 지정합니다. **MyAction**은 반환 값이 없는 메서드를 참조합니다. **MyFunc**는 반환 값이 있는 메서드를 참조합니다.

다음은 **delegate**와 **event**를 사용하는 예입니다.

C#

```
// delegate와 event를 사용하는 예
public class MyClass
{
    public delegate void MyDelegate();

    public event MyDelegate MyEvent;

    public void MyMethod()
    {
        // delegate를 사용하여 메서드를 호출합니다.
        MyDelegate myDelegate = new MyDelegate(MyMethod);
        myDelegate();

        // event를 사용하여 메서드를 호출합니다.
        MyEvent += MyMethod;
        MyEvent();
    }
}
```


위 코드에서 **MyClass** 클래스는 **MyDelegate**라는 **delegate**와 **MyEvent**라는 **event**를 정의합니다. **MyMethod** 메서드는 **MyDelegate**를 사용하여 호출할 수 있습니다. **MyEvent** 이벤트는 **MyMethod** 메서드를 사용하여 처리할 수 있습니다.

다음은 **action**과 **func**를 사용하는 예입니다.

C#

```
// action과 func를 사용하는 예
public class MyClass
{
    public static void Main(string[] args)
    {
        // action을 사용하여 메서드를 호출합니다.
        MyAction myAction = Action(() => Console.WriteLine("Hello, world!"));
        myAction();

        // func을 사용하여 메서드를 호출합니다.
        MyFunc myFunc = Func(x => x * x);
        int result = myFunc(10);
        Console.WriteLine(result);
    }
}
```


위 코드에서 **MyClass** 클래스는 **MyAction**이라는 **action**과 **MyFunc**라는 **func**를 정의합니다. **MyAction**은 반환 값이 없는 메서드를 참조합니다. **MyFunc**는 반환 값이 있는 메서드를 참조합니다.

**action**과 **func**는 **delegate**와 동일한 방식으로 사용됩니다. **action**은 반환 값이 없는 메서드를 참조하는 데 사용됩니다. **func**는 반환 값이 있는 메서드를 참조하는 데 사용됩니다.

    1. (꼬리질문) 프로젝트에 적용해 본 경험이 있다면 설명해주세요.
	    플레이어 레벨업 시 퀘스트, 아이템 등등의 잠금 해제를 위해 event 사용
		플레이어 캐릭터의 이동 처리(속도, 방향 등등) 
    
###### 13. 람다식(Lambda Expression)이 무엇인지 설명해주세요.

람다식(Lambda Expression)은 메서드를 하나의 표현식으로 표현한 것입니다. 람다식은 다음과 같은 특징을 가지고 있습니다.

- **익명 함수(Anonymous Function)**라고도 합니다.
- **메서드의 선언과 구현을 동시에 할 수 있습니다.**
- **메서드의 매개변수와 반환 값을 지정할 수 있습니다.**
- **메서드의 몸체는 하나의 표현식으로 구성됩니다.**

람다식은 다음과 같은 방법으로 사용됩니다.

- **델리게이트에 할당합니다.**
- **함수 포인터로 사용합니다.**
- **컬렉션의 요소를 처리하는 데 사용합니다.**

다음은 람다식의 사용 예입니다.

C#

```
// 델리게이트에 할당하는 예
public delegate void MyDelegate(int x);

// 람다식을 정의합니다.
MyDelegate myDelegate = (x) => Console.WriteLine(x);

// 람다식을 호출합니다.
myDelegate(10);
```



위 예에서 myDelegate는 int 타입의 x를 가지는 MyDelegate 델리게이트를 참조합니다. 람다식은 x를 콘솔에 출력하는 작업을 수행합니다.

다음은 함수 포인터로 사용하는 예입니다.

C#

```
// 함수 포인터로 사용하는 예
public static void Main(string[] args)
{
    // 람다식을 정의합니다.
    Action myAction = () => Console.WriteLine("Hello, world!");

    // 람다식을 함수 포인터로 사용합니다.
    myAction();
}
```


위 예에서 myAction은 반환 값이 없는 Action 델리게이트를 참조합니다. 람다식은 "Hello, world!"를 콘솔에 출력하는 작업을 수행합니다.
    
###### 14. 콜백이란 무엇인가요? 사용해봤는지?

- 콜백은 함수의 인수로 전달되는 함수입니다. 콜백 함수는 함수가 호출된 후 또는 특정 이벤트가 발생한 후에 호출됩니다.

콜백은 다음과 같은 용도로 사용됩니다.

- **비동기 작업을 처리하는 데 사용됩니다.**
- **이벤트를 처리하는 데 사용됩니다.**
- **함수의 동작을 확장하는 데 사용됩니다.**

다음은 콜백의 사용 예입니다.

C#

```
// 비동기 작업을 처리하는 예
public static void Main(string[] args)
{
    // 비동기 작업을 시작합니다.
    Task.Run(() =>
    {
        // 비동기 작업을 수행합니다.
        Thread.Sleep(1000);

        // 콜백 함수를 호출합니다.
        Callback(10);
    });
}

// 콜백 함수
private static void Callback(int value)
{
    // 콜백 함수가 호출된 후 수행할 작업을 지정합니다.
    Console.WriteLine(value);
}
```


위 예에서 비동기 작업이 시작되면 1초 후에 Callback 함수가 호출됩니다. Callback 함수는 콜백 함수로서, 비동기 작업이 완료된 후 수행할 작업을 지정합니다.

###### 15. 정렬 알고리즘이란 무엇이며, 사용 이유에 대해 설명해주세요.

정렬 알고리즘은 데이터를 특정한 기준에 따라 순서대로 나열하는 알고리즘입니다. 정렬 알고리즘은 다음과 같은 이유로 사용됩니다.

- **데이터를 검색하기 쉽도록 하기 위해 사용됩니다.** 정렬된 데이터는 검색 알고리즘이 효율적으로 작동할 수 있도록 합니다.
- **데이터를 분석하기 쉽도록 하기 위해 사용됩니다.** 정렬된 데이터는 데이터의 패턴을 쉽게 파악할 수 있도록 합니다.
- **데이터를 효율적으로 저장하기 위해 사용됩니다.** 정렬된 데이터는 저장 공간을 효율적으로 사용할 수 있도록 합니다.

정렬 알고리즘은 다음과 같은 종류로 구분할 수 있습니다.

- **비교 정렬 알고리즘:** 데이터의 크기를 비교하여 정렬하는 알고리즘입니다. 대표적인 비교 정렬 알고리즘으로는 선택 정렬, 버블 정렬, 삽입 정렬, 퀵 정렬, 병합 정렬 등이 있습니다.
- **비교가 필요 없는 정렬 알고리즘:** 데이터의 위치를 이동하여 정렬하는 알고리즘입니다. 대표적인 비교가 필요 없는 정렬 알고리즘으로는 셸 정렬, 힙 정렬 등이 있습니다.

정렬 알고리즘을 선택할 때는 다음과 같은 요소를 고려해야 합니다.

- **데이터의 크기:** 데이터의 크기가 작다면 비교 정렬 알고리즘을 사용해도 충분합니다. 하지만 데이터의 크기가 크다면 비교가 필요 없는 정렬 알고리즘을 사용하는 것이 효율적입니다.
- **데이터의 특성:** 데이터의 특성에 따라 정렬 알고리즘의 성능이 달라질 수 있습니다. 예를 들어, 데이터가 이미 부분적으로 정렬되어 있다면, 선택 정렬이나 버블 정렬보다는 삽입 정렬이나 퀵 정렬을 사용하는 것이 효율적입니다.


###### 16. 선택 정렬과 버블 정렬에 대해 설명해주시고, 코드를 작성해보세요.

**선택 정렬**은 데이터 중에서 가장 작은 값을 찾아서 맨 앞에 위치시키는 과정을 반복하여 정렬하는 알고리즘입니다.

```
public static void SelectionSort(int[] numbers)
{
    for (int i = 0; i < numbers.Length - 1; i++)
    {
        int minIndex = i;
        for (int j = i + 1; j < numbers.Length; j++)
        {
            if (numbers[minIndex] > numbers[j])
            {
                minIndex = j;
            }
        }

        int temp = numbers[i];
        numbers[i] = numbers[minIndex];
        numbers[minIndex] = temp;
    }
}
```


위 코드는 선택 정렬 알고리즘을 구현한 코드입니다. 먼저, `i`를 0으로 초기화하고, `i`가 배열의 마지막 요소 직전까지 반복합니다.

다음으로, `i`부터 배열의 마지막 요소까지 반복하면서 `i`보다 작은 값을 찾습니다. `minIndex` 변수를 사용하여 가장 작은 값의 인덱스를 저장합니다.

마지막으로, `i`와 `minIndex`의 값을 교환합니다.

**버블 정렬**은 인접한 두 개의 데이터를 비교하여 크기가 더 작은 데이터를 앞으로 보내는 과정을 반복하여 정렬하는 알고리즘입니다.

```
public static void BubbleSort(int[] numbers)
{
    for (int i = numbers.Length - 1; i >= 0; i--)
    {
        for (int j = 0; j < i; j++)
        {
            if (numbers[j] > numbers[j + 1])
            {
                int temp = numbers[j];
                numbers[j] = numbers[j + 1];
                numbers[j + 1] = temp;
            }
        }
    }
}
```


위 코드는 버블 정렬 알고리즘을 구현한 코드입니다. 먼저, `i`를 배열의 마지막 요소로 초기화하고, `i`가 0보다 크거나 같을 때까지 반복합니다.

다음으로, `0`부터 `i`까지 반복하면서 인접한 두 개의 데이터를 비교합니다. `j`번째 데이터가 `j+1`번째 데이터보다 크다면, 두 개의 데이터를 교환합니다.

선택 정렬과 버블 정렬은 모두 비교 정렬 알고리즘입니다. 선택 정렬은 최악의 경우 O(n^2)의 시간 복잡도를 가지지만, 평균적으로는 O(n log n)의 시간 복잡도를 가집니다. 버블 정렬은 최악의 경우 O(n^2)의 시간 복잡도를 가지지만, 평균적으로는 O(n)의 시간 복잡도를 가집니다.

일반적으로 선택 정렬은 버블 정렬보다 효율적이지만, 구현이 더 복잡합니다. 버블 정렬은 구현이 간단하지만, 효율이 떨어집니다.

###### 17. 스택, 힙 메모리란 무엇이며 어떤 차이가 있는지 비교해서 설명해주세요.

스택과 힙은 프로그래밍에서 사용하는 두 가지 메모리 영역입니다. 스택은 LIFO(Last In First Out) 방식으로 데이터가 저장되고, 힙은 메모리 관리자가 관리하는 메모리 영역입니다.

**스택 메모리**는 함수 호출과 반환을 위해 사용되는 메모리 영역입니다. 함수가 호출되면 스택에 함수의 매개변수, 지역 변수, 함수의 반환 값이 저장됩니다. 함수가 반환되면 스택에서 해당 함수의 데이터가 제거됩니다.

스택 메모리의 특징은 다음과 같습니다.

- LIFO 방식으로 데이터가 저장됩니다.
- 함수 호출과 반환에 사용됩니다.
- 프로그래머가 직접 관리하지 않습니다.

**힙 메모리**는 프로그래머가 직접 관리하는 메모리 영역입니다. 힙 메모리는 동적으로 메모리를 할당하고 해제할 수 있습니다.

힙 메모리의 특징은 다음과 같습니다.

- 프로그래머가 직접 관리합니다.
- 동적으로 메모리를 할당하고 해제할 수 있습니다.

스택 메모리와 힙 메모리의 차이점은 다음과 같습니다.

|특징|스택 메모리|힙 메모리|
|---|---|---|
|데이터 저장 방식|LIFO|자유롭게|
|사용 목적|함수 호출과 반환|동적 메모리 할당|
|관리 주체|프로그래밍 언어|프로그래머|

###### 18. 값 형식과 참조 형식의 차이에 대해 설명해주세요.

값 형식과 참조 형식은 프로그래밍 언어에서 데이터 형식을 구분하는 두 가지 방법입니다. 값 형식은 데이터의 값을 직접 저장하는 반면, 참조 형식은 데이터의 주소를 저장합니다.

**값 형식**은 데이터의 값을 직접 저장하는 형식입니다. 값 형식의 변수는 변수 자체에 데이터의 값이 저장됩니다. 따라서, 값 형식의 변수를 다른 변수에 할당하면 해당 변수의 값이 복사됩니다.

값 형식의 예로는 다음과 같은 것들이 있습니다.

- 기본 데이터 형식: int, float, double, char, bool
- 구조체: struct
- 열거형: enum

**참조 형식**은 데이터의 주소를 저장하는 형식입니다. 참조 형식의 변수는 변수 자체에 데이터의 주소가 저장됩니다. 따라서, 참조 형식의 변수를 다른 변수에 할당하면 해당 변수가 참조하는 데이터가 변경됩니다.

참조 형식의 예로는 다음과 같은 것들이 있습니다.

- 클래스: class
- 인터페이스: interface
- 배열: array
- 리스트: list

값 형식과 참조 형식의 차이는 다음과 같습니다.

|특징|값 형식|참조 형식|
|---|---|---|
|저장 방식|데이터의 값을 직접 저장|데이터의 주소를 저장|
|변수 할당|값을 복사|참조를 복사|
|변수의 크기|데이터의 크기|주소의 크기|
|메모리 할당 위치|스택|힙|
|복사 비용|저장된 데이터의 크기만큼|주소의 크기만큼|
|참조 변수의 개수|제한 없음|제한 없음|

값 형식은 다음과 같은 경우에 사용됩니다.

- 데이터의 값을 직접 변경할 필요가 없는 경우
- 데이터의 크기가 작은 경우
- 메모리 사용량을 줄여야 하는 경우

참조 형식은 다음과 같은 경우에 사용됩니다.

- 데이터의 값을 직접 변경해야 하는 경우
- 데이터의 크기가 큰 경우
- 메모리 사용량을 늘려도 상관없는 경우


###### 19. 자료구조의 종류는 무엇이 있으며 각각 어떤 차이점이 있는지 설명해주세요

자료구조는 데이터를 효율적으로 저장하고 처리하기 위해 사용되는 데이터 구조입니다. 자료구조는 다음과 같은 기준으로 분류할 수 있습니다.

- **자료형의 종류에 따른 분류**
    
    - 선형 자료구조: 데이터 요소가 선형적으로 연결된 자료구조입니다.
    - 비선형 자료구조: 데이터 요소가 선형적으로 연결되지 않은 자료구조입니다.
- **데이터의 접근 방식에 따른 분류**
    
    - 순차 자료구조: 데이터 요소를 순차적으로 접근하는 자료구조입니다.
    - 논리 자료구조: 데이터 요소를 논리적으로 접근하는 자료구조입니다.
- **데이터의 변경 가능성에 따른 분류**
    
    - 정적 자료구조: 데이터의 크기가 고정된 자료구조입니다.
    - 동적 자료구조: 데이터의 크기가 가변적인 자료구조입니다.

**선형 자료구조**는 데이터 요소가 선형적으로 연결된 자료구조입니다. 선형 자료구조의 대표적인 예로는 다음과 같은 것들이 있습니다.

- **배열:** 같은 타입의 데이터를 순차적으로 저장하는 자료구조입니다.
- **연결 리스트:** 데이터 요소가 연결리스트로 연결된 자료구조입니다.
- **큐:** 먼저 들어온 데이터가 먼저 나가는 자료구조입니다.
- **스택:** 먼저 들어온 데이터가 나중에 나가는 자료구조입니다.

**비선형 자료구조**는 데이터 요소가 선형적으로 연결되지 않은 자료구조입니다. 비선형 자료구조의 대표적인 예로는 다음과 같은 것들이 있습니다.

- **트리:** 데이터 요소가 부모-자식 관계로 연결된 자료구조입니다.
- **그래프:** 데이터 요소가 서로 연결된 자료구조입니다.

**순차 자료구조**는 데이터 요소를 순차적으로 접근하는 자료구조입니다. 순차 자료구조의 대표적인 예로는 다음과 같은 것들이 있습니다.

- **배열:** 배열의 요소는 인덱스를 사용하여 순차적으로 접근할 수 있습니다.
- **연결 리스트:** 연결 리스트의 요소는 포인터를 사용하여 순차적으로 접근할 수 있습니다.

**논리 자료구조**는 데이터 요소를 논리적으로 접근하는 자료구조입니다. 논리 자료구조의 대표적인 예로는 다음과 같은 것들이 있습니다.

- **트리:** 트리의 요소는 부모-자식 관계를 사용하여 논리적으로 접근할 수 있습니다.
- **그래프:** 그래프의 요소는 연결 관계를 사용하여 논리적으로 접근할 수 있습니다.

**정적 자료구조**는 데이터의 크기가 고정된 자료구조입니다. 정적 자료구조의 대표적인 예로는 다음과 같은 것들이 있습니다.

- **배열:** 배열의 크기는 선언 시 설정되므로, 크기를 변경할 수 없습니다.

**동적 자료구조**는 데이터의 크기가 가변적인 자료구조입니다. 동적 자료구조의 대표적인 예로는 다음과 같은 것들이 있습니다.

- **연결 리스트:** 연결 리스트의 요소는 필요에 따라 추가하거나 제거할 수 있습니다.
- **큐:** 큐의 크기는 필요에 따라 조절할 수 있습니다.
- **스택:** 스택의 크기는 필요에 따라 조절할 수 있습니다.

    a. 위 자료구조는 무조건 좋은가요?
		아닙니다. 자료구조는 각각의 특성과 장단점이 있으므로, 상황에 맞게 적절하게 사용해야 합니다.
		예를 들어, 배열은 접근 속도가 빠르지만, 크기가 고정되어 있기 때문에 데이터의 크기가 가변적인 경우 적합하지 않습니다. 연결 리스트는 크기가 가변적이지만, 접근 속도가 배열보다 느립니다.
		따라서, 프로그램을 작성할 때는 다음과 같은 사항을 고려하여 적절한 자료구조를 선택해야 합니다.
		- **데이터의 크기:** 데이터의 크기가 고정적인지 가변적인지 확인합니다.
		- **데이터의 접근 방식:** 데이터를 순차적으로 접근해야 하는지 논리적으로 접근해야 하는지 확인합니다.
		- **데이터의 변경 가능성:** 데이터의 크기를 변경할 수 있는지 여부를 확인합니다.
    
###### 20. 객체지향이란 무엇인지 설명해주세요.

객체지향은 프로그래밍에서 사용하는 패러다임 중 하나로, 현실 세계의 사물과 개념을 객체로 모델링하여 프로그램하는 방법입니다. 객체는 속성(state)과 행위(behavior)를 가지고 있습니다. 속성은 객체의 상태를 나타내는 데이터이고, 행위는 객체가 수행할 수 있는 작업입니다.

객체지향 프로그래밍은 다음과 같은 네 가지 특징을 가지고 있습니다.

- **추상화:** 현실 세계의 사물과 개념을 객체로 추상화하여 모델링합니다.
- **캡슐화:** 객체의 속성과 행위를 하나의 단위로 묶어 외부로부터 보호합니다.
- **상속:** 상위 객체의 속성과 행위를 하위 객체가 상속받을 수 있습니다.
- **다형성:** 객체의 동일한 이름의 메서드가 서로 다른 동작을 할 수 있습니다.

객체지향 프로그래밍은 다음과 같은 장점을 가지고 있습니다.

- **복잡한 문제를 쉽게 해결할 수 있습니다.** 현실 세계의 사물과 개념을 객체로 모델링하면 복잡한 문제를 작은 단위로 나누어 해결할 수 있습니다.
- **프로그램의 재사용성이 높아집니다.** 상속을 사용하여 상위 객체의 코드를 하위 객체에서 재사용할 수 있습니다.
- **유지보수가 용이합니다.** 캡슐화를 사용하여 객체의 내부 구현을 외부로부터 보호하면, 객체의 속성과 행위를 변경해도 외부 코드를 수정할 필요가 없습니다.
- 
    1. (꼬리질문) 객체지향의 특징은 무엇이 있나요?
	    객체지향 프로그래밍은 다음과 같은 네 가지 특징을 가지고 있습니다.
		- **추상화:** 현실 세계의 사물과 개념을 객체로 추상화하여 모델링합니다.
		- **캡슐화:** 객체의 속성과 행위를 하나의 단위로 묶어 외부로부터 보호합니다.
		- **상속:** 상위 객체의 속성과 행위를 하위 객체가 상속받을 수 있습니다.
		- **다형성:** 객체의 동일한 이름의 메서드가 서로 다른 동작을 할 수 있습니다.
	    
    2. (꼬리질문) OOP란?
		OOP는 **객체 지향 프로그래밍(Object-Oriented Programming)**의 약자로, 현실 세계의 사물과 개념을 객체로 모델링하여 프로그램하는 방법입니다.
    
    3. (꼬리질문) SOLID 원칙은 무엇인가요?
		    SOLID 원칙은 객체 지향 프로그래밍에서 지켜야 할 5가지 기본 원칙을 의미합니다. SOLID는 로버트 마틴이 2000년대 초반에 명명한 것으로, 마이클 페더스가 두문자어 기억술로 소개했습니다.
		
		**SOLID 원칙은 다음과 같습니다.**
		
		- **SRP(Single Responsibility Principle)**: 단일 책임 원칙
		- **OCP(Open-Closed Principle)**: 개방-폐쇄 원칙
		- **LSP(Liskov Substitution Principle)**: 리스코프 치환 원칙
		- **DIP(Dependency Inversion Principle)**: 의존 역전 원칙
		- **ISP(Interface Segregation Principle)**: 인터페이스 분리 원칙
		
		**SRP(Single Responsibility Principle)**은 한 클래스는 하나의 책임만 가져야 한다는 원칙입니다. 한 클래스가 여러 가지 책임을 가지면 클래스가 복잡해지고 유지보수가 어려워집니다.
		
		**OCP(Open-Closed Principle)**는 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다는 원칙입니다. 새로운 기능을 추가할 때 기존 코드를 변경하지 않아야 합니다.
		
		**LSP(Liskov Substitution Principle)**는 하위 클래스는 자신의 상위 클래스에 의해 대체될 수 있어야 한다는 원칙입니다. 하위 클래스가 상위 클래스의 약속을 위반하면 상위 클래스를 사용하는 코드와의 호환성이 깨집니다.
		
		**DIP(Dependency Inversion Principle)**는 상위 모듈은 하위 모듈에 의존하지 말고, 추상화에 의존해야 한다는 원칙입니다. 이는 상위 모듈이 하위 모듈의 구현에 의존하면 하위 모듈의 변경으로 상위 모듈이 영향을 받게 되기 때문입니다.
		
		**ISP(Interface Segregation Principle)**는 인터페이스는 구현에 의존해서는 안 되고, 최소한의 책임만을 가지는 인터페이스로 분리되어야 한다는 원칙입니다. 인터페이스가 너무 많으면 관리가 어려워지고, 인터페이스가 너무 적으면 구현이 복잡해집니다.
