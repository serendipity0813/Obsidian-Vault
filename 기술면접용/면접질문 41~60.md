###### 41. 유니티 최적화 기법은 어떤 것들이 있나요?
    유니티에서의 최적화는 게임이 원활하게 동작하고, 성능이 향상되도록 하는데 중요한 부분입니다. 몇 가지 주요한 최적화 기법은 다음과 같습니다:

1. **오브젝트 풀링(Object Pooling):**
   - 반복적으로 생성되고 소멸되는 객체들을 풀에 저장하고 재활용함으로써, 객체 생성과 소멸에 따른 오버헤드를 줄입니다.

2. **레벨 오브 디테일(LOD, Level of Detail):**
   - 먼 거리에서는 더 단순한 모델 또는 텍스처를 사용하고, 가까이 다가갈수록 상세한 모델 또는 텍스처를 사용하여 성능을 최적화합니다.

3. **뷰 프러스텀 컬링(View Frustum Culling):**
   - 카메라 시야 밖에 있는 객체를 렌더링하지 않고 제거하여 성능을 향상시킵니다.

4. **정점 오프셋(Vertex Offset):**
   - 정적인 오브젝트들의 정점 위치를 적절하게 오프셋하여, 정점 수를 줄이고 성능을 향상시킵니다.

5. **배치 처리(Batch Processing):**
   - 유사한 속성을 가진 오브젝트들을 동일한 배치에 그룹화하여 GPU에 효율적으로 처리할 수 있도록 합니다.

6. **쉐이더 최적화(Shader Optimization):**
   - 불필요한 계산을 최소화하고, 최적의 쉐이더를 사용하여 GPU 부담을 줄입니다.

7. **텍스처 압축(Texture Compression):**
   - 텍스처를 압축하여 메모리 사용을 최적화하고 로딩 시간을 단축합니다.

8. **애니메이션 최적화(Animation Optimization):**
   - 필요 없는 애니메이션 업데이트를 줄이고, 정확한 레벨의 디테일로 제한하여 성능을 향상시킵니다.

9. **UI 최적화(UI Optimization):**
   - UI 업데이트를 효율적으로 처리하고, 필요 없는 UI 요소를 비활성화하여 성능을 향상시킵니다.

10. **불필요한 렌더링 방지(Preventing Unnecessary Rendering):**
    - 렌더링이 필요하지 않은 오브젝트들을 비활성화하고, 불필요한 렌더링을 피하여 GPU 부하를 줄입니다.

이러한 최적화 기법을 적절히 조합하여 게임이 목표하는 플랫폼에서 최적의 성능을 얻을 수 있습니다.

	1. 최적화를 해본 적이 있나요? 없다면 어떤 최적화가 있는지 설명해주세요.
    
	2. 최적화에서 가장 중요한 부분은 무엇인가요?
    
	3. 최적화를 위해서 적용해본 텍스쳐 포맷이 있나요?

###### 42. 가비지컬렉터(GC)란 무엇인가요?
가비지 컬렉터(Garbage Collector, GC)는 프로그램에서 사용하지 않는 메모리를 자동으로 식별하고 해제하는 기능을 수행하는 프로그램 또는 모듈입니다. 주로 메모리 관리를 담당하여 프로그래머가 명시적으로 메모리를 할당하거나 해제하지 않아도 됩니다.

다양한 프로그래밍 언어에서 가비지 컬렉션을 지원하는데, 몇 가지 주요 언어에서 사용되는 컨셉은 다음과 같습니다:

1. **자바(Java):**
   - 자바는 가비지 컬렉션을 통해 동적으로 할당된 객체들 중에서 더 이상 참조되지 않는 객체들을 식별하고 메모리에서 자동으로 해제합니다. 이를 통해 메모리 누수를 방지하고 개발자가 메모리 관리에 직접 신경 쓸 필요가 없습니다.

2. **C# (C Sharp):**
   - C#도 자바와 유사하게 가비지 컬렉션을 사용합니다. .NET 프레임워크에서는 CLR(Common Language Runtime)에서 가비지 컬렉션을 관리하며, 개발자가 명시적으로 메모리를 해제할 필요가 없습니다.

3. **파이썬(Python):**
   - 파이썬은 자체적인 가비지 컬렉션을 가지고 있습니다. 이를 통해 사용되지 않는 객체들을 식별하고 메모리에서 자동으로 해제합니다.

4. **JavaScript:**
   - JavaScript 역시 가비지 컬렉션을 사용하며, 웹 브라우저에서는 브라우저의 자바스크립트 엔진이 가비지 컬렉션을 수행합니다. 이를 통해 더 이상 참조되지 않는 객체들을 해제하여 브라우저의 메모리를 효과적으로 관리합니다.

가비지 컬렉터는 프로그래머가 메모리 관리에 대한 부담을 덜어주고, 메모리 누수와 관련된 문제를 예방하는 데 도움을 줍니다. 하지만 잘못된 사용으로 인해 성능 저하가 발생할 수 있으므로, 효율적인 코드 작성이 필요합니다.

###### 43. 어떤 에셋을 사용해 보셨나요? 없다면 알고 있는 에셋이 있나요?

###### 44. ScriptableObject이란 무엇이며 어떻게 사용되나요?
ScriptableObject은 Unity 엔진에서 제공하는 특별한 종류의 데이터 컨테이너로, 스크립트 로직과 연계하여 데이터를 저장하고 공유하는 데 사용됩니다. 이는 MonoBehaviour와는 달리 게임 오브젝트에 종속되지 않고, 프로젝트 전반에 걸쳐 데이터를 관리하고 공유할 수 있습니다.

1. ScriptableObject의 특징에 대해 설명해주세요.

ScriptableObject의 주요 특징과 사용 방법은 다음과 같습니다:

1. **게임 오브젝트에 종속되지 않음:**
   - ScriptableObject는 게임 오브젝트에 연결되지 않으며, 별도의 인스턴스로 프로젝트 내 어디에서나 사용할 수 있습니다.

2. **데이터 저장 및 공유:**
   - ScriptableObject를 사용하면 스크립트 간에 데이터를 저장하고 공유할 수 있습니다. 이를 통해 서로 다른 스크립트 간에 일관된 데이터를 유지하고 활용할 수 있습니다.

3. **에디터에서 수정 가능:**
   - ScriptableObject 인스턴스의 데이터는 에디터에서 수정 가능하며, 프로젝트의 리소스 폴더에 저장됩니다. 이는 게임이 실행 중이 아닌 에디터에서 데이터를 편집하고 저장할 수 있도록 합니다.

4. **쉬운 직렬화(Serialization):**
   - ScriptableObject는 Unity에서 제공하는 직렬화 기능을 이용하여 데이터를 저장하고 로드할 수 있습니다. 이는 데이터를 파일로 저장하고 불러올 때 편리하게 활용됩니다.

5. **리소스 관리:**
   - ScriptableObject는 리소스로 저장되므로, 빌드 시에도 쉽게 접근할 수 있습니다. 이는 게임 실행 중이 아닌 시점에서도 데이터를 활용할 수 있게 해줍니다.

간단한 ScriptableObject의 예시는 다음과 같습니다:

```csharp
using UnityEngine;

[CreateAssetMenu(fileName = "NewData", menuName = "CustomData", order = 1)]
public class CustomData : ScriptableObject
{
    public int intValue;
    public float floatValue;
    public string stringValue;
}
```

이렇게 정의된 ScriptableObject를 에디터에서 생성하고 데이터를 설정한 후, 스크립트에서 이를 참조하여 사용할 수 있습니다. ScriptableObject는 Unity의 데이터 관리 및 유지보수를 용이하게 만들어주는 강력한 도구 중 하나입니다.

###### 45. Unity에서 레이어와 태그의 역할은 무엇이며, 어떻게 사용되는지 설명해주세요.
Unity에서 레이어(Layer)와 태그(Tag)는 주로 게임 오브젝트를 분류하고 식별하는 데 사용되는 기능입니다.

1. **레이어(Layer):**
   - **역할:** 레이어는 게임 오브젝트를 물리적으로 그룹화하고, 카메라 렌더링, 레이캐스팅 등에서 특정 그룹의 오브젝트를 선택할 때 사용됩니다.
   - **사용 예시:**
     - 카메라가 특정 레이어의 오브젝트만 렌더링하도록 설정할 수 있습니다.
     - 레이캐스트 시 특정 레이어의 오브젝트만을 대상으로 할 수 있습니다.
   - **사용 방법:**
     - Inspector 창에서 "Layer" 필드에서 오브젝트의 레이어를 설정할 수 있습니다.
     - 코드에서는 `gameObject.layer`를 통해 동적으로 레이어를 변경할 수 있습니다.

2. **태그(Tag):**
   - **역할:** 태그는 게임 오브젝트에 레이블을 부여하여 특정 그룹을 구분하는 데 사용됩니다. 주로 게임 오브젝트의 식별에 사용되며, 레이어보다는 좀 더 추상적인 그룹화에 사용됩니다.
   - **사용 예시:**
     - 태그를 통해 플레이어, 적, 아이템 등을 식별하고 처리할 수 있습니다.
     - OnCollisionEnter 등의 콜백에서 특정 태그의 오브젝트와 충돌하는지 확인할 수 있습니다.
   - **사용 방법:**
     - Inspector 창에서 "Tag" 필드에서 오브젝트의 태그를 설정할 수 있습니다.
     - 코드에서는 `gameObject.tag`를 통해 동적으로 태그를 변경할 수 있습니다.

레이어와 태그를 적절히 활용하면 게임 오브젝트를 논리적으로 그룹화하고, 특정 기능을 수행할 때 필요한 오브젝트를 효과적으로 식별할 수 있습니다. 이는 게임의 구조를 명확하게 만들고, 코드에서 유연하게 작업할 수 있도록 도와줍니다.
###### 46. Find 함수 사용을 자제해야 하는 이유에 대해 설명해주세요.
`Find` 함수는 Unity에서 특정 조건을 만족하는 게임 오브젝트를 찾는 데 사용되지만, 너무 남발하면 성능과 코드 유지보수 측면에서 문제가 발생할 수 있습니다. 여러 이유로 `Find` 함수 사용을 자제해야 하는 이유는 다음과 같습니다:

1. **성능 문제:**
   - `Find` 함수는 계층 구조를 순회하면서 조건에 맞는 오브젝트를 찾기 때문에 성능이 비교적 낮습니다. 특히 게임 오브젝트의 수가 많고, `Find` 함수를 많이 호출하는 경우 성능 저하가 발생할 수 있습니다.
   - 대안으로는 참조를 미리 변수에 할당하거나 캐시하여 사용하는 방법을 고려할 수 있습니다.

2. **유지보수 어려움:**
   - `Find` 함수를 남발하면 코드의 가독성이 떨어지고, 어떤 오브젝트를 찾고 있는지 명확하지 않아집니다. 코드가 복잡해지면 유지보수가 어려워집니다.
   - 대신에 Inspector 창에서 직접 참조를 할당하거나, 레이어와 태그를 사용하여 필요한 오브젝트를 식별하는 방법을 고려할 수 있습니다.

3. **런타임 비용 증가:**
   - `Find` 함수는 런타임에 실행되기 때문에 불필요한 호출이 있을 경우 그만큼 런타임 비용이 증가합니다. 특히 매 프레임마다 호출되는 경우 부하가 크게 증가할 수 있습니다.
   - 초기화 단계에서 필요한 오브젝트들을 미리 참조해두고 사용하는 것이 좋습니다.

4. **NullPointerException 발생 가능성:**
   - `Find` 함수가 원하는 오브젝트를 찾지 못할 경우 `null`을 반환합니다. 이에 대한 예외 처리가 부족하면 프로그램이 예기치 않게 중단될 수 있습니다.
   - `Find` 함수 사용 전에 null 체크를 하는 등 안전한 사용법을 고려해야 합니다.

대신에 가능하면 다른 방법을 사용하여 필요한 오브젝트에 접근하고, 캐싱을 통해 중복 호출을 최소화하며 코드의 가독성과 성능을 유지하는 것이 좋습니다.
###### 47. Scene Load의 종류를 비교해서 설명해주세요.
Unity에서 씬(Scene)을 로드하는 방식에는 여러 가지가 있습니다. 각각의 방식은 다양한 상황에 적합하며, 성능 및 사용자 경험에 영향을 미칠 수 있습니다. 주요한 씬 로드 방식들을 비교하여 설명하겠습니다:

1. **SceneManager.LoadScene:**
   - **동기 방식 (Synchronous):**
     - `SceneManager.LoadScene` 함수는 동기 방식으로 씬을 로드합니다. 로드가 완료될 때까지 다음 코드 진행이 차단됩니다.
   - **사용 예시:**
     ```csharp
     SceneManager.LoadScene("SceneName");
     ```

2. **SceneManager.LoadSceneAsync:**
   - **비동기 방식 (Asynchronous):**
     - `SceneManager.LoadSceneAsync` 함수는 비동기 방식으로 씬을 로드합니다. 로드가 완료될 때까지 코드가 차단되지 않으므로 게임 진행이 멈추지 않습니다.
   - **사용 예시:**
     ```csharp
     IEnumerator LoadSceneAsync()
     {
         AsyncOperation asyncLoad = SceneManager.LoadSceneAsync("SceneName");

         while (!asyncLoad.isDone)
         {
             float progress = Mathf.Clamp01(asyncLoad.progress / 0.9f);
             // 로딩 프로그레스 표시 등의 추가 작업
             yield return null;
         }
     }
     ```

3. **SceneManager.LoadSceneAsync with additive:**
   - **추가 방식 (Additive):**
     - `SceneManager.LoadSceneAsync` 함수에 `LoadSceneMode.Additive`를 사용하여 씬을 현재 씬에 추가적으로 로드할 수 있습니다. 이는 여러 씬을 동시에 띄울 수 있는데, 각 씬의 카메라, 라이팅 등이 독립적으로 유지됩니다.
   - **사용 예시:**
     ```csharp
     AsyncOperation asyncLoad = SceneManager.LoadSceneAsync("SceneName", LoadSceneMode.Additive);
     ```

4. **Addressable Asset System:**
   - **자원 관리 시스템 (Addressables):**
     - Addressable Asset System을 사용하면 리소스를 주소로 관리하고, 미리 로드해둔 것을 사용하거나, 비동기로 필요할 때 로드할 수 있습니다. 주소로 관리되므로 효율적인 리소스 관리가 가능합니다.
   - **사용 예시:**
     ```csharp
     Addressables.LoadSceneAsync("AddressableScene");
     ```

5. **Scene Overlapping:**
   - **씬 중첩 (Overlapping):**
     - 여러 씬을 동시에 로드하는 것이 아닌, 현재 씬에 다른 씬을 겹쳐서 로드하는 방식입니다. UI 씬이나 로딩 화면 등을 다른 씬 위에 띄우는 경우에 사용됩니다.
     - **사용 예시:**
       - 현재 씬에서 다른 씬을 `SceneManager.LoadScene`로 로드하고, 기존 씬에 덮어 씌웁니다.

씬 로드 방식의 선택은 프로젝트의 요구사항과 성능 등을 고려하여 이루어져야 합니다. 예를 들어, 대규모의 씬을 비동기로 로드하고 로딩 화면을 표시하는 등의 상황에서는 `LoadSceneAsync`를 사용하는 것이 좋습니다.

###### 48. Unity의 물리 엔진은 어떻게 동작하며, 어떤 요소를 조작할 수 있는지 설명해주세요.
Unity의 물리 엔진은 주로 NVIDIA의 PhysX 엔진을 기반으로 하며, 물체 간의 충돌, 중력, 강체 및 연결된 조인트 등을 다룹니다. 물리 엔진은 게임에서 현실적인 움직임 및 충돌을 시뮬레이션하기 위해 사용됩니다. 아래는 Unity의 물리 엔진이 어떻게 동작하며 어떤 요소를 조작할 수 있는지에 대한 간략한 설명입니다:

1. **리지드바디(Rigidbody):**
   - Unity의 물리 시스템에서는 물체에 물리적 특성을 부여하기 위해 `Rigidbody` 컴포넌트를 사용합니다. 리지드바디는 물체의 질량, 중력 영향 등을 고려하여 물체의 움직임을 계산합니다.
   - 개발자는 리지드바디의 속도, 각속도, 힘, 토크 등을 조작하여 물체의 움직임을 제어할 수 있습니다.

2. **콜라이더(Collider):**
   - 콜라이더는 물리 시뮬레이션에서 물체의 형태와 충돌 영역을 정의합니다. 리지드바디는 콜라이더와의 충돌을 감지하고 물리 엔진은 이 충돌에 대한 반응을 계산합니다.
   - Unity에서는 다양한 형태의 콜라이더를 제공하며, 개발자는 오브젝트의 모양과 크기에 맞게 적절한 콜라이더를 선택할 수 있습니다.

3. **조인트(Joint):**
   - 조인트는 물리적으로 연결된 두 개의 리지드바디 사이의 관계를 정의합니다. 강체의 연결, 도로의 구현, 휠과 차체의 연결 등 다양한 상황에서 사용됩니다.
   - 고정 조인트, 쿼터니언 슬라이더 조인트, 힌지 조인트 등 다양한 조인트 유형이 있습니다.

4. **물리 머티리얼(Physics Material):**
   - 물리 머티리얼은 콜라이더 간의 마찰, 반발력 등의 물리적 특성을 정의합니다. 각 콜라이더에 머티리얼을 할당하여 각각의 물체에 대한 물리 특성을 조작할 수 있습니다.

5. **Raycast 및 충돌 이벤트:**
   - Raycast를 통해 레이를 쏴서 충돌을 감지하거나, OnCollisionEnter, OnCollisionStay, OnCollisionExit 등의 콜백 함수를 이용하여 충돌 이벤트를 처리할 수 있습니다.
   - 이를 통해 특정 상황에서의 물체 간 상호작용을 감지하고 반응할 수 있습니다.

6. **레이어와 레이어 마스크(Layer and Layer Mask):**
   - Unity에서는 레이어와 레이어 마스크를 통해 특정 오브젝트 간 충돌 감지를 제어할 수 있습니다. 레이어를 지정하여 특정 레이어 간에만 충돌을 감지하도록 설정할 수 있습니다.

Unity의 물리 엔진을 사용하면 게임에 물리적인 요소를 추가하여 현실적인 효과를 구현할 수 있습니다.

###### 49. Texture 와 Sprite 에 대해 설명해주세요.
**Texture(텍스처):**

텍스처는 이미지 데이터를 포함하는 2D 이미지 파일을 나타내는 개념입니다. Unity에서 텍스처는 게임 오브젝트의 머티리얼(Material)에 적용되어 시각적인 요소를 나타내는 데 사용됩니다. 텍스처는 주로 이미지 파일로부터 로드되거나 생성됩니다. 이러한 텍스처는 주로 게임의 텍스처 매핑(Texture Mapping)이나 배경 이미지 등에 사용됩니다.

Unity에서는 다양한 형식의 텍스처를 지원하며, PNG, JPEG, BMP, TGA 등의 이미지 포맷을 사용할 수 있습니다. 또한, 텍스처의 크기, 압축 방법, 투명도, 반사 등의 속성을 설정할 수 있습니다.

**Sprite(스프라이트):**

스프라이트는 2D 이미지를 나타내는 개체로, 게임에서 그래픽 요소를 구성하는데 사용됩니다. Unity에서 스프라이트는 텍스처를 기반으로 하며, 2D 이미지를 표현하기 위한 여러 가지 속성과 기능을 제공합니다.

일반적으로 Unity에서는 스프라이트를 2D 이미지를 담는 컴포넌트로서 `SpriteRenderer`를 사용하여 표현합니다. 스프라이트는 게임 오브젝트의 렌더링을 담당하며, 텍스처와 함께 사용되어 게임 내에서 시각적인 효과를 생성합니다.

주로 게임에서 플레이어 캐릭터, 아이템, 배경 등의 그래픽 요소는 스프라이트로 표현되며, Unity에서는 2D 게임 제작에 사용되는 다양한 도구와 기능을 제공하고 있습니다.
###### 50. 프리팹(Prefab)이란 무엇이며, 어떻게 사용되나요?
프리팹(Prefab)은 Unity에서 사용되는 중요한 개념 중 하나로, 재사용 가능한 게임 오브젝트의 템플릿이나 모듈입니다. 프리팹을 사용하면 동일한 게임 오브젝트를 여러 번 사용하거나, 변경이 필요할 때 쉽게 업데이트할 수 있습니다.

프리팹은 일반적으로 다음과 같은 특징을 가지고 있습니다:

1. **템플릿:**
   - 프리팹은 게임 오브젝트의 템플릿으로 기능하며, 동일한 레이아웃, 구조, 컴포넌트 등을 가지는 여러 인스턴스를 생성할 수 있습니다.

2. **재사용성:**
   - 프리팹은 프로젝트 내에서 여러 씬에서 사용될 수 있으며, 변경이 필요한 경우 한 곳에서 업데이트하면 해당 프리팹을 사용하는 모든 인스턴스에 자동으로 적용됩니다.

3. **동적 업데이트:**
   - 게임이 실행 중일 때도 프리팹을 업데이트할 수 있습니다. 이로써 프로젝트의 유지보수가 용이해지고, 변경 사항이 즉시 반영됩니다.

프리팹을 사용하는 일반적인 단계는 다음과 같습니다:

1. **프리팹 생성:**
   - 프리팹은 보통 씬에 배치된 게임 오브젝트를 프로젝트 뷰로 드래그하여 프리팹으로 만들거나, 프로젝트 창에서 오브젝트를 만들어 직접 프리팹으로 저장합니다.

2. **프리팹 인스턴스화:**
   - 프리팹을 씬에 배치할 때마다 해당 프리팹의 인스턴스가 생성됩니다. 이 인스턴스는 프리팹과 연결되어 있어 프리팹이 업데이트되면 모든 인스턴스에도 변경사항이 적용됩니다.

3. **프리팹 업데이트:**
   - 프리팹이 변경되면 해당 프리팹을 사용하는 모든 인스턴스에 즉시 변경 사항이 반영됩니다. 이는 프리팹을 사용하는 모든 장소에 대한 일관성을 유지하는 데 도움이 됩니다.

프리팹은 Unity에서 게임 오브젝트를 효과적으로 관리하고 유지보수하는 데 도움이 되며, 특히 반복되는 요소들을 쉽게 생성하고 업데이트할 수 있도록 합니다.

###### 51. 디버깅을 어떤 방식으로 진행하는지 설명해주세요.
디버깅(Debugging)은 프로그램이나 스크립트에서 발생하는 버그를 찾고 수정하는 과정을 의미합니다. Unity에서는 다양한 디버깅 도구와 기능이 제공되며, 주로 다음과 같은 방식으로 디버깅이 진행됩니다:

1. **로그 출력(Logging):**
   - `Debug.Log` 함수를 사용하여 중요한 정보, 변수의 값을 출력하여 코드 실행 중의 상태를 확인합니다.
   ```csharp
   Debug.Log("This is a log message.");
   Debug.Log("Variable value: " + myVariable);
   ```

2. **에디터 내 디버깅 도구:**
   - Unity 에디터에서는 플레이 모드에서 코드를 실행하는 동안 변수의 값을 확인하고 변경할 수 있는 Inspector, Console, Hierarchy, Scene 창 등 다양한 도구를 활용합니다.

3. **중단점(Breakpoints):**
   - 코드 편집기에서 특정 라인에 중단점을 설정하여 프로그램의 실행을 일시 중지하고 해당 지점에서 변수 및 상태를 확인할 수 있습니다.
   - 중단점은 코드 에디터에서 클릭하여 설정하거나 디버그 창에서 설정할 수 있습니다.

4. **단계별 실행(Step-by-step Execution):**
   - 디버그 창에서 "Step Over", "Step Into", "Step Out" 등을 사용하여 코드를 한 줄씩 실행하면서 각 단계에서 변수와 상태를 확인할 수 있습니다.

5. **조건부 중단점(Conditional Breakpoints):**
   - 중단점에 특정 조건을 설정하여 해당 조건이 참일 때만 중단점에서 프로그램을 일시 중지하도록 할 수 있습니다.

6. **스택 트레이스(Stack Trace):**
   - 예외가 발생했을 때 디버그 창에서 스택 트레이스를 확인하여 어떤 함수에서 예외가 발생했는지, 호출 순서를 파악할 수 있습니다.

7. **시각적 디버깅(Visual Debugging):**
   - `Debug.DrawLine`, `Debug.DrawRay` 등을 사용하여 Scene 뷰에 시각적인 디버깅 정보를 표시할 수 있습니다.

8. **모바일 디버깅:**
   - 모바일 디바이스에서도 Unity Remote 또는 Unity Profiler를 활용하여 실제 디바이스에서 발생하는 문제를 확인하고 해결할 수 있습니다.

디버깅은 프로그램 개발의 필수적인 부분이며, Unity에서 제공하는 다양한 도구를 적절히 활용하여 문제를 신속하게 해결할 수 있습니다.
###### 52. Attribute를 사용한 경험과 그에 대한 설명을 해주세요.
Attributes(속성)는 C# 프로그래밍 언어에서 메타데이터를 클래스, 메서드, 변수 등에 부착하는 데 사용되는 기능입니다. Unity에서도 C# 언어를 기반으로 하고 있어, Attributes를 자주 활용합니다. 여러 가지 Attributes가 있지만, 가장 흔하게 사용되는 몇 가지를 살펴보겠습니다:

1. **[SerializeField]:**
   - Unity에서 `private`으로 선언된 변수도 Inspector 창에서 직접 접근할 수 있게 해주는 Attribute입니다. 주로 Unity의 Serialized Field로 표시되는 변수에 사용됩니다.
   ```csharp
   public class Example : MonoBehaviour
   {
       [SerializeField]
       private int myValue;
   }
   ```

2. **[Header], [Space]:**
   - Inspector 창에서 가독성을 높이기 위해 사용됩니다. [Header]는 해당 변수나 메서드 위에 제목을 표시하고, [Space]는 여백을 추가합니다.
   ```csharp
   public class Example : MonoBehaviour
   {
       [Header("Settings")]
       public int health;

       [Space(10)]
       public float speed;
   }
   ```

3. **[Range]:**
   - 숫자 변수의 값을 특정 범위로 제한할 때 사용됩니다. Inspector에서 해당 변수를 조절할 때 범위가 표시됩니다.
   ```csharp
   public class Example : MonoBehaviour
   {
       [Range(1, 100)]
       public int damage;
   }
   ```

4. **[HideInInspector]:**
   - Inspector 창에서 해당 변수를 감추고 싶을 때 사용됩니다. 주로 프로그램 로직에만 사용되는 변수에 적용됩니다.
   ```csharp
   public class Example : MonoBehaviour
   {
       [HideInInspector]
       public bool isReady;
   }
   ```

5. **[ExecuteInEditMode]:**
   - 에디터 모드에서 스크립트의 메서드를 실행하고 싶을 때 사용됩니다. 에디터에서 미리보기를 통해 작업할 때 유용합니다.
   ```csharp
   [ExecuteInEditMode]
   public class Example : MonoBehaviour
   {
       private void Update()
       {
           // 에디터 모드에서도 실행되는 코드
       }
   }
   ```

Attributes는 주로 코드의 가독성을 높이고, Inspector 창에서 조작이나 시각적으로 이해하기 쉽도록 도움을 주는 데에 활용됩니다. Unity에서 제공하는 다양한 Attributes는 편리하게 사용할 수 있으며, 적절히 활용하면 개발 생산성을 향상시킬 수 있습니다.

###### 53. git을 사용해 본적이 있나요? 어떤 점이 어려웠고 어떤 툴을 사용했는지 설명해주세요.

###### 54. 게임 개발 학습 과정에서 자신이 가장 재미있었던 부분이나 혹은 자신 있게 설명할 수 있는 부분이 있다면 설명해주세요.

###### 55. 포트폴리오에서 본인이 담당한 부분이 무엇인가요?

###### 56. 만약 본인이 개발한 것을 다시 개발한다면, 어떻게 개선할 것인지 설명해주세요.

###### 57. 협업하면서 가장 어려웠던 점이 무엇인가요?
    
	1. 구현 하면서 기술적으로 어려웠던 부분을 어떻게 해결하였나요?

###### 58. 프로젝트를 진행하면서 기술적인 도전과제는 무엇이었나요?

###### 59. 협업하면서 조원과 트러블이 있었는지? 어떻게 해결해 나갔는지

###### 60. Git Repository를 팀원들과 공동으로 작업하면서 발생했던 문제점이 있다면 무엇인지, 어떻게 해결하였는지 이야기해주세요.