#### 공지사항

빠르게 훑는 것보다는 천천히 짚고 가는 걸로

지난주보다는 천천히, 구체적으로 주제 탐색

## 클래스, 구조체, 제네릭, 인터페이스 복습

#### 값타입과 참조타입

Vector2는 왜 미묘하게 색이 다른걸까 생각해보신 적 있으신가요?

![[Pasted image 20240115000242.png]]

#### C#의 값타입과 참조타입
C#에서는 값타입과 참조타입 두 가지 타입을 지원합니다.

- **값타입(Value Type)**: int, float, double, bool 등의 기본 데이터 타입들이 값타입에 해당합니다. 값타입은 변수에 직접 값을 저장하며, **변수 간의 대입 시 값이 복사**됩니다. 값타입 변수가 다른 변수에 할당되거나 전달될 때는 값이 복사되므로 독립적으로 동작합니다.
- **참조타입(Reference Type)**: 클래스, 인터페이스 등이 참조타입에 해당합니다. 참조타입은 변수에는 실제 값 대신 **객체에 대한 참조(메모리 주소)가 저장**됩니다. 참조타입 변수가 다른 변수에 할당되거나 전달될 때는 참조(메모리 주소)가 복사되므로 동일한 객체를 참조하게 됩니다.
	-  
![[Pasted image 20240115000413.png]]
![[Pasted image 20240115000420.png]]
#### 클래스 : 객체지향 프로그래밍에서 데이터와 메소드를 정의하는 일종의 틀

#### (1) 다양한 데이터를 저장하는 복합자료형

다양한 데이터를 저장할 수 있는 복합자료형

클래스가 가질 수 있는 멤버들 : 메소드, 필드, 프로퍼티(속성)

#### (2) 데이터를 참조형식으로 저장함

얕은 복사 : 내부의 값이 아닌 참조만 복사함으로서 발생하는 문제

해결 : 값 타입이 나올때까지 찾아서 계속 복사해줘야 함

의문 : string은 값 타입도 아닌데.. 문제가 없다?

#### 결론 : 값형식(구조체 포함) 혹은 String은 문제가 없음 / 나머지는 복사시에 굉장히 유의해야함


	![[Pasted image 20240115000430.png]]

사례 1
```csharp
public class Player
{
    public int health;

    public Player(int initialHealth)
    {
        health = initialHealth;
    }
}

public class Example
{
    void Start()
    {
        Player originalPlayer = new Player(100);
        Player copiedPlayer = originalPlayer;

        copiedPlayer.health = 50;

        // 이 시점에서 originalPlayer의 health도 50으로 변경되어 있음
        Debug.Log(originalPlayer.health);  // 출력: 50
    }
}
```

사례 2
```csharp
using System;
using System.Collections.Generic;

public class HelloWorld
{
    public static void Main(string[] args)
    {
        Player originalPlayer = new Player();
        Player copiedPlayer = new Player();
        copiedPlayer.HP = originalPlayer.HP;
        copiedPlayer.inventory = new List<MyClass>();
				for(int i =0; i < originalPlayer.inventory.Count; i++){
						copitedPlayer.inventory.Add(originalPlayer.inventory[i]);
				}
        
        // copiedPlayer의 인벤토리에 'Potion' 추가
        copiedPlayer.inventory.Add("Potion");

        // originalPlayer의 인벤토리에도 'Potion'이 추가된 것을 볼 수 있음
        foreach (string item in originalPlayer.inventory)
        {
            Console.WriteLine(item); // 출력: Sword, Shield, Potion
        }
    }
}


public class Player : IClonable
{
    public List<string> inventory = new List<string>();
    public int HP = 100;
    
		public Player(int Hp, List<string> prev_inventory){
				HP = Hp;
				inventory = prev_inventory;
		}

    public Player()
    {
        inventory.Add("Sword");
        inventory.Add("Shield");
    }

		public Player Clone(){
			 
		}
}
```

#### (3) 클래스는 상속이 가능하다

클래스는 부모(base)클래스로부터 공통적 부분을 상속하여 새로운 파생 클래스를 만들 수 있습니다. 상속을 사용하면 base 클래스의 데이터와 메서드를 파생클래스에서 사용합니다.

상속은 주로 “is a” 관계를 맺고 있습니다. ItemManager is a Manager / Monster is a Damagable / Zealot is a GroundUnit

상속의 의의 : 중복된 코드 줄일 수 있음, 다형성을 통해 일관된 형식(인터페이스)을 공유할 수 있음

상속의 문법 : 콜론을 찍어서 Base 클래스를 명시

```csharp
// 베이스 클래스
public class Animal
{
   public string Name { get; set; }
   public int Age { get; set; }
}

// 파생클래스
public class Dog : Animal
{       
   public void HowOld() 
   {
      // 베이스 클래스의 Age 속성 사용
      Console.WriteLine("나이: {0}", this.Age);
   }
}

public class Bird : Animal
{       
   public void Fly()
   {
      Console.WriteLine("{0}가 날다", this.Name);
   }
}
```


#### 상속 FAQ

1) 실제로 Animal 클래스로 객체가 만들어지는 경우를 막고 싶어요 → 추상클래스
```csharp
public abstract class Animal // 실제 구현을 강제함 --> interface 비슷
{
    public abstract void Speak();
}

public class Dog : Animal
{
	 // Dog는 무조건 speak을 구현해야함 : 이유는 abstract함수여서
    public override void Speak()
    {
        Debug.Log("Bark");
    }
}
```


2) 날 수 있다는 특성(flyable)도 상속받도록 하고 싶어요 → 인터페이스
```csharp
public interface IFlyable
{
    void Fly();
}

public class Bird : Animal, IFlyable
{
    public override void Speak()
    {
        Debug.Log("Chirp");
    }

    public void Fly()
    {
        Debug.Log("Bird is flying");
    }
}
```
​

3) 부모 클래스에서는 A처럼 작동했지만 자식 클래스에서는 A’처럼 행동하고 싶어요 → virtual / override
```csharp
public class Animal
{
    public virtual void Speak() // 실제 구현을 강제하지 않음. 그냥 기본 구현(default값)
    {
        Debug.Log("Animal sound");
    }
}

public class Cat : Animal
{
    public override void Speak()
    {
        Debug.Log("Meow");
    }
}

public class Dog : Animal // Speak를 했을 때 오류 안남 왜냐면 기본 구현이 있기 때문
{
	
}

```
​

4) 여러 자식 클래스들이 섞여들어있는 컬렉션에서 특정 클래스인지 확인하고 싶어요 → is/as
```csharp
public void CheckAnimalType(Animal animal)
{
    if (animal is Dog)
    {
        Dog dog = animal as Dog;
        dog.Speak();  // Bark
    }
    else if (animal is Cat)
    {
        Cat cat = (Cat)animal;
        cat.Speak();  // Meow
    }
}
```

​

5) 부모 클래스의 일부 멤버를 자식 클래스에 전달하고 싶지 않아요 → private```
```csharp
public class Animal
{
    private int age;

    public void SetAge(int age)
    {
        this.age = age;
    }
}

public class Dog : Animal
{
    public void PrintAge()
    {
        // age 접근 불가능. 컴파일 오류 발생
        // Debug.Log(age);
    }
}
```

6) 부모 클래스의 일부 멤버를 외부 클래스에는 노출하고 싶지 않지만 자식 클래스에게는 전달하고 싶어요 → protected
```csharp
public class Animal
{
    protected int age;

    public void SetAge(int age)
    {
        this.age = age;
    }
}

public class Dog : Animal
{
    public void PrintAge()
    {
        Debug.Log(age);  // 접근 가능
    }
}
```

​

#### 클래스 VS 구조체

|   |   |   |
|---|---|---|
|특징|클래스|구조체|
|키워드|class|struct|
|형식|참조타입|값 타입|
|복사|얕은 복사|깊은 복사|
|인스턴스 생성|new 연산자|선언만으로 생성|
|상속|가능|불가능 인터페이스는 됨|

#### [더 배우기] is a 관계가 말이 되지만 문제가 되는 상황들

![👉](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

리스코프 치환 원칙 (Liskov Substitution Principle)

리스코프 치환 원칙은 객체 지향 프로그래밍에서 상속과 다형성을 이용할 때 지켜야 할 원칙 중 하나입니다. 리스코프 치환 원칙은 다음과 같이 정의됩니다.

"프로그램의 객체들은 그것들의 서브타입(subtype) 객체로 대체될 수 있어야 한다."

즉, 어떤 클래스가 상속 관계에 있을 때, 부모 클래스의 인스턴스 대신에 자식 클래스의 인스턴스를 사용해도 프로그램의 의미나 동작에 아무런 영향이 없어야 합니다.

하지만 때로는 상속을 받은 것처럼 보이지만 실제로는 리스코프 치환 원칙을 위배하면서 문제가 발생할 수 있습니다.

예시 1
```csharp
public class Rectangle
{
    public virtual int Width { get; set; }
    public virtual int Height { get; set; }

    public int Area()
    {
        return Width * Height;
    }
}

public class Square : Rectangle
{
    public override int Width
    {
        get { return base.Width; }
        set
        {
            base.Width = value;
            base.Height = value;
        }
    }

    public override int Height
    {
        get { return base.Height; }
        set
        {
            base.Width = value;
            base.Height = value;
        }
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        Rectangle rectangle = new Square();
        rectangle.Width = 5;
        rectangle.Height = 10;

        Console.WriteLine(rectangle.Area());  // 출력: 100
    }
}

```

예시 2
```csharp
public abstract class Animal
{
    public abstract void MakeSound();
}

public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Bark");
    }
}

public class Cat : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Meow");
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        Animal animal = GetRandomAnimal();
        animal.MakeSound();
    }

    public static Animal GetRandomAnimal()
    {
        Random random = new Random();
        int randomNumber = random.Next(1, 3);

        if (randomNumber == 1)
        {
            return new Dog();
        }
        else
        {
            return new Cat();
        }
    }
}

```

예시 3
```csharp
public class Bird
{
    public virtual void Fly()
    {
        Console.WriteLine("The bird is flying");
    }
}

public class Penguin : Bird
{
    public override void Fly()
    {
        throw new NotImplementedException();
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        Bird bird = new Penguin();
        bird.Fly();
    }
}

```

리스코프 치환 원칙을 위배하면 예상치 못한 동작이나 예외가 발생할 수 있습니다. 예를 들어, 부모 클래스의 메서드를 오버라이딩하여 자식 클래스에서 다른 동작을 수행하는 경우, 이는 리스코프 치환 원칙을 위배합니다. 이로 인해 코드의 가독성이 떨어지고, 예상치 못한 결과가 발생할 수 있습니다.

또한, 자식 클래스가 부모 클래스의 일부 멤버를 숨기지 않고 노출하거나 변경하는 경우도 리스코프 치환 원칙을 위배할 수 있습니다. 이는 다형성을 사용하는 클라이언트 코드에서 예외를 발생시킬 수 있습니다. 클라이언트 코드가 부모 클래스의 인스턴스를 사용하는 것이 예상되는 상황에서 자식 클래스의 인스턴스를 사용하면 예상치 못한 동작이 발생할 수 있습니다.

따라서, 리스코프 치환 원칙을 지키지 않는다면 코드의 예측 가능성과 유지 보수성이 떨어지며, 오류 발생 가능성이 증가할 수 있습니다.

![[Pasted image 20240115000448.png]]

### 제네릭 : 마법상자

제네릭은 마치 마법상자처럼 다양한 타입을 담을 수 있는 기능입니다. 제네릭을 사용하면 코드의 재사용성과 유연성을 높일 수 있습니다. 타입에 대한 제한이 없이 여러 종류의 데이터를 한꺼번에 처리할 수 있어 개발을 더욱 효율적으로 만들어줍니다. 이러한 제네릭은 마치 마법처럼 다양한 상황에서 사용할 수 있는 강력한 도구입니다.

제너릭은 데이터 타입을 미리 지정하지 않고 다양한 타입을 지원하는 코드를 작성할 수 있게 해줍니다. 제너릭을 사용하면 코드의 재사용성과 유지 보수성을 향상시킬 수 있습니다.

예를 들어, `List<T>` 클래스는 제너릭을 사용하여 다양한 데이터 타입의 리스트를 생성할 수 있습니다. T는 사용자가 지정한 타입에 따라서 다양한 형태의 리스트를 만들 수 있습니다. 아래는 제너릭을 사용한 `List<T>` 클래스의 예시입니다.


```csharp
List<int> numbers = new List<int>();
numbers.Add(1);
numbers.Add(2); 
numbers.Add(3); 

List<string> names = new List<string>();
names.Add("John"); 
names.Add("Jane"); 
names.Add("Mike");
```


위의 예시에서 `List<int>`는 int의 리스트를, `List<string>`은 string의 리스트를 생성합니다. 제너릭을 사용하면 동일한 코드를 다양한 데이터 타입에 대해 재사용할 수 있습니다.

제너릭을 사용하여 사용자 정의 클래스나 메소드를 작성할 수도 있습니다. 아래는 제너릭을 사용한 메소드의 예시입니다.


​```
```csharp
public T GetMax<T>(T a, T b)
{
    if (a.CompareTo(b) > 0)
    {
        return a;
    }
    else
    {
        return b;
    }
}

int maxInt = GetMax<int>(3, 5);
string maxString = GetMax<string>("apple", "banana");
```


위의 예시에서 `GetMax<T>` 메소드는 제너릭으로 작성되어 있습니다. 사용자가 지정한 데이터 타입에 따라서 최댓값을 반환하는 메소드입니다. `GetMax<int>`는 정수형 데이터에 대한 최댓값을, `GetMax<string>`은 문자열 데이터에 대한 최댓값을 반환합니다.

제네릭의 제한

하지만, 사실 대부분의 경우에서는 아무거나 막 넣을 수 있도록 허락하지 않습니다. 더하기를 한다고하는데 클래스를 넣어버리고 이러면 곤란하겠죠. 그래서 제네릭에서는 제한을 걸 수 있도록 합니다. 제네릭에서 제한을 거는 부분은 where 절을 사용하여 구현할 수 있습니다. where 절을 사용하면 제네릭 타입 매개변수에 대한 제약 조건을 지정할 수 있습니다.

예를 들어, T가 Monster 클래스 또는 Monster 클래스를 상속받은 클래스여야 한다는 제약 조건을 걸고 싶다면 다음과 같이 작성할 수 있습니다:

```csharp
public class Example<T> where T : Monster
{
    // ...
}

```
​

위의 예시에서 `Example<T>` 클래스는 T가 Monster 클래스 또는 Monster 클래스를 상속받은 클래스여야 합니다. 이렇게 하면 T는 Monster 클래스로 제한되며, Monster 클래스의 멤버에 접근할 수 있습니다.

#### 인터페이스

죽음의 다이아몬드 문제

![[Pasted image 20240115000540.png]]


쓰는 이유 : 클래스만 쓸 때보다 훨씬 유연성과 확장성 있는 코드를 구현하기 위해서!

인터페이스는 클래스가 구현해야 하는 동작을 정의하는 계약서입니다. 즉, 인터페이스는 클래스에 어떤 동작을 구현해야 하는지 알려줍니다. 이를 통해 클래스 간에 일관된 동작을 보장할 수 있습니다.

인터페이스는 C#에서 다형성을 구현하는 중요한 개념입니다. 다형성이란, 동일한 메서드를 가지고 있지만 다른 방식으로 동작하는 여러 개의 객체를 사용할 수 있는 것을 말합니다.

인터페이스는 클래스의 형태를 갖지 않고, 동작에 대한 규약을 정의합니다. 클래스는 이러한 인터페이스를 구현함으로써 인터페이스에 정의된 동작을 보장하게 됩니다.

인터페이스를 사용하면 코드의 재사용성과 유연성을 높일 수 있습니다. 인터페이스를 구현한 클래스들은 동일한 동작을 제공하므로, 클라이언트 코드는 구현체의 내부 구현에 대해 알 필요가 없습니다. 이를 통해 코드의 결합도를 낮출 수 있으며, 유지 보수성을 향상시킬 수 있습니다.

인터페이스를 구현하려면 인터페이스에 정의된 모든 동작을 구현해야 합니다. 이를 통해 클래스는 인터페이스에 명시된 동작을 보장하게 되며, 다형성을 구현할 수 있습니다.

인터페이스는 다중 상속을 흉내내는 기능을 제공하여 여러 개의 인터페이스를 동시에 구현할 수 있습니다. 이를 통해 클래스는 다양한 동작을 갖는 객체를 생성할 수 있고, 코드의 재사용성과 유연성을 극대화할 수 있습니다.

C#에서 인터페이스를 잘 활용하면 유연하고 확장 가능한 코드를 작성할 수 있습니다. 인터페이스는 객체 지향 프로그래밍에서 중요한 역할을 하며, 다형성을 통해 코드의 유연성을 높일 수 있습니다.

|   |   |   |
|---|---|---|
|비교|클래스 (Class)|인터페이스 (Interface)|
|정의|데이터와 메서드의 집합으로 구성된 타입|동작에 대한 규약을 정의하는 계약서|
|다중 상속|단일 상속만 가능|다중 인터페이스 구현 가능|
|생성자|생성자를 가질 수 있음|생성자를 가질 수 없음|
|필드|인스턴스 필드와 정적 필드 지정 가능|인터페이스는 필드를 가질 수 없음|
|메서드|일반 메서드, 가상 메서드, 추상 메서드 가능|모든 메서드는 추상 메서드로 선언되어야 함|
|속성|속성 지정 가능|속성 지정 가능|