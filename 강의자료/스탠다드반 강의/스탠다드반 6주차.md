# 20231218

### 실습파일

## 코루틴

코루틴은 하나의 작업을 다수의 프레임에 분산할 때 사용합니다. 예를 들어, 투명하게 만들고 싶은 게임오브젝트에 대한 메소드가 있다고 생각해봅시다.

```csharp
void Fade()
{
    Color c = spriteRenderer.color;
    for (float alpha = 1f; alpha >= 0; alpha -= 0.1f)
    {
        c.a = alpha;
        spriteRenderer.color = c;
    }
}

void Start(){
		Fade();
}
```

위와 같이 작성할 경우 결국 플레이어가 만나게 되는 화면은 알파가 0일 때뿐입니다. 하지만 알파가 0.9 0.8 0.7… 순차적으로 내려가고 싶게했던 프로그래머의 (뇌가) 순수한 의도를 우리는 볼 수 있을 것입니다.

코루틴은 유니티에서 비동기적인 작업을 수행할 수 있게 해줍니다. **코루틴은 함수의 실행을 일시 중지하고, 이후에 다시 재개할 수 있는 기능을 제공합니다.
**
![[Pasted image 20240122204450.png]]
코루틴의 대강의 흐름이라고 생각하시면 됩니다.

예를 들어, 아래의 코드는 1초마다 "Hello, World!"를 출력하는 간단한 코루틴을 보여줍니다.

```csharp
using UnityEngine;
using System.Collections;

public class CoroutineExample : MonoBehaviour
{
    IEnumerator Start()
    {
        while (true)
        {
            Debug.Log("Hello, World!");
            yield return new WaitForSeconds(1f); 
        }
    }
}

```

위의 코드에서 `yield return new WaitForSeconds(1f);` 부분은 코루틴을 1초 동안 중지시키는 역할을 합니다. 이렇게 함으로써 코루틴은 지정된 시간 간격으로 반복적인 작업을 수행할 수 있습니다.

코루틴은 복잡한 비동기 작업, 예를 들어 네트워크 통신이나 애니메이션 재생과 같은 작업에 유용하게 사용될 수 있습니다. 코루틴을 통해 코드의 가독성과 유지보수성을 향상시킬 수 있습니다.

### 예시

다음은 코루틴을 사용하여 플레이어를 일정 시간 동안 무적 상태로 만드는 예시입니다.

```csharp
using UnityEngine;
using System.Collections;

public class Player : MonoBehaviour
{
    bool invincible = false;

    void Start()
    {
        StartCoroutine(InvincibilityCoroutine());
    }

    IEnumerator InvincibilityCoroutine()
    {
        invincible = true;
        yield return new WaitForSeconds(5f);
        invincible = false;
    }
}

```

위의 예시에서 `StartCoroutine(InvincibilityCoroutine());` 부분은 `InvincibilityCoroutine` 코루틴을 시작하는 역할을 합니다. 이 코루틴은 플레이어를 5초 동안 무적 상태로 만들고, 이후에 다시 무적 상태를 해제합니다.

### IEnumerator

IEnumerator 인터페이스는 Current (속성), MoveNext() (메서드), Reset() (메서드) 등 3개의 멤버로 이루어져 있는데, Enumerator가 되기 위해서는 Current와 MoveNext() 를 반드시 구현해야 합니다.

이를 통해 유니티의 DelayedCallManager가 등록하고 있다가 다음 단계에 실행하는 방식으로 구현되어 있습니다.

### Yield return …

**yield return null** : 다음 프레임까지 대기

**yield return new WaitForSeconds(float**) : 입력한 초(sec) 만큼 대기 yield return new WaitForSecondsRealtime(float) : Timescale영향없는 실제 시간 기준 초 대기

yield return new WaitFixedUpdate() : 다음 프레임의 FixedUpdate 까지 대기

yield return new WaitForEndOfFrame() : 모든 랜더링 작업이 끝날 때까지 대기

**yield return startCoroutiune(string)** : 입력한 다른 코루틴이 끝날 때까지 대기

**yield return new www(string)** : 입력한 웹 통신 작업이 끝날 때까지 대기

yield break : 코루틴 종료

### 코루틴의 종료

코루틴은 StopCoroutine과 StopAllCoroutines를 이용하여 코루틴을 정지가능하며, 코루틴을 소유하고 있는 게임오브젝트를 정지하거나 파괴하는 경우에도 종료됩니다. **단, 컴포넌트를 .enabled를 false로 하는 경우 꺼지지 않습니다.**

## 카메라 뷰

카메라 뷰는 플레이어들에게 게임을 보여주는 창과 같은 역할을 합니다. 이를 통해 유저들은 더욱 몰입하거나, 특정한 대상에 집중하거나 할 수 있는 등, 경험이 많이 변화하게 됩니다. 어떤 뷰들이 있고 어떻게 구현할 수 있는지 공부하겠습니다.

### 카메라 뷰

1. 탑다운(2D, 3D : X축 45도이상)
    
    ![[Pasted image 20240122204513.png]]
![[Pasted image 20240122204531.png]]
    
![[Pasted image 20240122204537.png]]
    
2. 사이드(온) : 원근법 무시(2D, 3D : Orthographic, 캐릭터 follow)
    
  ![[Pasted image 20240122204542.png]]

![[Pasted image 20240122204550.png]]
![[Pasted image 20240122204557.png]]

1. 1인칭 주인공 시점 (주로 3D, 캐릭터 Follow)
    ![[Pasted image 20240122204610.png]]
   ![[Pasted image 20240122204615.png]]
    
4. 3인칭 백뷰(숄더뷰) (3D 주로, 캐릭터 후방 상공에서 X축 살짝 회전)
    ![[Pasted image 20240122204620.png]]
![[Pasted image 20240122204623.png]]
    
5. 아이소메트릭(쿼터뷰) (원근법 무시 + x축 30도 y축 45도)
    
![[Pasted image 20240122204628.png]]![[Pasted image 20240122204635.png]]