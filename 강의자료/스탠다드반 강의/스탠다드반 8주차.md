# 231226

**ë””ìì¸ íŒ¨í„´ì´ë€?**

> ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œ ë°©ë²•ì—ì„œ ì‚¬ìš©ë˜ëŠ”Â **ë””ìì¸ íŒ¨í„´**ì€ í”„ë¡œê·¸ë¨ ê°œë°œì—ì„œ ìì£¼ ë‚˜íƒ€ë‚˜ëŠ” ê³¼ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ ë°©ë²• ì¤‘ í•˜ë‚˜ë¡œ, ê³¼ê±°ì˜ ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œ ê³¼ì •ì—ì„œ ë°œê²¬ëœ ì„¤ê³„ì˜ ë…¸í•˜ìš°ë¥¼ ì¶•ì í•˜ì—¬ ì´ë¦„ì„ ë¶™ì—¬, ì´í›„ì— ì¬ì´ìš©í•˜ê¸° ì¢‹ì€ í˜•íƒœë¡œ íŠ¹ì •ì˜ ê·œì•½ì„ ë¬¶ì–´ì„œ ì •ë¦¬í•œ ê²ƒì´ë‹¤.

ë””ìì¸ íŒ¨í„´ì€ ê¼­ ì´ë ‡ê²Œ í•´ì•¼ í•œë‹¤ë¼ê¸°ë³´ë‹¤ëŠ” â€˜ê¸°ì¶œ ë¬¸ì œâ€™ì™€ ê·¸ ì„±ê²©ì´ ë¹„ìŠ·í•©ë‹ˆë‹¤. í˜¹ìëŠ” â€˜ë¹„ê¸‰ì„œâ€™ì™€ ê°™ë‹¤ê³ ë„ í•©ë‹ˆë‹¤. ì„ ëŒ€ì˜ ê³ ë¯¼ì˜ í”ì ì„ ë³¼ ìˆ˜ ìˆëŠ” ê²ƒì´ì£ .

ì‹¬ì§€ì–´ ì´ë¯¸ ì•Œê³ , í™œìš©í•˜ê³  ìˆëŠ” ë””ìì¸ íŒ¨í„´ë“¤ë„ ìˆìŠµë‹ˆë‹¤.

1. **ì‹±ê¸€í†¤** íŠ¹ì •í•œ ê¸°ëŠ¥ì„ í•˜ëŠ” ì˜¤ë¸Œì íŠ¸ê°€ í•œ ê°œë§Œ ì¡´ì¬í•´ì•¼ í•˜ê²Œ í•˜ëŠ” íŒ¨í„´
2. **ì˜¤ë¸Œì íŠ¸ í’€** ì˜¤ë¸Œì íŠ¸ì˜ ì¬í™œìš©ì„ í†µí•´ íš¨ìœ¨ì ìœ¼ë¡œ ì˜¤ë¸Œì íŠ¸ë¥¼ ìƒì„±í•˜ê³  íšŒìˆ˜í•˜ëŠ” íŒ¨í„´
3. **ì»´í¬ë„ŒíŠ¸ íŒ¨í„´** ë…ë¦½ì ì¸ ê¸°ëŠ¥ì„ í•˜ëŠ” ë‹¤ì–‘í•œ ê¸°ëŠ¥ë“¤ì„ ë‹¤ì–‘í•œ ì˜¤ë¸Œì íŠ¸ì— ë¶™ì´ê³  ë—„ ìˆ˜ ìˆë„ë¡ êµ¬ì„±í•˜ëŠ” íŒ¨í„´
4. **ê²Œì„ë£¨í”„ (ì—…ë°ì´íŠ¸)** ê²Œì„ì˜ ì˜¤ë¸Œì íŠ¸ì— ë¼ì´í”„ì‚¬ì´í´ì„ ì„¤ì •í•˜ê³  ì´ë¥¼ í†µí•´ ê²Œì„ì˜¤ë¸Œì íŠ¸ê°€ ì‹¤í–‰í•´ì•¼ í•  í–‰ë™ë“¤ì„ ì²´ê³„ì ìœ¼ë¡œ ê´€ë¦¬

### ì „ëµ íŒ¨í„´

ë‹¤ì–‘í•œ í–‰ë™ì„ í•  ìˆ˜ ìˆëŠ” ë“œë¡ ì´ ìˆë‹¤ê³  ìƒê°í•´ë´…ì‹œë‹¤. ì´ ë“œë¡ ì´ í•­ìƒ ë˜‘ê°™ì´ í”„ë¡œê·¸ë˜ë°í•œ ëŒ€ë¡œë§Œ ì›€ì§ì´ëŠ” ê²Œ ì•„ë‹ˆë¼, ì‹¤ì œ ì‹¤í–‰**(ëŸ°íƒ€ì„) ì¤‘ì—** ëœë¤ìœ¼ë¡œ í˜¹ì€ ìœ ì €ì˜ ì…ë ¥ì— ë”°ë¼ ì–´ë–¤ í–‰ë™ì´ ë‹¬ë¼ì§ˆ ì§€ êµ¬í˜„í•œë‹¤ê³  ìƒê°í•´ë´…ì‹œë‹¤.

ì¦‰, ê°ì²´ì§€í–¥ ê·¸ ìì²´ íŒ¨í„´ì…ë‹ˆë‹¤. ê³µí†µì ì¸ ë‚´ìš©ë“¤ì„ ì¶”ìƒí™”í•˜ê³ , ì´ë¥¼ í†µí•´ ë™ì ìœ¼ë¡œ í”„ë¡œê·¸ë¨ì˜ ì‹¤í–‰íë¦„ì„ ë³€ê²½ì‹œí‚¤ëŠ” íŒ¨í„´ì´ë‹¤ë¼ê³  ìƒê°í•´ì£¼ì‹œë©´ ë©ë‹ˆë‹¤.

<aside> ğŸ’¡ **[ì •ë¦¬]** í•œ í´ë˜ìŠ¤ê°€ ë‹¤ì–‘í•œ ì—­í• ì„ í•  ìˆ˜ ìˆê³  ì´ì— ëŒ€í•œ ì „ëµì„ ë§Œë“¤ì–´ë‘”ë‹¤. ì´ ì¤‘ í•œê°€ì§€ì˜ ì „ëµì„ í”Œë ˆì´íƒ€ì„ì— ì‹¤í–‰í•  ìˆ˜ ìˆë„ë¡ ë¡œì§ì„ êµ¬í˜„í•œë‹¤.

</aside>

![[Pasted image 20240122210041.png]]

- (1ì•ˆ) í•„ë“œë¥¼ í†µí•´ êµ¬í˜„í•˜ëŠ” ê²½ìš°
    
    ```csharp
    using UnityEngine;
    
    namespace Chapter.Strategy {
        public class Drone : MonoBehaviour {
            
            // Ray parameters
      
te float _rayAngle = -45.0f;
            [SerializeField] private float _rayDistance = 15.0f;
    
            // Movement parameters
            public float speed = 1.0f;
            public float maxHeight = 5.0f;
            public float weavingDistance = 1.5f;
            public float fallbackDistance = 20.0f;
    
            void Start() {
                _rayDirection = 
                    transform.TransformDirection(Vector3.back) 
                    * _rayDistance;
                
                _rayDirection = 
                    Quaternion.Euler(_rayAngle, 0.0f, 0f) 
                    * _rayDirection;
    
    						StartCoroutine(Manuever());
            }
    
            void Update() {
                Debug.DrawRay(transform.position, 
                    _rayDirection, Color.blue);
                
                if (Physics.Raycast(
                    transform.position,
                    _rayDirection, out _hit, _rayDistance)) {
                    
                    if (_hit.collider) {
                        Debug.DrawRay(
                            transform.position, 
                            _rayDirection, Color.green);
                    }
                }
            }
    
    		IEnumerator Manuever(){
    			    while (true) {
                  time = 0;
                  Vector3 start = drone.transform.position;
                  Vector3 end = 
                      (isReverse) ? startPosition : endPosition;
    
                  while (time < speed) {
                      drone.transform.position = 
                          Vector3.Lerp(start, end, time / speed);
                      time += Time.deltaTime;
                      yield return null;
                  }
                  yield return new WaitForSeconds(1);
                  isReverse = !isReverse;
              }
    			}
        }
    }
    ```
    
- (2ì•ˆ) ifë¬¸ì„ í†µí•´ êµ¬í˜„í•˜ë ¤ëŠ” ê²½ìš°
    
    ```csharp
    using UnityEngine;
    
    namespace Chapter.Strategy {
    
    		public enum DroneType {
    			Bopple, Weave, Fallback
    		}
    
        public class Drone : MonoBehaviour {
            
            // Ray parameters
            private RaycastHit _hit;
            private Vector3 _rayDirection;
            private float _rayAngle = -45.0f;
            private float _rayDistance = 15.0f;
    
            // Movement parameters
            public float speed = 1.0f;
            public float maxHeight = 5.0f;
            public float weavingDistance = 1.5f;
            public float fallbackDistance = 20.0f;
    
    				public DroneType type;
    
            void Start() {
    						switch(type){
    								case DroneType.Bopple:
    									_rayAngle = ~~;
    								case DroneType.Weave:
    									_rayAngle = ~~;
    						}
    /*
                _rayDirection = 
                    transform.TransformDirection(Vector3.back) 
                    * _rayDistance;
                
                _rayDirection = 
                    Quaternion.Euler(_rayAngle, 0.0f, 0f) 
                    * _rayDirection;
    */
    						StartCoroutine(Manuever());
            }
    
            void Update() {
                Debug.DrawRay(transform.position, 
                    _rayDirection, Color.blue);
                
                if (Physics.Raycast(
                    transform.position,
                    _rayDirection, out _hit, _rayDistance)) {
                    
                    if (_hit.collider) {
                        Debug.DrawRay(
                            transform.position, 
                            _rayDirection, Color.green);
                    }
                }
            }
    
    		IEnumerator Manuever(){
    			    while (true) {
                  time = 0;
                  Vector3 start = drone.transform.position;
                  Vector3 end = 
                      (isReverse) ? startPosition : endPosition;
    
                  while (time < speed) {
                      drone.transform.position = 
                          Vector3.Lerp(start, end, time / speed);
                      time += Time.deltaTime;
                      yield return null;
                  }
                  yield return new WaitForSeconds(1);
                  isReverse = !isReverse;
              }
    			}
        }
    }
    ```
    
- (3ì•ˆ) ì „ëµ íŒ¨í„´ì„ í†µí•´ êµ¬í˜„í•˜ëŠ” ê²½ìš°
    
    ì „ëµ ì¸í„°í˜ì´ìŠ¤
    
    ```csharp
    namespace Chapter.Strategy
    {
        public interface IManeuverBehaviour
        {
            void Maneuver(Drone drone);
        }
    }
    ```
    
    ì „ëµ êµ¬í˜„ë¶€ (Boppleë§Œ)
    
    ```csharp
    using UnityEngine;
    using System.Collections;
    
    namespace Chapter.Strategy {
        public class BoppingManeuver : 
            MonoBehaviour, IManeuverBehaviour { 
            
            public void Maneuver(Drone drone) {
                StartCoroutine(Bopple(drone));
            }
    
            IEnumerator Bopple(Drone drone)
            {
                float time;
                bool isReverse = false;
                float speed = drone.speed;
                Vector3 startPosition = drone.transform.position;
                Vector3 endPosition = startPosition;
                endPosition.y = drone.maxHeight;
    
                while (true) {
                    time = 0;
                    Vector3 start = drone.transform.position;
                    Vector3 end = 
                        (isReverse) ? startPosition : endPosition;
    
                    while (time < speed) {
                        drone.transform.position = 
                            Vector3.Lerp(start, end, time / speed);
                        time += Time.deltaTime;
                        yield return null;
                    }
    								**// ë³€ìˆ˜ë§Œ ë°”ê¾¸ëŠ” ìˆ˜ì¤€ì—ì„œ ë³µì¡í•œ ì¡°ì‘ì´ ê°€ëŠ¥í•˜ë„ë¡ êµ¬í˜„ ê°€ëŠ¥!**
    
                    yield return new WaitForSeconds(1);
                    isReverse = !isReverse;
                }
            }
        }
    }
    ```
    
    ë“œë¡  êµ¬í˜„ë¶€
    
    ```csharp
    using UnityEngine;
    
    namespace Chapter.Strategy {
        public class Drone : MonoBehaviour {
            
            // Ray parameters
            private RaycastHit _hit;
            private Vector3 _rayDirection;
            private float _rayAngle = -45.0f;
            private float _rayDistance = 15.0f;
    
            // Movement parameters
            public float speed = 1.0f;
            public float maxHeight = 5.0f;
            public float weavingDistance = 1.5f;
            public float fallbackDistance = 20.0f;
    
            void Start() {
                _rayDirection = 
                    transform.TransformDirection(Vector3.back) 
                    * _rayDistance;
                
                _rayDirection = 
                    Quaternion.Euler(_rayAngle, 0.0f, 0f) 
                    * _rayDirection;
            }
    
            public void ApplyStrategy(IManeuverBehaviour strategy) {
                strategy.Maneuver(this);
            }
    
            void Update() {
                Debug.DrawRay(transform.position, 
                    _rayDirection, Color.blue);
                
                if (Physics.Raycast(
                    transform.position,
                    _rayDirection, out _hit, _rayDistance)) {
                    
                    if (_hit.collider) {
                        Debug.DrawRay(
                            transform.position, 
                            _rayDirection, Color.green);
                    }
                }
            }
        }
    }
    ```
    
    ì „ëµ ì ìš©ë¶€
    
    ```csharp
    using UnityEngine;
    using System.Collections.Generic;
    
    namespace Chapter.Strategy {
        public class ClientStrategy : MonoBehaviour {
            
            private GameObject _drone;
            private List<IManeuverBehaviour> 
                _components = new List<IManeuverBehaviour>();
            
            private void SpawnDrone() {
                _drone = 
                    GameObject.CreatePrimitive(PrimitiveType.Cube);
                
                _drone.AddComponent<Drone>();
                
                _drone.transform.position = 
                    Random.insideUnitSphere * 10;
                
                ApplyRandomStrategies();
            }
    
            private void ApplyRandomStrategies() {
                _components.Add(
                    _drone.AddComponent<WeavingManeuver>());
                _components.Add(
                    _drone.AddComponent<BoppingManeuver>());
                _components.Add(
                    _drone.AddComponent<FallbackManeuver>());
                
                int index = Random.Range(0, _components.Count);
                
                _drone.GetComponent<Drone>().
                    ApplyStrategy(_components[index]);
            }
            
            void OnGUI() {
                if (GUILayout.Button("Spawn Drone")) {
                    SpawnDrone();
                }
            }
        }
    }
    ```
    

### ëª…ë ¹ íŒ¨í„´

ëª…ë ¹ íŒ¨í„´ì€ í•œë§ˆë””ë¡œ **ë©”ì†Œë“œë¥¼ ê°ì²´ì²˜ëŸ¼ ë§Œë“œëŠ” ê²ƒ**ì´ë¼ê³  ìƒê°í•˜ë©´ í¸í•©ë‹ˆë‹¤. ì´ëŸ° íŒ¨í„´ì„ ì•ˆì“°ë©´ ìš°ë¦¬ëŠ” ê·¸ì € ì•„ë˜ì™€ ê°™ì´ ì‘ì„±í•˜ê² ì§€ë§Œ,

```csharp
if(Input.GetKey(KeyCode.LeftArrow)){
	GoLeft();
}

void GoLeft(){
	Debug.Log("Left Turn!");
}
```

ëª…ë ¹íŒ¨í„´ì„ í™œìš©í•˜ë©´ ì•„ë˜ì™€ ê°™ì´ ë°”ê¿€ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```csharp
public abstract class Command {
	public abstract void Execute();
}

public class LeftCommand : Command {
	public override void Execute(){
		Debug.Log("Left Turn!");
	}
}

/// Another Class 
LeftCommand leftCommand = new LeftCommand();

if(Input.GetKey(KeyCode.LeftArrow)){
	leftCommand.Execute();
}
```

ìœ„ì™€ ê°™ì€ ë°©ì‹ì´ í›¨ì”¬ ë” ë³µì¡í•´ë³´ì¼ ìˆ˜ ìˆì§€ë§Œ, ìœ ì§€ë³´ìˆ˜ì„±ì„ ê°•í™”í•´ì£¼ëŠ” ë°ì—ëŠ” ì¢‹ì€ ë°©ì‹ì˜ ì½”ë“œ ì‘ì—… ë°©ì‹ì´ë¼ê³  ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë ˆì´ì‹± ê²Œì„ ì‘ì—… ì¤‘ í•œ ëª…ì€ ëŒ€ì‹œ ì‘ì—…, í•œ ëª…ì€ ì í”„ ì‘ì—…ì„ í•œë‹¤ê³  ìƒê°í•´ë´…ì‹œë‹¤. ì‘ì—…ì„ ë‚˜ëˆ ì„œ í•˜ê¸° ë•Œë¬¸ì— í›¨ì”¬ ë” í™•ì¥ì„±ì´ ë†’ì•„ì§€ê² ì£ ?

- ì˜ˆì‹œ 1 - ë¦¬í”Œë ˆì´ ì‹œìŠ¤í…œ ì „ì œì‚¬í•­ : ê²°ì •ë¡ ì (deterministic) ê²Œì„ ê²°ê³¼ ë¶€ìŠ¤í„° ì¼ì„ ë•Œ ì†ë„ê°€ ëœë¤ìœ¼ë¡œ 0 ~ 10KM/H ë¹¨ë¼ì§„ë‹¤ ì´ëŸ°ê±° ì—†ìŒ í”„ë ˆì„ ì‹œê°„ì— ëŒ€í•œ ë³´ì • ìˆì–´ì•¼í•¨(fixedupdateìœ„ì£¼, approximate ê³ ë ¤) transform.Translate(Vector3.right * Time.deltaTime);
    
    â†’ ë©€í‹°í”Œë ˆì´ ê²Œì„!
    
    Command
    
    ```csharp
    namespace Chapter.Command
    {
        public abstract class Command
        {
            public abstract void Execute();
        }
    }
    
    namespace Chapter.Command
    {
        public class ToggleTurbo : Command
        {
            private BikeController _controller;
    
            public ToggleTurbo(BikeController controller)
            {
                _controller = controller;
            }
    
            public override void Execute()
            {
                _controller.ToggleTurbo();
            }
        }
    }
    ```
    
    Controller
    
    ```csharp
    using UnityEngine;
    
    namespace Chapter.Command
    {
        public class BikeController : MonoBehaviour
        {
            public enum Direction
            {
                Left = -1,
                Right = 1
            }
    
            private bool _isTurboOn;
            private float _distance = 1.0f;
        
            public void ToggleTurbo()
            {
                _isTurboOn = !_isTurboOn;
            }
        
            public void Turn(Direction direction)
            {
                if (direction == Direction.Left) 
                    transform.Translate(Vector3.left * _distance);
            
                if (direction == Direction.Right)
                    transform.Translate(Vector3.right * _distance);
            }
    
            public void ResetPosition()
            {
                transform.position = new Vector3(0.0f, 0.0f, 0.0f);
            }
        }
    }
    ```
    
    Invoker
    
    ```csharp
    using UnityEngine;
    using System.Linq;
    using System.Collections.Generic;
    
    namespace Chapter.Command
    {
        class Invoker : MonoBehaviour
        {
            private bool _isRecording;
            private bool _isReplaying;
            private float _replayTime;
            private float _recordingTime;
            private SortedList<float, Command> _recordedCommands = 
                new SortedList<float, Command>();
    
            public void ExecuteCommand(Command command)
            {
                command.Execute();
                
                if (_isRecording) 
                    _recordedCommands.Add(_recordingTime, command);
                
                Debug.Log("Recorded Time: " + _recordingTime);
                Debug.Log("Recorded Command: " + command);
            }
    
            public void Record()
            {
                _recordingTime = 0.0f;
                _isRecording = true;
            }
    
            public void Replay()
            {
                _replayTime = 0.0f;
                _isReplaying = true;
                
                if (_recordedCommands.Count <= 0)
                    Debug.LogError("No commands to replay!");
                
                _recordedCommands.Reverse();
            }
            
            void FixedUpdate()
            {
                if (_isRecording) 
                    _recordingTime += Time.fixedDeltaTime;
                
                if (_isReplaying)
                {
                    _replayTime += Time.fixedDeltaTime;
    
                    if (_recordedCommands.Any()) 
                    {
                        if (Mathf.Approximately(
                            _replayTime, _recordedCommands.Keys[0])) {
    
                            Debug.Log("Replay Time: " + _replayTime);
                            Debug.Log("Replay Command: " + 
                                      _recordedCommands.Values[0]);
                            
                            _recordedCommands.Values[0].Execute();
                            _recordedCommands.RemoveAt(0);
                        }
                    }
                    else
                    {
                        _isReplaying = false;
                    }
                }
            }
        }
    }
    ```
    

**ë©”ë©˜í†  íŒ¨í„´**

<aside> ğŸ’¡ ë©”ë©˜í†  íŒ¨í„´ì€ ë’¤ë¡œ ëŒì•„ê°ˆ ìˆ˜ ìˆë„ë¡ êµ¬í˜„í•˜ëŠ” ê²ƒì„ ë§í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ê²Œì„ì„ í”Œë ˆì´í•˜ë‹¤ê°€ ì£½ì—ˆì„ ë•Œ, 1ì´ˆì •ë„ì˜ ìˆœê°„ì„ ì €ì¥í•´ë‘ê³ , ì´ë¥¼ ì—­ì¬ìƒí•  ìˆ˜ ìˆê² ì£ ? ì•„ë‹ˆë©´ ìœ ë‹ˆí‹° ê°™ì€ í”„ë¡œê·¸ë¨ì„ ì“°ë‹¤ê°€ ì˜ëª»í–ˆì„ ë•Œ Ctrl+Zë¥¼ í†µí•´ì„œ ëŒì•„ê°€ê³  ì‹¶ì„ ìˆ˜ ìˆì£ ? ì´ë ‡ê²Œ **ëŒì•„ê°ˆ ìˆ˜ ìˆë„ë¡ ì„¤ê³„**í•˜ëŠ” ë°©ë²•ì„ **ë©”ë©˜í† ** íŒ¨í„´ì´ë¼ê³  í•˜ë©°, ëª…ë ¹ íŒ¨í„´ì„ í™œìš©í•˜ì—¬ ì‰½ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆë‹µë‹ˆë‹¤.

ë°©ë²• : ëª…ë ¹ íŒ¨í„´ìœ¼ë¡œ êµ¬í˜„í•œë‹¤ìŒì— ëª…ë ¹ë“¤ì„ ë¦¬ìŠ¤íŠ¸ì— ë„£ê³  ì—­ìœ¼ë¡œ ì½ìœ¼ë©´ ë!

</aside>

![[Pasted image 20240122210131.png]]

> íŠ¹ì´í•˜ê²Œë„ ì˜í™” ì „ê°œëŠ” ì‹œê°„ìˆœì´ ì•„ë‹Œ ì—­ìˆœì´ê³ , í‘ë°±ìœ¼ë¡œ ë‚˜ì˜¤ëŠ” ê³¼ê±° ì´ì•¼ê¸°ëŠ” ì‹œê°„ìˆœì´ë‹¤. ê·¸ëŸ¬í•œ ê·¹ ì „ê°œê°€ ê³¼ê±° ê¸°ì–µê³¼ ë§ë¬¼ë¦¬ê²Œ ëœë‹¤. ê·¸ë ‡ê¸°ì— ì ê¹ì´ë¼ë„ ì¥ë©´ì„ ë†“ì¹œë‹¤ë©´ ë‚´ìš©ì„ ë”°ë¼ê°€ê¸°ê°€ í˜ë“  ì˜í™”ë‹¤.

- ì˜ˆì‹œ 1 - ë˜ëŒë¦¬ê¸°
    
    ```csharp
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    
    public class TimeBody : MonoBehaviour {
    
    	bool isRewinding = false;
    
    	public float recordTime = 5f;
    
    	List<PointInTime> pointsInTime;
    
    	Rigidbody rb;
    
    	// Use this for initialization
    	void Start () {
    		pointsInTime = new List<PointInTime>();
    		rb = GetComponent<Rigidbody>();
    	}
    	
    	// Update is called once per frame
    	void Update () {
    		if (Input.GetKeyDown(KeyCode.Return))
    			StartRewind();
    		if (Input.GetKeyUp(KeyCode.Return))
    			StopRewind();
    	}
    
    	void FixedUpdate ()
    	{
    		if (isRewinding)
    			Rewind();
    		else
    			Record();
    	}
    
    	void Rewind ()
    	{
    		if (pointsInTime.Count > 0)
    		{
    			PointInTime pointInTime = pointsInTime[0];
          transform.position = pointInTime.position;
    			transform.rotation = pointInTime.rotation;
    			pointsInTime.RemoveAt(0);
    		} else
    		{
    			StopRewind();
    		}
    		
    	}
    
    	void Record ()
    	{
    		if (pointsInTime.Count > Mathf.Round(recordTime / Time.fixedDeltaTime))
    		{
    			pointsInTime.RemoveAt(pointsInTime.Count - 1);
    		}
    
    		pointsInTime.Insert(0, new PointInTime(transform.position, transform.rotation));
    	}
    
    	public void StartRewind ()
    	{
    		isRewinding = true;
    		rb.isKinematic = true;
    	}
    
    	public void StopRewind ()
    	{
    		isRewinding = false;
    		rb.isKinematic = false;
    	}
    }
    ```
    

### ì˜µì €ë²„ íŒ¨í„´

ì‚¬ì‹¤ ì˜µì €ë²„ íŒ¨í„´ì€ ì´ë¯¸ ë§ì´ í™œìš©í•´ë³´ì…¨ìŠµë‹ˆë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, Input Systemì—ì„œ ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ íŠ¹ì •í•œ í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ë„ë¡ êµ¬í˜„í•œë‹¤ë“ ì§€, ì–´ë–¤ ê°’ì´ ë³€ê²½ë  ê²½ìš°ì— íŠ¹ì •í•œ ì´ë²¤íŠ¸ê°€ ë°œìƒí•œë‹¤ë“ ì§€ í•˜ëŠ” ì‹ì…ë‹ˆë‹¤.

ì˜µì €ë²„ íŒ¨í„´ì€ ì´ë²¤íŠ¸ë¥¼ íŠ¹ì •í•œ ì˜¤ë¸Œì íŠ¸ê°€ ë°œìƒì‹œí‚¬ ê²½ìš° ì´ë¥¼ êµ¬ë…í•˜ëŠ” êµ¬ë…ìë“¤ì˜ í•¨ìˆ˜ë¥¼ ì‹¤í–‰ì‹œí‚¤ê²Œ í•˜ëŠ” íŒ¨í„´ì„ ë§í•©ë‹ˆë‹¤. ì´ë•Œ, ë°œí–‰ìì™€ êµ¬ë…ìì˜ ê´€ê³„ì— ë”°ë¼, ì•„ë˜ì™€ ê°™ì´ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/83c75a39-3aba-4ba4-a792-7aefe4b07895/aeea8c06-20b6-4c3b-b7ca-bf1d0f952f6f/Untitled.png)

ì˜µì €ë²„ íŒ¨í„´ì€ ë°œí–‰ìê°€ 1ëª…ì¼ë•Œ, êµ¬ë…ìê°€ Nëª…ì¸ ë°©ì‹ìœ¼ë¡œ, HPë°”ê°€ ê°ì†Œí–ˆì„ ë•Œ HPë°”ì— ëŒ€í•œ UIì²˜ë¦¬, ìŠ¹ë¦¬/íŒ¨ë°° ì²˜ë¦¬ ë“±ì„ ê°™ì´ í•´ì•¼ í•  ë•Œ ì´ëŸ° ë°©ì‹ì„ ìƒê°í•´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

- ì˜ˆì‹œ 1
    
    ```csharp
    public abstract class Observer
    {
        // ìƒíƒœ update ë©”ì„œë“œ
        public abstract void OnNotify();
    }
    // =================================
    
    // ì˜µì €ë²„ êµ¬í˜„í´ë˜ìŠ¤
    public class ConcreteObserver1 : Observer
    {
        // ëŒ€ìƒíƒ€ì…ì˜ í´ë˜ìŠ¤ì—ì„œ ì´ ë©”ì†Œë“œë¥¼ ì‹¤í–‰ì‹œí‚´
        public override void OnNotify()
        {
            Debug.Log("ì˜µì €ë²„ í´ë˜ìŠ¤ì˜ ë©”ì„œë“œ ì‹¤í–‰ #1");
        }
    }
    // =================================
    
    public interface ISubject
    {
        void AddObserver(Observer o);
        void RemoveObserver(Observer o);
        void Notify();
    }
    
    // =================================
    
    // ëŒ€ìƒ í´ë˜ìŠ¤
    // : ëŒ€ìƒ ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œ í´ë˜ìŠ¤
    public class ConcreteSubject : MonoBehaviour, ISubject
    {
        List<Observer> observers = new List<Observer>();  // ì˜µì €ë²„ë¥¼ ê´€ë¦¬í•˜ëŠ” List
    
        // ê´€ë¦¬í•  ì˜µì €ë²„ë¥¼ ë“±ë¡
        public void AddObserver(Observer observer)
        {
            observers.Add(observer);
        }
    
        // ê´€ë¦¬ì¤‘ì¸ ì˜µì €ë²„ë¥¼ ì‚­ì œ
        public void RemoveObserver(Observer observer)
        {
            if (observers.IndexOf(observer) > 0) observers.Remove(observer);
        }
    
        // ê´€ë¦¬ì¤‘ì¸ ì˜µì €ë²„ì—ê²Œ ì—°ë½
        public void Notify()
        {
    				foreach (Observer o in observers)
    				{
    					o.OnNotify();
    				}
        }
    
        void Start()
        {
            Observer obj1 = new ConcreteObserver1();
    
            AddObserver(obj1);
        }
    }
    ```
    
- ì˜ˆì‹œ 2 - event í™œìš©
    
    ```csharp
    public class PlayerCharacter : MonoBehaviour
    	{
    	    public event Action<Enemy> OnAttack; // ì´ë²¤íŠ¸ ì„ ì–¸
    
    	    public void Attack(Enemy enemy)
    	    {
    	        // ê³µê²© ë™ì‘ ìˆ˜í–‰
    	        // ...
    
    	        // ì´ë²¤íŠ¸ í˜¸ì¶œ
    	        OnAttack?.Invoke(enemy);
    	    }
    	}
    
    	public class Enemy : MonoBehaviour
    	{
    	    private void Start()
    	    {
    	        PlayerCharacter player = FindObjectOfType<PlayerCharacter>();
    	        player.OnAttack += ReactToAttack; // ì˜µì €ë²„ ë“±ë¡
    	    }
    
    	    private void ReactToAttack(Enemy enemy)
    	    {
    	        // ê³µê²©ì— ëŒ€í•œ ë°˜ì‘ êµ¬í˜„
    	        // ...
    	    }
    	}
    
    public class PlayerHealth : MonoBehaviour
    {
        public Text healthText;
    
        private int health = 100;
    
        private void Start()
        {
            UpdateUI();
        }
    
        public void TakeDamage(int damage)
        {
            health -= damage;
            UpdateUI();
        }
    
        private void UpdateUI()
        {
            healthText.text = "Health: " + health.ToString();
        }
    }
    
    public class Explosion : MonoBehaviour
    {
        public delegate void ExplosionEventHandler();
        public static event ExplosionEventHandler OnExplode; // ì´ë²¤íŠ¸ ì„ ì–¸
    
        private void Start()
        {
            Explode();
        }
    
        private void Explode()
        {
            // í­ë°œ ë™ì‘ ìˆ˜í–‰
            // ...
    
            // ì´ë²¤íŠ¸ í˜¸ì¶œ
            OnExplode?.Invoke();
        }
    }
    
    public class PlayerController : MonoBehaviour
    {
        private void Start()
        {
            // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë“±ë¡
            Explosion.OnExplode += PlayExplosionSound;
        }
    
        private void PlayExplosionSound()
        {
            // í­ë°œ ì‚¬ìš´ë“œ ì¬ìƒ
            // ...
        }
    }
    ```
    

## ê²Œì„ìˆ˜í•™ - íšŒì „

**ìš°ë¦¬ê°€ íšŒì „ì„ ìƒê°í•˜ëŠ” ë°©ë²• 3ê°€ì§€**

1. ì˜¤ì¼ëŸ¬ê° - x, y, zì¶•ì˜ ê°ê°ì˜ íšŒì „ìœ¼ë¡œ í‘œí˜„í•˜ëŠ” ë°©ì‹

2D - Zì¶•ìœ¼ë¡œ íšŒì „, X, Yì¶•ì—ì„œ ì´ë™ 3D - X/Y/Zì¶•ìœ¼ë¡œ íšŒì „, X, Y, Zì¶•ì—ì„œ ì´ë™ (êµ­ë£° : XZì¶• í‰ë©´ì—ì„œ ì´ë™ Yì¶•ì—ì„œ ì í”„ : y-up)

**ì§ë²Œë½** - [MAXë¥¼ í™œìš©í•œ ì§ë²Œë½Gimbal-lock)ì„¤ëª… (youtube.com)](https://www.youtube.com/watch?v=yxMQKsab5TQ&t=321s)

2. ì‚¬ì›ìˆ˜(ì¿¼í„°ë‹ˆì–¸) - w, x, y, zì˜ ë„¤ ê°€ì§€ ìˆ˜ë¡œ íšŒì „ì„ í‘œí˜„í•˜ëŠ” ë°©ì‹

ê²Œì„ ì—”ì§„ì—ì„œëŠ” ì£¼ë¡œ ì¿¼í„°ë‹ˆì–¸ì„ í™œìš©í•˜ì—¬ íšŒì „í•˜ì§€ë§Œ **ë§¤ìš° ë¹„ì§ê´€ì ì´ê¸° ë•Œë¬¸ì—** ê°œë°œìë“¤ì€ ì˜¤ì¼ëŸ¬ê°ì„ ì¿¼í„°ë‹ˆì–¸ìœ¼ë¡œ ë°”ê¾¸ëŠ” ë°©ì‹ì„ í™œìš©í•˜ê³ , ì´ëŸ¬í•œ ë©”ì†Œë“œë¥¼ ì œê³µí•œë‹¤. Quaternion.Identity // íšŒì „ì´ ì—†ë‹¤

Quaternion.Euler â† ì˜¤ì¼ëŸ¬ê°ì„ ì¿¼í„°ë‹ˆì–¸ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” ë°©ì‹

Transform.eulerAngles â† ì˜¤ì¼ëŸ¬ê°ì„ íšŒì „ì— ì§ì ‘ ë°˜ì˜í•˜ëŠ” ë°©ì‹

ë¬¸ì œ : **ìš°ë¦¬ê°€ ìƒê°í•˜ëŠ” ì–´ë–¤ íŠ¹ì •í•œ íšŒì „ì„ ì ìš©í•˜ëŠ” ìˆ˜ë§ì€ ì¿¼í„°ë‹ˆì–¸ì´ ìˆë‹¤.**

- íšŒì „ ì‚¬ìš©ì‹œ ì£¼ì˜ì‚¬í•­
    
    ```csharp
    void Update ()
    {
        var rot = transform.rotation; // Quaternion
        rot.x += Time.deltaTime * 10; // Quaternionì€ í¬ê¸°ê°€ 1ì¸ ë²¡í„°ë¼ê³  ìƒê°ê°€ëŠ¥ ë‹¨ìœ„ì‚¬ì›ìˆ˜
        transform.rotation = rot;
    }
    ```
    
    ```csharp
    // rotation scripting mistake #2
    // Read, modify, then write the Euler values from a Quaternion.
    // Because these values are calculated from a Quaternion,
    // each new rotation might return very different Euler angles, which might suffer from gimbal lock.
    
    void Update ()
    {
        var angles = transform.rotation.eulerAngles;
        angles.x += Time.deltaTime * 10;
        transform.rotation = Quaternion.Euler(angles);
    }
    // Debug.Log ë­ê°€ ë‚˜ì˜¤ê³  ìˆëŠ”ì§€ë¥¼ ê¼­ ë´ì•¼ë¨
    ```
    
    ê·¸ë¦¬ê³  ë‹¤ìŒì€ ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ì˜¤ì¼ëŸ¬ ê°ì„Â **ì˜¬ë°”ë¥´ê²Œ**Â ì‚¬ìš©í•˜ëŠ” ì˜ˆì…ë‹ˆë‹¤.
    
    ```csharp
    // Rotation scripting with Euler angles correctly.
    // Store the Euler angle in a class variable, and only use it to
    // apply it as an Euler angle, but never rely on reading the Euler back.
    
    float x;
    void Update ()
    {
        x += Time.deltaTime * 10;
        transform.rotation = Quaternion.Euler(x,0,0);
    }
    ```
    
    ```csharp
    using UnityEngine;
    
    // demonstration of eulerAngles not returning the same values as assigned
    public class EulerAnglesProblemExample :MonoBehaviour
    {
        private void Start()
        {
    			Quaternion myRotation =Quaternion.identity;
            myRotation.eulerAngles = newVector3(150, 35, 45);
    
    			Debug.Log(myRotation.eulerAngles);
    
            // output is: (30.0, 215.0, 225.0)
        }
    }
    ```
    

3. ë°©í–¥ ë²¡í„° - íŠ¹ì •í•œ ë°©í–¥ì„ ë°”ë¼ë³´ê²Œ í•˜ê±°ë‚˜, íŠ¹ì •í•œ ë°©í–¥ê³¼ ì¶•ì„ ë§ì¶œ ë•Œ í™œìš©

- ì˜ˆì‹œ - LookRotation
    
    ```csharp
    public class ExampleClass : MonoBehaviour
    {
        public Transform target;
    
        void Update()
        {
            Vector3 relativePos = target.position - transform.position;
    
            // the second argument, upwards, defaults to Vector3.up
            Quaternion rotation = Quaternion.LookRotation(relativePos, Vector3.up);
            transform.rotation = rotation;
        }
    }
    ```
    
- ì˜ˆì‹œ - FromToRotation (ë²¡í„°ì˜ ì •ë ¬)
    
    ```csharp
    rb.velocity = transform.forward * speed.z;
    Ray ray = new Ray(transform.position, transform.forward);
    Physics.Raycast(transform.position, transform.forward, out RaycastHit hit, 1f);
    if (hit.collider != null)
    {
        Instantiate(Effect, hit.point, Quaternion.FromToRotation(Vector3.up, hit.normal));
        Destroy(gameObject);
    }
    ```
    

Lerp (ì„ í˜•ë³´ê°„)

Mathf.Lerp(float ì´ˆê¸°ê°’, float ëª©í‘œê°’, float ë¹„ìœ¨);

0, 1, 0.07 â‡’ 0.07

íšŒë³µë°” êµ¬í˜„

ë¹„ìœ¨ì„ ì˜¬ë ¤ì„œ ì„ í˜•ìœ¼ë¡œ ì±„ìš°ëŠ” ë²• VS ì—°ì¶œì  ëª©í‘œë¥¼ ìœ„í•´ ì´ˆê¸°ê°’ì„ ê±´ë“œë¦¬ëŠ” ê²ƒ(ì ˆëŒ€ 1ì•ˆë¨ ì£¼ì˜)

Slerp (êµ¬í˜•ë³´ê°„)

Quaternion.Slerp(Quaternion From, quaternion To, float ë¹„ìœ¨);