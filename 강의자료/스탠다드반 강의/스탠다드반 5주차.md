# 231215

## 싱글톤 복습

좋은 코드와 아쉬운 코드를 보면서, 어떻게 바꾸면 좋을지에 대해서 이야기해보는 시간을 가져봅시다.

- 동료 코드 1
    
    ```csharp
    using System.Collections.Generic;
    
    public class GameManager
    {
        public CharacterBlueprint PlayerBlueprint { get; private set; }
        public GameState State { get; private set; }
    
        public void Initialize()
        {
            State = GameState.Play;
        }
    }
    ```
    
- 동료 코드 2
    
    ```csharp
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using TMPro;
    using UnityEngine.SceneManagement;
    using UnityEngine.UI;
    
    public class GameManager : MonoBehaviour
    {
        public static GameManager instance;
    
        private HealthSystem playerHealthSystem;
    
        [SerializeField] private TextMeshProUGUI waveText;
        [SerializeField] private Slider hpGaugeSlider;
        [SerializeField] private GameObject gameOverUI;
    
        [SerializeField] private int currentWaveIndex = 0;
        private int currentSpawnCount = 0;
        private int waveSpawnCount = 0;
        private int waveSpawnPosCount = 0;
    
        public float spawnInterval = .5f;
        public List<GameObject> enemyPrefebs = new List<GameObject>();
    
        [SerializeField] private Transform spawnPositionsRoot;
        private List<Transform> spawnPositions = new List<Transform>();
    
        public Transform Player { get; private set; }
        [SerializeField] private string playerTag = "Player";
    
        public List<GameObject> rewards = new List<GameObject>();
    
        [SerializeField] private CharacterStats defaultStats;
        [SerializeField] private CharacterStats rangedStats;
    
        private void Awake()
        {
            instance = this;
            Player = GameObject.FindGameObjectWithTag(playerTag).transform;
    
            playerHealthSystem = Player.GetComponent<HealthSystem>();
            playerHealthSystem.OnDamage += UpdateHealthUI;
            playerHealthSystem.OnHeal += UpdateHealthUI;
            playerHealthSystem.OnDeath += GameOver;
    
            gameOverUI.SetActive(false);
    
            for (int i = 0; i < spawnPositionsRoot.childCount; i++)
            {
                spawnPositions.Add(spawnPositionsRoot.GetChild(i));
            }
        }
    
        private void Start()
        {
            UpgradeStatInit();
            StartCoroutine("StartNextWave");
        }
    
        IEnumerator StartNextWave()
        {
            while (true)
            {
                if (currentSpawnCount == 0)
                {
                    UpdateWaveUI();
                    yield return new WaitForSeconds(2f);
    
                    if (currentWaveIndex % 20 == 0)
                    {
                        RandomUpgrade();
                    }
    
                    if (currentWaveIndex % 10 == 0)
                    {
                        waveSpawnPosCount = waveSpawnPosCount + 1 > spawnPositions.Count ? waveSpawnPosCount : waveSpawnPosCount + 1;
                        waveSpawnCount = 0;
                    }
    
                    if (currentWaveIndex % 5 == 0)
                    {
                        CreateReward();
                    }
    
                    if (currentWaveIndex % 3 == 0)
                    {
                        waveSpawnCount += 1;
                    }
    
                    for (int i = 0; i < waveSpawnPosCount; i++)
                    {
                        int posIdx = Random.Range(0, spawnPositions.Count);
                        for (int j = 0; j < waveSpawnCount; j++)
                        {
                            int prefabIdx = Random.Range(0, enemyPrefebs.Count);
                            GameObject enemy = Instantiate(enemyPrefebs[prefabIdx], spawnPositions[posIdx].position, Quaternion.identity);
                            enemy.GetComponent<HealthSystem>().OnDeath += OnEnemyDeath;
                            enemy.GetComponent<CharacterStatsHandler>().AddStatModifier(defaultStats);
                            enemy.GetComponent<CharacterStatsHandler>().AddStatModifier(rangedStats);
                            currentSpawnCount++;
                            yield return new WaitForSeconds(spawnInterval);
                        }
                    }
    
                    currentWaveIndex++;
                }
    
                yield return null;
            }
        }
    
        private void UpdateHealthUI()
        {
            hpGaugeSlider.value = playerHealthSystem.CurrentHealth / playerHealthSystem.MaxHealth;
        }
    
        private void OnEnemyDeath()
        {
            currentSpawnCount--;
        }
    
        private void GameOver()
        {
            gameOverUI.SetActive(true);
            StopAllCoroutines();
        }
    
        private void UpdateWaveUI()
        {
            waveText.text = (currentWaveIndex + 1).ToString();
        }
    
        public void RestartGame()
        {
            SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
        }
    
        public void ExitGame()
        {
            SceneManager.LoadScene("StartScene");
        }
    
        void CreateReward()
        {
            int idx = Random.Range(0, rewards.Count);
            int posIdx = Random.Range(0, spawnPositions.Count);
    
            GameObject obj = rewards[idx];
            Instantiate(obj, spawnPositions[posIdx].position, Quaternion.identity);
        }
    
        void UpgradeStatInit()
        {
            defaultStats.statsChangeType = StatsChangeType.Add;
            defaultStats.attackSO = Instantiate(defaultStats.attackSO);
    
            rangedStats.statsChangeType = StatsChangeType.Add;
            rangedStats.attackSO = Instantiate(rangedStats.attackSO);
        }
    
        void RandomUpgrade()
        {
            switch (Random.Range(0, 6))
            {
                case 0:
                    defaultStats.maxHealth += 2;
                    break;
    
                case 1:
                    defaultStats.attackSO.power += 1;
                    break;
    
                case 2:
                    defaultStats.speed += 0.1f;
                    break;
    
                case 3:
                    defaultStats.attackSO.isOnKnockback = true;
                    defaultStats.attackSO.knockbackPower += 1;
                    defaultStats.attackSO.knockbackTime = 0.1f;
                    break;
    
                case 4:
                    defaultStats.attackSO.delay -= 0.05f;
                    break;
    
                case 5:
                    RangedAttackData rangedAttackData = rangedStats.attackSO as RangedAttackData;
                    rangedAttackData.numberofProjectilesPershot += 1;
                    break;
    
                default:
                    break;
            }
        }
    }
    ```
    

## 데이터의 저장

열심히 플레이 한 결과가 전부 다 날라가버린다면 그 게임을 하고 싶을까요?

데이터의 저장은 운영되고 있는 게임의 서비스 수명에 직접 영향을 주는 중요한 주제입니다.

### 직렬화

![[Pasted image 20240122203848.png]]

우리가 프로그래밍한 복잡한 객체를 바이트들의 배열로 만들어버리는 작업을 직렬화라고 하며, **모든 클래스를 직렬화할 수 있는 것은 아닙니다**.

유니티에서는 아래와 같은 필드들에 대해 직렬화할 수 있다고 정의하고 있습니다.

### 왜 데이터를 파일에 저장하면 좋을까

```csharp
switch(characterType){
	case CharacterType.Warrior:
		HP = 40;
		MP = 5;
		DEX = 10;
		
}
```

![[Pasted image 20240122203902.png]]

### 직렬화 가능 타입

![[Pasted image 20240122203941.png]]

⭐ 정리 : Serializable로 전체를 구성하고, 클래스 자체도 Serializable 어트리뷰트를 붙이면 직렬화 가능타입이 됩니다 ⭐

```csharp
[Serializable]
public class MyClass{
	public int a;
	public int b;
}

[Serializable]
public class MyBigClass{
	public MyClass my;
}

public class myCharacterData{
	// Transform 직접 넣는거 안됨
	public Vector3 position;
	public Quaternion rotation;
}
```

### **PlayerPrefs**

PlayerPrefs는 게임 세션 간에 **플레이어 환경설정**을 저장하는 클래스입니다. 이 클래스는 **문자열, 실수, 정수** 값을 사용자의 플랫폼 레지스트리에 저장할 수 있습니다.

유니티는 암호화하지 않고 로컬 레지스트리에 PlayerPrefs를 저장합니다. 민감한 데이터를 저장하는 데에는 적합하지 않습니다.

유니티는 애플리케이션이 실행되는 운영 체제에 따라 PlayerPrefs 데이터를 다르게 저장합니다. 이 페이지에 제공된 파일 경로에서 예제 회사 이름과 예제 제품 이름은 Unity의 플레이어 설정에서 설정한 이름입니다.

![[Pasted image 20240122204014.png]]

- 예제 1
    
    ```csharp
    string userId = "user1234";
    string password = "password123";
    string name = "홍길동";
    int balance = 10000;
    
    string combinedInfo = password + "," + name + "," + balance.ToString();
    PlayerPrefs.SetString(userId, combinedInfo);
    PlayerPrefs.Save();
    ```
    
    ```csharp
    if(PlayerPrefs.HasKey(userId){ // ID 있음
    	string savedInfo = PlayerPrefs.GetString(userId);
    	string[] infoParts = savedInfo.Split(',');
    	
    	string loadedPassword = infoParts[0];
    	string loadedName = infoParts[1];
    	int loadedBalance = int.Parse(infoParts[2]);
    	
    	Debug.Log("비밀번호: " + loadedPassword);
    	Debug.Log("이름: " + loadedName);
    	Debug.Log("잔액: " + loadedBalance);
    }
    else {
    		// ID 없음
    }
    ```
    
- 예제 1+
    
    ```csharp
    [System.Serializable]
    public class UserData
    {
        public string userId;
        public string password;
        public string name;
        public int balance;
    
        public UserData(string userId, string password, string name, int balance)
        {
            this.userId = userId;
            this.password = password;
            this.name = name;
            this.balance = balance;
        }
    
        // 객체의 데이터를 하나의 문자열로 변환
        public string Serialize()
        {
            return userId + "," + password + "," + name + "," + balance.ToString();
        }
    
        // 문자열에서 객체의 데이터를 복원
        public static UserData Deserialize(string data)
        {
            string[] parts = data.Split(',');
            return new UserData(parts[0], parts[1], parts[2], int.Parse(parts[3]));
        }
    }
    
    UserData userData = new UserData("user1234", "password123", "홍길동", 10000);
    string serializedData = userData.Serialize();
    PlayerPrefs.SetString(userData.userId, serializedData);
    PlayerPrefs.Save();
    
    string serializedData = PlayerPrefs.GetString("user1234");
    UserData loadedUserData = UserData.Deserialize(serializedData);
    
    Debug.Log("비밀번호: " + loadedUserData.password);
    Debug.Log("이름: " + loadedUserData.name);
    Debug.Log("잔액: " + loadedUserData.balance);
    ```
    
- 예제 2
    
    ```csharp
    public void changeScore(int value)
    {
        this.nowScore += value;
        
    		// 최고점수 갱신
        if (nowScore > highScore)
        {
            **highScore = nowScore;
            PlayerPrefs.SetInt("HighScore", highScore);
        }
        // 점수 UI에 반영
    		updateScore();
    }
    ```
    
- Playerprefs.Save()?
    
![[Pasted image 20240122204035.png]]

### 데이터 저장에 많이 쓰이는 메소드/프로퍼티들

1. Application.persistentDataPath
    
    [Unity - Scripting API: Application.persistentDataPath](https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html)
    
2. File.Exists
    
    [File.Exists(String) 메서드 (System.IO)](https://learn.microsoft.com/ko-kr/dotnet/api/system.io.file.exists?view=net-8.0)
    
3. File.ReadAllText
    
    [File.ReadAllText 메서드 (System.IO)](https://learn.microsoft.com/ko-kr/dotnet/api/system.io.file.readalltext?view=netframework-4.7.2)
    
4. File.WriteAllText
    
    [File.WriteAllText 메서드 (System.IO)](https://learn.microsoft.com/ko-kr/dotnet/api/system.io.file.writealltext?view=net-8.0)
    

## **CSV**

CSV(Comma-Separated Values)는 데이터를 저장하고 교환하는 데 사용되는 간단한 파일 형식입니다. 이 형식은 각 데이터 항목이 쉼표로 구분되며, **각 줄**이 **하나**의 **데이터 레코드**를 나타냅니다. CSV 파일은 엑셀이나 다른 표 계산 소프트웨어에서 쉽게 읽고 쓸 수 있으며, 프로그래밍에서도 널리 사용됩니다.

- 예제 1
    
    ```csharp
    [System.Serializable]
    public class Item
    {
        public int id;
        public string name;
        public int price;
        public string type;
    
        public Item(int id, string name, int price, string type)
        {
            this.id = id;
            this.name = name;
            this.price = price;
            this.type = type;
        }
    }
    ```
    
    ```csharp
    using System.Collections.Generic;
    using UnityEngine;
    
    public class CSVReader : MonoBehaviour
    {
        public TextAsset csvFile; // Unity Editor에서 할당
    
        void Start()
        {
    				csvFile = Resources.Load<TextAsset>("/File/myFile");
    
            List<Item> items = ReadCsv(csvFile.text);
            // 읽은 데이터 사용 예
            foreach (Item item in items)
            {
                Debug.Log($"아이템: {item.name}, 가격: {item.price}, 타입: {item.type}");
            }
        }
    
        List<Item> ReadCsv(string csvData)
        {
            List<Item> items = new List<Item>();
    
            string[] lines = csvData.Split('\\n');
            for (int i = 1; i < lines.Length; i++) // 헤더줄 제외!
            {
                if (lines[i].Trim() == "") continue;
    
                string[] fields = lines[i].Split(',');
                int id = int.Parse(fields[0]);
                string name = fields[1];
                int price = int.Parse(fields[2]);
                string type = fields[3];
    
                items.Add(new Item(id, name, price, type));
            }
    
            return items;
        }
    }
    ```
    

### JSON

JSON(JavaScript Object Notation)은 경량 데이터 교환 형식입니다. 유니티에서는 JSON을 사용하여 데이터를 저장하고 읽어올 수 있습니다. JSON은 사람과 기계 모두에게 읽기 쉽고 쓰기 쉬운 형식이며, 다양한 프로그래밍 언어에서 지원됩니다.

![[Pasted image 20240122204111.png]]

### 예제 1

```csharp
using UnityEngine;
using System.IO;

public class JsonDataManager : MonoBehaviour
{
    private string filePath;

    private void Awake()
    {
        filePath = Application.persistentDataPath + "/data.json";
    }

    public void SaveData(PlayerData data)
    {
        string jsonData = JsonUtility.ToJson(data, true);
        File.WriteAllText(filePath, jsonData);
    }

    public PlayerData LoadData()
    {
        if (File.Exists(filePath))
        {
            string jsonData = File.ReadAllText(filePath);
            return JsonUtility.FromJson<PlayerData>(jsonData);
        }
        else
        {
            Debug.LogError("Save file not found.");
            return null;
        }
    }
}

```

위 예제에서는 `JsonDataManager` 클래스를 사용하여 데이터를 JSON 형식으로 저장하고 로드하는 방법을 보여줍니다. `SaveData` 함수는 `PlayerData` 객체를 JSON 문자열로 변환하여 파일에 저장하고, `LoadData` 함수는 파일에서 JSON 문자열을 읽어와 `PlayerData` 객체로 변환하여 반환합니다.

### 예제 2

```csharp
using UnityEngine;

[System.Serializable]
public class PlayerData
{
    public string playerName;
    public int playerLevel;
    public float playerHealth;
}

public class Player : MonoBehaviour
{
    public PlayerData playerData;

    private void Start()
    {
        playerData = new PlayerData();
        playerData.playerName = "John";
        playerData.playerLevel = 10;
        playerData.playerHealth = 100.0f;

        SavePlayerData();
        LoadPlayerData();
    }

    private void SavePlayerData()
    {
        string jsonData = JsonUtility.ToJson(playerData);
        PlayerPrefs.SetString("PlayerData", jsonData);
        PlayerPrefs.Save();
    }

    private void LoadPlayerData()
    {
        if (PlayerPrefs.HasKey("PlayerData"))
        {
            string jsonData = PlayerPrefs.GetString("PlayerData");
            playerData = JsonUtility.FromJson<PlayerData>(jsonData);

            Debug.Log("Player Name: " + playerData.playerName);
            Debug.Log("Player Level: " + playerData.playerLevel);
            Debug.Log("Player Health: " + playerData.playerHealth);
        }
    }
}

```

위 예제에서는 `Player` 클래스를 사용하여 `PlayerData` 객체를 JSON 형식으로 저장하고 로드하는 방법을 보여줍니다. `Start` 함수에서는 `PlayerData` 객체를 생성하고 초기값을 설정한 후, `SavePlayerData` 함수를 호출하여 데이터를 저장하고 `LoadPlayerData` 함수를 호출하여 데이터를 로드합니다. 로드한 데이터는 `playerData` 변수에 저장되며, 필요에 따라 사용할 수 있습니다.

JSON을 사용하여 유니티에서 데이터를 저장하고 로드하는 것은 간편하고 효율적인 방법입니다. JSON 형식은 다양한 데이터 유형을 지원하며, 데이터를 읽고 쓰기 쉽게 처리할 수 있습니다. 이를 통해 게임 내에서 플레이어 정보, 게임 설정, 진행 상태 등을 관리할 수 있습니다.

### Scriptable Object

Scriptable Object은 유니티 엔진에서 사용되는 데이터 컨테이너입니다. 이를 통해 게임 오브젝트나 씬에 종속되지 않고 데이터를 저장하고 공유할 수 있습니다. Scriptable Object는 주로 게임의 리소스, 설정, 상태 등을 관리하는 데 사용됩니다.

![[Pasted image 20240122204130.png]]

![[Pasted image 20240122204143.png]]

사용법 - ScriptableObject 상속

![[Pasted image 20240122204153.png]]

- 예제 1
    
    ```csharp
    using UnityEngine;
    
    [CreateAssetMenu(fileName = "Data", menuName = "ScriptableObjects/SpawnManagerScriptableObject", order = 1)]
    public class SpawnManagerScriptableObject : ScriptableObject
    {
        public string prefabName;
    
        public int numberOfPrefabsToCreate;
        public Vector3[] spawnPoints;
    }
    ```
    
    ```csharp
    using UnityEngine;
    
    public class Spawner : MonoBehaviour
    {
        // The GameObject to instantiate.
        public GameObject entityToSpawn;
    
        // An instance of the ScriptableObject defined above.
        public SpawnManagerScriptableObject spawnManagerValues;
    
        // This will be appended to the name of the created entities and increment when each is created.
        int instanceNumber = 1;
    
        void Start()
        {
            SpawnEntities();
        }
    
        void SpawnEntities()
        {
            int currentSpawnPointIndex = 0;
    
            for (int i = 0; i < spawnManagerValues.numberOfPrefabsToCreate; i++)
            {
                // Creates an instance of the prefab at the current spawn point.
                GameObject currentEntity = Instantiate(entityToSpawn, spawnManagerValues.spawnPoints[currentSpawnPointIndex], Quaternion.identity);
    
                // Sets the name of the instantiated entity to be the string defined in the ScriptableObject and then appends it with a unique number. 
                currentEntity.name = spawnManagerValues.prefabName + instanceNumber;
    
                // Moves to the next spawn point index. If it goes out of range, it wraps back to the start.
                currentSpawnPointIndex = (currentSpawnPointIndex + 1) % spawnManagerValues.spawnPoints.Length;
    
                instanceNumber++;
            }
        }
    }
    ```
    
- 예제 2
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/83c75a39-3aba-4ba4-a792-7aefe4b07895/d471c61f-61d4-4120-abeb-44b42973fe8c/Untitled.png)
    
    ```csharp
    using UnityEngine;
    
    [CreateAssetMenu(fileName = "CharacterBaseStatsData", menuName = "ScriptableObjects/CharacterBaseStatsData", order = 1)]
    public class CharacterBaseStatsData : ScriptableObject
    {
        public int Hp;
        public int Defence;
        public int Damage;
        public int AttackSpeed;
        public int MoveSpeed;
    }
    ```
    

### Binary Formatter

**Binary Formatter**

Binary Formatter는 유니티에서 사용되는 직렬화 도구입니다. 이를 통해 객체를 이진 형식으로 직렬화하고, 이진 형식을 다시 객체로 역직렬화할 수 있습니다. Binary Formatter는 주로 파일 저장 및 로드에 사용되며, 데이터를 보다 효율적으로 관리하고 공유할 수 있습니다.

예를 들어, 게임에서 플레이어의 상태를 저장하고 로드해야 할 때 Binary Formatter를 사용할 수 있습니다. 플레이어의 정보를 객체로 표현하고, 이를 이진 형식으로 직렬화하여 파일에 저장합니다. 필요할 때마다 파일에서 이진 형식을 읽어와 역직렬화하여 플레이어의 정보를 복원합니다.

Binary Formatter를 사용하기 위해서는 직렬화할 클래스에 `[Serializable]` 속성을 추가해야 합니다. 또한, `FileStream`과 같은 파일 처리 클래스를 사용하여 파일을 생성하고 열어서 Binary Formatter를 이용해 데이터를 읽고 쓸 수 있습니다.

- 예제
    
    ```csharp
    using UnityEngine;
    using System.IO;
    using System.Runtime.Serialization.Formatters.Binary;
    
    [System.Serializable]
    public class PlayerData
    {
        public string playerName;
        public int playerLevel;
        public float playerHealth;
    }
    
    public class SaveLoadManager : MonoBehaviour
    {
        public PlayerData playerData;
    
        private string saveFilePath;
    
        private void Awake()
        {
            saveFilePath = Application.persistentDataPath + "/playerData.dat";
        }
    
        public void SavePlayerData()
        {
            BinaryFormatter binaryFormatter = new BinaryFormatter();
            FileStream fileStream = File.Create(saveFilePath);
    
            binaryFormatter.Serialize(fileStream, playerData);
            fileStream.Close();
        }
    
        public void LoadPlayerData()
        {
            if (File.Exists(saveFilePath))
            {
                BinaryFormatter binaryFormatter = new BinaryFormatter();
                FileStream fileStream = File.Open(saveFilePath, FileMode.Open);
    
                playerData = (PlayerData)binaryFormatter.Deserialize(fileStream);
                fileStream.Close();
            }
            else
            {
                Debug.Log("Save file not found.");
            }
        }
    }
    
    ```
    
    위 코드에서 `PlayerData` 클래스는 직렬화를 위해 `[Serializable]` 속성이 추가되었습니다. `SaveLoadManager` 클래스는 `playerData`를 이진 형식으로 직렬화하여 파일에 저장하고, 필요할 때 파일에서 읽어와 역직렬화하여 `playerData`를 복원합니다.
    
    Binary Formatter를 사용하면 유니티에서 데이터를 파일에 저장하고 로드하는 기능을 구현할 수 있습니다. 이를 통해 게임의 진행 상태, 플레이어 정보, 게임 설정 등을 보다 효율적으로 관리할 수 있습니다.
    

### 정리

파일을 로컬(디바이스)에 저장하는 것은 항상 문제.

![[Pasted image 20240122204211.png]]

[How to Hack il2cpp Games - MelonLoader Tutorial](https://www.youtube.com/watch?v=XH4lePNqiHc)