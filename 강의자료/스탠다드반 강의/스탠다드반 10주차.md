# 240102

## 1. ì½”ë“œì¹´íƒ€ ë¬¸ì œí’€ì´

ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ ì ‘ê·¼ë°©ì‹

- ì œí•œì‚¬í•­ ê¼¼ê¼¼íˆ ë³´ê¸°
- ì…ì¶œë ¥ ì˜ˆì‹œ ê¼­ ë³´ê¸° (ë‡Œí”¼ì…œ ê¸ˆì§€)
- ë‚´ê°€ ê°€ì§€ê³  ìˆëŠ” ë¬´ê¸° í™•ì¸í•´ë³´ê¸° (ìë£Œêµ¬ì¡°, ì•Œê³ ë¦¬ì¦˜ ì§€ì‹, ê³¼ê±° ë¬¸ì œ í’€ì´ ê²½í—˜ ë“±ë“±)

ë¬¸ì œ í•´ì„¤

- [142] í•˜ë…¸ì´íƒ‘
    
    ```csharp
    using System;
    using System.Collections.Generic;
    
    public class Solution {
        public List<int[]> Move(int where, int to, int pass, int num) {
            List<int[]> result = new List<int[]>();
    
            if (num == 1) {
                result.Add(new int[] { where, to });
                return result;
            }
    
            result.AddRange(Move(where, pass, to, num - 1));
            result.Add(new int[] { where, to });
            result.AddRange(Move(pass, to, where, num - 1));
    
            return result;
        }
    
        public int[,] solution(int n) {
            List<int[]> resultList = Move(1, 3, 2, n);
            int rowCount = resultList.Count;
            int[,] array = new int[rowCount, 2];
    
            for (int i = 0; i < rowCount; i++) {
                array[i, 0] = resultList[i][0];
                array[i, 1] = resultList[i][1];
            }
    
            return array;
        }
    }
    ```
    
- [143] ë¯¸ë¡œíƒˆì¶œ
    
    ```csharp
    using System;
    using System.Collections.Generic;
    
    public class Solution {
        public int solution(string[] maps) {
            
            return FindShortestPath(maps);
        }
    
        public char[,] ConvertTo2DArray(string[] input) {
            int rows = input.Length;
            int cols = (rows > 0) ? input[0].Length : 0;
            char[,] result = new char[rows, cols];
    
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    result[i, j] = input[i][j];
                }
            }
    
            return result;
        }
    
        private int BFS(char[,] grid, Tuple<int, int> start, Tuple<int, int> end, char[] validChars) {
            int rows = grid.GetLength(0);
            int cols = grid.GetLength(1);
            bool[,] visited = new bool[rows, cols];
            // Tuple contains row, col, and distance
            Queue<Tuple<int, int, int>> queue = new Queue<Tuple<int, int, int>>(); 
    
            queue.Enqueue(new Tuple<int, int, int>(start.Item1, start.Item2, 0));
            visited[start.Item1, start.Item2] = true;
    
            int[] dr = new int[] { -1, 1, 0, 0 };
            int[] dc = new int[] { 0, 0, -1, 1 };
    
            while (queue.Count > 0) {
                var current = queue.Dequeue();
                int row = current.Item1, col = current.Item2, distance = current.Item3;
    
                if (row == end.Item1 && col == end.Item2) {
                    return distance;
                }
    
                for (int i = 0; i < 4; i++) {
                    int newRow = row + dr[i];
                    int newCol = col + dc[i];
    
                    if (IsValidMove(newRow, newCol, rows, cols, grid, visited, validChars)) {
                        queue.Enqueue(new Tuple<int, int, int>(newRow, newCol, distance + 1));
                        visited[newRow, newCol] = true;
                    }
                }
            }
    
            return -1; // No path found
        }
        
            private bool IsValidMove(int newRow, int newCol, int rows, int cols, char[,] grid, bool[,] visited, char[] validChars) {
            // Check if the new position is within the grid boundaries
            bool isInBounds = newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols;
            // Check if the position has not been visited and is a valid character
            bool isValidPosition = isInBounds && !visited[newRow, newCol] && Array.IndexOf(validChars, grid[newRow, newCol]) >= 0;
    
            return isValidPosition;
        }
    
        public int FindShortestPath(string[] input) {
            var grid = ConvertTo2DArray(input);
            Tuple<int, int> start = null, endL = null, endE = null;
    
            // Find positions of S, L, and E
            for (int i = 0; i < grid.GetLength(0); i++) {
                for (int j = 0; j < grid.GetLength(1); j++) {
                    if (grid[i, j] == 'S') start = Tuple.Create(i, j);
                    else if (grid[i, j] == 'L') endL = Tuple.Create(i, j);
                    else if (grid[i, j] == 'E') endE = Tuple.Create(i, j);
                }
            }
    
            // S-> Lê°ˆ ë•Œ O, L, Eë§Œ ë°Ÿì„ ìˆ˜ ìˆê³ , 
            int distanceSL = BFS(grid, start, endL, new char[] { 'O', 'L', 'E' });
            int distanceLE = BFS(grid, endL, endE, new char[] { 'O', 'S', 'E' });
    
            if (distanceSL == -1 || distanceLE == -1) return -1; // No path found
    
            return distanceSL + distanceLE;
        }
    }
    ```
    

## 2. ë””ìì¸ íŒ¨í„´

### (2) ë”í‹°í”Œë˜ê·¸ íŒ¨í„´

(ì‚¬ì‹¤ ë”í‹°í”Œë˜ê·¸ íŒ¨í„´ì„ ì •ë§ ë””ìì¸ íŒ¨í„´ì˜ í•˜ë‚˜ë¡œ í¬í•¨í•˜ì§€ ì•ŠëŠ” ì˜ê²¬ë„ ë§ì§€ë§Œ, ê½¤ ìœ ìš©í•œ ë°©ë²• ì¤‘ í•˜ë‚˜ì´ê³  ê³ ë¯¼í•´ë³¼ ë§Œí•œ ì£¼ì œë¼ê³  ìƒê°í•´ì„œ ê°€ì ¸ì˜¤ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤ ğŸ˜Š)

ë”í‹°í”Œë˜ê·¸ íŒ¨í„´ì€ **ì¤‘ë³µì ì¸ ì—°ì‚°ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ê¸° ìœ„í•œ** ë””ìì¸ íŒ¨í„´ì…ë‹ˆë‹¤. ì´ íŒ¨í„´ì€ í•œ ë²ˆì— ì—°ì‚°í•˜ê±°ë‚˜ **ê°’ì„ í˜¸ì¶œí•˜ê¸° ì „ê¹Œì§€ í•´ë‹¹ ì—°ì‚°ì„ ìˆ˜í–‰í•˜ì§€ ì•ŠëŠ” ë°©ì‹**ìœ¼ë¡œ ì‘ë™í•©ë‹ˆë‹¤.

ì¥ì :

- ì¤‘ë³µì ì¸ ì—°ì‚°ì„ í¬ê²Œ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ê³ ë ¤ì‚¬í•­:

- ì´ì „ ê°’ì„ ì €ì¥í•´ì•¼ í•©ë‹ˆë‹¤.
- ë³€ê²½ì´ ìˆëŠ”ì§€ ê³„ì† ì²´í¬í•´ì•¼ í•©ë‹ˆë‹¤.

Transform. Translate â†’ ì´ë™ì— íšŒì „ì„ ì ìš©í•˜ëŠ” ì—°ì‚°ì„ í•œë‹¤ìŒì— ì´ë™

Transform.Rotate â†’ ì§€ê¸ˆ ì–´ë–¤ íšŒì „ì´ ê±¸ë ¤ìˆê³  ê·¸ê±°ì— ëŒ€í•´ì„œ í–‰ë ¬ì—°ì‚°

- ì˜ˆì‹œ : íŠ¸ëœìŠ¤í¼ ì—…ë°ì´íŠ¸
    
    íŠ¸ëœìŠ¤í¼ì˜ ìì‹ë“¤ì€ ë¶€ëª¨ì˜ ì´ë™ì— ì˜í•´ ì˜í–¥ì„ ë°›ìŒ.
    
    ![[Pasted image 20240122212714.png]]
    
![[Pasted image 20240122212721.png]]
    
- ìœ ì‚¬ ì˜ˆì‹œ - LINQ Lazy Evaluation
    
    ```csharp
    static Func<int, bool> func; //intë¥¼ ì¸ìë¡œ ë°›ì•„ boolì„ ë°˜í™˜í•˜ëŠ” Func
    
    static void Main(string[] args)
    {
     	List<int> list = new List<int> { 1, 2, 3, 4, 5, 6, 7 };
      	func = (x) =>
                {
                 Console.WriteLine("Func Executed");
                 return x % 2 == 0; 
                };
    
    	Console.WriteLine("==Where==");
    	IEnumerable<int> whereList = list.Where(func).ToArray(); // ToArrayë„£ìœ¼ë©´ ìµœì¢…ê²°ê³¼ë¡œ ì¸ì‹
    
    	Console.WriteLine("==Foreach==");
    	foreach(int i in whereList)
        {
        	Console.WriteLine(i);
        }
    }
    /////////////////////////
    .ToArray() // ê²°ê³¼í™”í•´ë²„ë¦¬ë©´ ê·¸ëƒ¥ ëì„
    
    ==Where==
    ==Foreach==
    Func Executed
    Func Excuted
    2
    Func Excuted
    Func Excuted
    4
    
    ==Where==
    Func Excuted
    ~~ X7
    ==Foreach==
    2
    4
    6
    8
    
    ```
    

### (3) ìƒíƒœ íŒ¨í„´

### ìœ í•œìƒíƒœê¸°ê³„(FSM)

![[Pasted image 20240122212733.png]]

ìœ í•œ ìƒíƒœ ê¸°ê³„(Finite State Machine, FSM)ì€ ê°ì²´ì˜ ë™ì‘ì´ ë‚´ë¶€ ìƒíƒœì— ë”°ë¼ ë‹¬ë¼ì§€ëŠ” ìƒí™©ì—ì„œ ì‚¬ìš©ë˜ëŠ” ê°œë…ì…ë‹ˆë‹¤. ì´ëŸ¬í•œ ìƒí™©ì—ì„œ ìƒíƒœ íŒ¨í„´(State Pattern)ì€ ìœ ìš©í•˜ê²Œ í™œìš©ë©ë‹ˆë‹¤. ìƒíƒœ íŒ¨í„´ì€ **ê°ì²´ì˜ ìƒíƒœë¥¼ í´ë˜ìŠ¤ë¡œ ì¶”ìƒí™”í•˜ê³ **, ê° ìƒíƒœë§ˆë‹¤ í•´ë‹¹ ìƒíƒœì—ì„œì˜ ë™ì‘ì„ ì •ì˜í•©ë‹ˆë‹¤. ê°ì²´ëŠ” í˜„ì¬ ìƒíƒœì— ë”°ë¼ **ë™ì‘ì„ ìˆ˜í–‰**í•˜ë©°, **ìƒíƒœ ì „í™˜**ì„ í†µí•´ ë‹¤ë¥¸ ë™ì‘ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, í”Œë ˆì´ì–´ì˜ ìƒíƒœë¥¼ ê´€ë¦¬í•˜ëŠ” ê²½ìš°ë¥¼ ìƒê°í•´ë³´ê² ìŠµë‹ˆë‹¤. í”Œë ˆì´ì–´ëŠ” ì—¬ëŸ¬ ê°€ì§€ ìƒíƒœë¥¼ ê°€ì§ˆ ìˆ˜ ìˆìœ¼ë©°, ê° ìƒíƒœì—ì„œëŠ” íŠ¹ì • ë™ì‘ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤. ìƒíƒœ íŒ¨í„´ì„ ì‚¬ìš©í•˜ë©´ í”Œë ˆì´ì–´ì˜ ìƒíƒœ ê´€ë¦¬ê°€ ê°„í¸í•´ì§€ê³ , ìƒˆë¡œìš´ ìƒíƒœë¥¼ ì¶”ê°€í•˜ê±°ë‚˜ ê¸°ì¡´ ìƒíƒœë¥¼ ë³€ê²½í•˜ëŠ” ê²ƒë„ ì‰¬ì›Œì§‘ë‹ˆë‹¤. ë˜í•œ, ê° ìƒíƒœì˜ ë™ì‘ì„ ë¶„ë¦¬í•˜ì—¬ ìœ ì§€ë³´ìˆ˜ì„±ì„ ë†’ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

- ì˜ˆì‹œ - í”Œë ˆì´ì–´ ìƒíƒœê´€ë¦¬
```csharp
// í”Œë ˆì´ì–´ ìƒíƒœ ì¸í„°í˜ì´ìŠ¤
public interface IPlayerState
{
    void EnterState(Player player);
    void ExitState(Player player);
    void UpdateState(Player player);
}

// ì •ì§€ ìƒíƒœ í´ë˜ìŠ¤
public class IdleState : IPlayerState
{
    public void EnterState(Player player)
    {
        player.AnimateIdle();
    }

    public void ExitState(Player player) { }

    public void UpdateState(Player player)
    {
        if (player.IsMoving)
        {
            player.ChangeState(new MoveState());
        }
    }
}

// ì´ë™ ìƒíƒœ í´ë˜ìŠ¤
public class MoveState : IPlayerState
{
    public void EnterState(Player player)
    {
        player.AnimateMove();
    }

    public void ExitState(Player player) { }

    public void UpdateState(Player player)
    {
        if (!player.IsMoving)
        {
            player.ChangeState(new IdleState());
        }
    }
}

// í”Œë ˆì´ì–´ í´ë˜ìŠ¤
public class Player
{
    private IPlayerState currentState;

    public bool IsMoving { get; set; }

    public Player()
    {
        currentState = new IdleState();
    }

    public void ChangeState(IPlayerState newState)
    {
        currentState.ExitState(this);
        currentState = newState;
        currentState.EnterState(this);
    }

    public void Update()
    {
        currentState.UpdateState(this);
    }

    public void AnimateIdle()
    {
        // ì •ì§€ ìƒíƒœ ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ
    }

    public void AnimateMove()
    {
        // ì´ë™ ìƒíƒœ ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ
    }
}
	
```