## 클래스, 구조체, 제네릭, 인터페이스 복습

#### 값타입과 참조타입

Vector2는 왜 미묘하게 색이 다른걸까 생각해보신 적 있으신가요?

![[Pasted image 20240115000242.png]]

#### C#의 값타입과 참조타입
C#에서는 값타입과 참조타입 두 가지 타입을 지원합니다.

- **값타입(Value Type)**: int, float, double, bool 등의 기본 데이터 타입들이 값타입에 해당합니다. 값타입은 변수에 직접 값을 저장하며, **변수 간의 대입 시 값이 복사**됩니다. 값타입 변수가 다른 변수에 할당되거나 전달될 때는 값이 복사되므로 독립적으로 동작합니다.
- **참조타입(Reference Type)**: 클래스, 인터페이스 등이 참조타입에 해당합니다. 참조타입은 변수에는 실제 값 대신 **객체에 대한 참조(메모리 주소)가 저장**됩니다. 참조타입 변수가 다른 변수에 할당되거나 전달될 때는 참조(메모리 주소)가 복사되므로 동일한 객체를 참조하게 됩니다.
	-  
![[Pasted image 20240115000413.png]]
![[Pasted image 20240115000420.png]]
#### 클래스 : 객체지향 프로그래밍에서 데이터와 메소드를 정의하는 일종의 틀

#### (1) 다양한 데이터를 저장하는 복합자료형

다양한 데이터를 저장할 수 있는 복합자료형

클래스가 가질 수 있는 멤버들 : 메소드, 필드, 프로퍼티(속성)

#### (2) 데이터를 참조형식으로 저장함

얕은 복사 : 내부의 값이 아닌 참조만 복사함으로서 발생하는 문제

해결 : 값 타입이 나올때까지 찾아서 계속 복사해줘야 함

의문 : string은 값 타입도 아닌데.. 문제가 없다?

#### 결론 : 값형식(구조체 포함) 혹은 String은 문제가 없음 / 나머지는 복사시에 굉장히 유의해야함


	![[Pasted image 20240115000430.png]]

사례 1
```csharp
public class Player
{
    public int health;

    public Player(int initialHealth)
    {
        health = initialHealth;
    }
}

public class Example
{
    void Start()
    {
        Player originalPlayer = new Player(100);
        Player copiedPlayer = originalPlayer;

        copiedPlayer.health = 50;

        // 이 시점에서 originalPlayer의 health도 50으로 변경되어 있음
        Debug.Log(originalPlayer.health);  // 출력: 50
    }
}
```

사례 2
```csharp
using System;
using System.Collections.Generic;

public class HelloWorld
{
    public static void Main(string[] args)
    {
        Player originalPlayer = new Player();
        Player copiedPlayer = new Player();
        copiedPlayer.HP = originalPlayer.HP;
        copiedPlayer.inventory = new List<MyClass>();
				for(int i =0; i < originalPlayer.inventory.Count; i++){
						copitedPlayer.inventory.Add(originalPlayer.inventory[i]);
				}
        
        // copiedPlayer의 인벤토리에 'Potion' 추가
        copiedPlayer.inventory.Add("Potion");

        // originalPlayer의 인벤토리에도 'Potion'이 추가된 것을 볼 수 있음
        foreach (string item in originalPlayer.inventory)
        {
            Console.WriteLine(item); // 출력: Sword, Shield, Potion
        }
    }
}


public class Player : IClonable
{
    public List<string> inventory = new List<string>();
    public int HP = 100;
    
		public Player(int Hp, List<string> prev_inventory){
				HP = Hp;
				inventory = prev_inventory;
		}

    public Player()
    {
        inventory.Add("Sword");
        inventory.Add("Shield");
    }

		public Player Clone(){
			 
		}
}
```

#### (3) 클래스는 상속이 가능하다

클래스는 부모(base)클래스로부터 공통적 부분을 상속하여 새로운 파생 클래스를 만들 수 있습니다. 상속을 사용하면 base 클래스의 데이터와 메서드를 파생클래스에서 사용합니다.

상속은 주로 “is a” 관계를 맺고 있습니다. ItemManager is a Manager / Monster is a Damagable / Zealot is a GroundUnit

상속의 의의 : 중복된 코드 줄일 수 있음, 다형성을 통해 일관된 형식(인터페이스)을 공유할 수 있음

상속의 문법 : 콜론을 찍어서 Base 클래스를 명시

```csharp
// 베이스 클래스
public class Animal
{
   public string Name { get; set; }
   public int Age { get; set; }
}

// 파생클래스
public class Dog : Animal
{       
   public void HowOld() 
   {
      // 베이스 클래스의 Age 속성 사용
      Console.WriteLine("나이: {0}", this.Age);
   }
}

public class Bird : Animal
{       
   public void Fly()
   {
      Console.WriteLine("{0}가 날다", this.Name);
   }
}
```


#### 상속 FAQ

1) 실제로 Animal 클래스로 객체가 만들어지는 경우를 막고 싶어요 → 추상클래스
```csharp
public abstract class Animal // 실제 구현을 강제함 --> interface 비슷
{
    public abstract void Speak();
}

public class Dog : Animal
{
	 // Dog는 무조건 speak을 구현해야함 : 이유는 abstract함수여서
    public override void Speak()
    {
        Debug.Log("Bark");
    }
}
```


2) 날 수 있다는 특성(flyable)도 상속받도록 하고 싶어요 → 인터페이스
```csharp
public interface IFlyable
{
    void Fly();
}

public class Bird : Animal, IFlyable
{
    public override void Speak()
    {
        Debug.Log("Chirp");
    }

    public void Fly()
    {
        Debug.Log("Bird is flying");
    }
}
```
​

3) 부모 클래스에서는 A처럼 작동했지만 자식 클래스에서는 A’처럼 행동하고 싶어요 → virtual / override
```csharp
public class Animal
{
    public virtual void Speak() // 실제 구현을 강제하지 않음. 그냥 기본 구현(default값)
    {
        Debug.Log("Animal sound");
    }
}

public class Cat : Animal
{
    public override void Speak()
    {
        Debug.Log("Meow");
    }
}

public class Dog : Animal // Speak를 했을 때 오류 안남 왜냐면 기본 구현이 있기 때문
{
	
}

```
​

4) 여러 자식 클래스들이 섞여들어있는 컬렉션에서 특정 클래스인지 확인하고 싶어요 → is/as
```csharp
public void CheckAnimalType(Animal animal)
{
    if (animal is Dog)
    {
        Dog dog = animal as Dog;
        dog.Speak();  // Bark
    }
    else if (animal is Cat)
    {
        Cat cat = (Cat)animal;
        cat.Speak();  // Meow
    }
}
```

​

5) 부모 클래스의 일부 멤버를 자식 클래스에 전달하고 싶지 않아요 → private```
```csharp
public class Animal
{
    private int age;

    public void SetAge(int age)
    {
        this.age = age;
    }
}

public class Dog : Animal
{
    public void PrintAge()
    {
        // age 접근 불가능. 컴파일 오류 발생
        // Debug.Log(age);
    }
}
```

6) 부모 클래스의 일부 멤버를 외부 클래스에는 노출하고 싶지 않지만 자식 클래스에게는 전달하고 싶어요 → protected
```csharp
public class Animal
{
    protected int age;

    public void SetAge(int age)
    {
        this.age = age;
    }
}

public class Dog : Animal
{
    public void PrintAge()
    {
        Debug.Log(age);  // 접근 가능
    }
}
```

​

#### 클래스 VS 구조체

|   |   |   |
|---|---|---|
|특징|클래스|구조체|
|키워드|class|struct|
|형식|참조타입|값 타입|
|복사|얕은 복사|깊은 복사|
|인스턴스 생성|new 연산자|선언만으로 생성|
|상속|가능|불가능 인터페이스는 됨|

#### [더 배우기] is a 관계가 말이 되지만 문제가 되는 상황들

![👉](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

리스코프 치환 원칙 (Liskov Substitution Principle)

리스코프 치환 원칙은 객체 지향 프로그래밍에서 상속과 다형성을 이용할 때 지켜야 할 원칙 중 하나입니다. 리스코프 치환 원칙은 다음과 같이 정의됩니다.

"프로그램의 객체들은 그것들의 서브타입(subtype) 객체로 대체될 수 있어야 한다."

즉, 어떤 클래스가 상속 관계에 있을 때, 부모 클래스의 인스턴스 대신에 자식 클래스의 인스턴스를 사용해도 프로그램의 의미나 동작에 아무런 영향이 없어야 합니다.

하지만 때로는 상속을 받은 것처럼 보이지만 실제로는 리스코프 치환 원칙을 위배하면서 문제가 발생할 수 있습니다.

예시 1
```csharp
public class Rectangle
{
    public virtual int Width { get; set; }
    public virtual int Height { get; set; }

    public int Area()
    {
        return Width * Height;
    }
}

public class Square : Rectangle
{
    public override int Width
    {
        get { return base.Width; }
        set
        {
            base.Width = value;
            base.Height = value;
        }
    }

    public override int Height
    {
        get { return base.Height; }
        set
        {
            base.Width = value;
            base.Height = value;
        }
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        Rectangle rectangle = new Square();
        rectangle.Width = 5;
        rectangle.Height = 10;

        Console.WriteLine(rectangle.Area());  // 출력: 100
    }
}

```

예시 2
```csharp
public abstract class Animal
{
    public abstract void MakeSound();
}

public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Bark");
    }
}

public class Cat : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Meow");
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        Animal animal = GetRandomAnimal();
        animal.MakeSound();
    }

    public static Animal GetRandomAnimal()
    {
        Random random = new Random();
        int randomNumber = random.Next(1, 3);

        if (randomNumber == 1)
        {
            return new Dog();
        }
        else
        {
            return new Cat();
        }
    }
}

```

예시 3
```csharp
public class Bird
{
    public virtual void Fly()
    {
        Console.WriteLine("The bird is flying");
    }
}

public class Penguin : Bird
{
    public override void Fly()
    {
        throw new NotImplementedException();
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        Bird bird = new Penguin();
        bird.Fly();
    }
}

```

리스코프 치환 원칙을 위배하면 예상치 못한 동작이나 예외가 발생할 수 있습니다. 예를 들어, 부모 클래스의 메서드를 오버라이딩하여 자식 클래스에서 다른 동작을 수행하는 경우, 이는 리스코프 치환 원칙을 위배합니다. 이로 인해 코드의 가독성이 떨어지고, 예상치 못한 결과가 발생할 수 있습니다.

또한, 자식 클래스가 부모 클래스의 일부 멤버를 숨기지 않고 노출하거나 변경하는 경우도 리스코프 치환 원칙을 위배할 수 있습니다. 이는 다형성을 사용하는 클라이언트 코드에서 예외를 발생시킬 수 있습니다. 클라이언트 코드가 부모 클래스의 인스턴스를 사용하는 것이 예상되는 상황에서 자식 클래스의 인스턴스를 사용하면 예상치 못한 동작이 발생할 수 있습니다.

따라서, 리스코프 치환 원칙을 지키지 않는다면 코드의 예측 가능성과 유지 보수성이 떨어지며, 오류 발생 가능성이 증가할 수 있습니다.
