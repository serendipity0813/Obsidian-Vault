
### 명령 패턴

명령 패턴은 한마디로 **메소드를 객체처럼 만드는 것**이라고 생각하면 편합니다. 이런 패턴을 안쓰면 우리는 그저 아래와 같이 작성하겠지만,

```csharp
if(Input.GetKey(KeyCode.LeftArrow)){
	GoLeft();
}

void GoLeft(){
	Debug.Log("Left Turn!");
}
```

명령패턴을 활용하면 아래와 같이 바꿀 수 있습니다.

```csharp
public abstract class Command {
	public abstract void Execute();
}

public class LeftCommand : Command {
	public override void Execute(){
		Debug.Log("Left Turn!");
	}
}

/// Another Class 
LeftCommand leftCommand = new LeftCommand();

if(Input.GetKey(KeyCode.LeftArrow)){
	leftCommand.Execute();
}
```

위와 같은 방식이 훨씬 더 복잡해보일 수 있지만, 유지보수성을 강화해주는 데에는 좋은 방식의 코드 작업 방식이라고 생각할 수 있습니다. 레이싱 게임 작업 중 한 명은 대시 작업, 한 명은 점프 작업을 한다고 생각해봅시다. 작업을 나눠서 하기 때문에 훨씬 더 확장성이 높아지겠죠?

- 예시 1 - 리플레이 시스템 전제사항 : 결정론적(deterministic) 게임 결과 부스터 썼을 때 속도가 랜덤으로 0 ~ 10KM/H 빨라진다 이런거 없음 프레임 시간에 대한 보정 있어야함(fixedupdate위주, approximate 고려) transform.Translate(Vector3.right * Time.deltaTime);
    
    → 멀티플레이 게임!
    
    Command
    
    ```csharp
    namespace Chapter.Command
    {
        public abstract class Command
        {
            public abstract void Execute();
        }
    }
    
    namespace Chapter.Command
    {
        public class ToggleTurbo : Command
        {
            private BikeController _controller;
    
            public ToggleTurbo(BikeController controller)
            {
                _controller = controller;
            }
    
            public override void Execute()
            {
                _controller.ToggleTurbo();
            }
        }
    }
    ```
    
    Controller
    
    ```csharp
    using UnityEngine;
    
    namespace Chapter.Command
    {
        public class BikeController : MonoBehaviour
        {
            public enum Direction
            {
                Left = -1,
                Right = 1
            }
    
            private bool _isTurboOn;
            private float _distance = 1.0f;
        
            public void ToggleTurbo()
            {
                _isTurboOn = !_isTurboOn;
            }
        
            public void Turn(Direction direction)
            {
                if (direction == Direction.Left) 
                    transform.Translate(Vector3.left * _distance);
            
                if (direction == Direction.Right)
                    transform.Translate(Vector3.right * _distance);
            }
    
            public void ResetPosition()
            {
                transform.position = new Vector3(0.0f, 0.0f, 0.0f);
            }
        }
    }
    ```
    
    Invoker
    
    ```csharp
    using UnityEngine;
    using System.Linq;
    using System.Collections.Generic;
    
    namespace Chapter.Command
    {
        class Invoker : MonoBehaviour
        {
            private bool _isRecording;
            private bool _isReplaying;
            private float _replayTime;
            private float _recordingTime;
            private SortedList<float, Command> _recordedCommands = 
                new SortedList<float, Command>();
    
            public void ExecuteCommand(Command command)
            {
                command.Execute();
                
                if (_isRecording) 
                    _recordedCommands.Add(_recordingTime, command);
                
                Debug.Log("Recorded Time: " + _recordingTime);
                Debug.Log("Recorded Command: " + command);
            }
    
            public void Record()
            {
                _recordingTime = 0.0f;
                _isRecording = true;
            }
    
            public void Replay()
            {
                _replayTime = 0.0f;
                _isReplaying = true;
                
                if (_recordedCommands.Count <= 0)
                    Debug.LogError("No commands to replay!");
                
                _recordedCommands.Reverse();
            }
            
            void FixedUpdate()
            {
                if (_isRecording) 
                    _recordingTime += Time.fixedDeltaTime;
                
                if (_isReplaying)
                {
                    _replayTime += Time.fixedDeltaTime;
    
                    if (_recordedCommands.Any()) 
                    {
                        if (Mathf.Approximately(
                            _replayTime, _recordedCommands.Keys[0])) {
    
                            Debug.Log("Replay Time: " + _replayTime);
                            Debug.Log("Replay Command: " + 
                                      _recordedCommands.Values[0]);
                            
                            _recordedCommands.Values[0].Execute();
                            _recordedCommands.RemoveAt(0);
                        }
                    }
                    else
                    {
                        _isReplaying = false;
                    }
                }
            }
        }
    }
    ```
    

