## Event Bus
---


동시에 플레이하는 게임에서 누가 중지를 했다고 생각해봅시다. 잠깐 핑이 길어지거나 이런 것을 용인하는 게임들이 ~~옛날에는~~ 있었습니다.
    
이때 공정한 게임을 위해서 모두가 중단되어야 한다고 생각해봅시다. 이런 이벤트는 발행자와 구독자가 따로 있는 개념이라기보다는 모두 다 같이 가능할 것입니다.
    
   ![[Pasted image 20240122212103.png]]
    
잠깐 게임이 중단되면 모두가 같이 멈춘다
    
이벤트 버스 패턴은 옵저버 패턴이 발행자와 구독자의 명확한 구도가 있었던 것과 다르게, 발행자와 구독자가 모두 N명인 형태를 말합니다.
    
이벤트가 발생했다면 모든 참여자들은 메시지를 받게 되고, 누가 보낸 메시지인지는 알 필요는 없습니다. 다만, 구현을 다르게 하여 구독자들을 정할 수 있습니다.
    

- 예제 1
    
    ```csharp
    public interface IEvent { }
    
    public struct PlayerEvent : IEvent {
        public int health;
        public int mana;
    }
    
    public interface IEventBinding<T> {
        public Action<T> OnEvent { get; set; }
        public Action OnEventNoArgs { get; set; }
    }
    
    public class EventBinding<T> : IEventBinding<T> where T : IEvent {
        Action<T> onEvent = _ => { };
        Action onEventNoArgs = () => { };
    
        Action<T> IEventBinding<T>.OnEvent {
            get => onEvent;
            set => onEvent = value;
        }
    
        Action IEventBinding<T>.OnEventNoArgs {
            get => onEventNoArgs;
            set => onEventNoArgs = value;
        }
    
        public EventBinding(Action<T> onEvent) => this.onEvent = onEvent;
        public EventBinding(Action onEventNoArgs) => this.onEventNoArgs = onEventNoArgs;
        
        public void Add(Action onEvent) => onEventNoArgs += onEvent;
        public void Remove(Action onEvent) => onEventNoArgs -= onEvent;
        
        public void Add(Action<T> onEvent) => this.onEvent += onEvent;
        public void Remove(Action<T> onEvent) => this.onEvent -= onEvent;
    }
    
    public static class EventBus<T> where T : IEvent {
        static readonly HashSet<IEventBinding<T>> bindings = new HashSet<IEventBinding<T>>();
        
        public static void Register(EventBinding<T> binding) => bindings.Add(binding);
        public static void Deregister(EventBinding<T> binding) => bindings.Remove(binding);
    
        public static void Raise(T @event) {
            foreach (var binding in bindings) {
                binding.OnEvent.Invoke(@event);
                binding.OnEventNoArgs.Invoke();
            }
        }
    
        static void Clear() {
            Debug.Log($"Clearing {typeof(T).Name} bindings");
            bindings.Clear();
        }
    }
    ```
    
- 예제 2
    
    ```csharp
    using UnityEngine.Events;
    using System.Collections.Generic;
    
    namespace Chapter.EventBus
    {
        public class RaceEventBus
        {
            private static readonly 
                IDictionary<RaceEventType, UnityEvent> 
                Events = new Dictionary<RaceEventType, UnityEvent>();
    
            public static void Subscribe
                (RaceEventType eventType, UnityAction listener) {
                
                UnityEvent thisEvent;
    
                if (Events.TryGetValue(eventType, out thisEvent)) {
                    thisEvent.AddListener(listener);
                }
                else {
                    thisEvent = new UnityEvent();
                    thisEvent.AddListener(listener);
                    Events.Add(eventType, thisEvent);
                }
            }
    
            public static void Unsubscribe
                (RaceEventType type, UnityAction listener) {
    
                UnityEvent thisEvent;
    
                if (Events.TryGetValue(type, out thisEvent)) {
                    thisEvent.RemoveListener(listener);
                }
            }
    
            public static void Publish(RaceEventType type) {
    
                UnityEvent thisEvent;
    
                if (Events.TryGetValue(type, out thisEvent)) {
                    thisEvent.Invoke();
                }
            }
        }
    
        public class ClientEventBus : MonoBehaviour
        {
          private bool _isButtonEnabled;
          
          void Start()
          {
              gameObject.AddComponent<HUDController>();
              gameObject.AddComponent<CountdownTimer>();
              gameObject.AddComponent<BikeController>();
    
              _isButtonEnabled = true;
          }
          
          void OnEnable()
          {
              RaceEventBus.Subscribe(
                  RaceEventType.STOP, Restart);
          }
    
          void OnDisable()
          {
              RaceEventBus.Unsubscribe(
                  RaceEventType.STOP, Restart);
          }
    
          private void Restart()
          {
              _isButtonEnabled = true;
          }
    
          void OnGUI()
          {
              if (_isButtonEnabled)
              {
                  if (GUILayout.Button("Start Countdown"))
                  {
                      _isButtonEnabled = false;
                      RaceEventBus.Publish(RaceEventType.COUNTDOWN);
                  }
              }
          }
    }
    ```
    
