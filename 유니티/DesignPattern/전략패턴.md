### 전략 패턴

다양한 행동을 할 수 있는 드론이 있다고 생각해봅시다. 이 드론이 항상 똑같이 프로그래밍한 대로만 움직이는 게 아니라, 실제 실행**(런타임) 중에** 랜덤으로 혹은 유저의 입력에 따라 어떤 행동이 달라질 지 구현한다고 생각해봅시다.

즉, 객체지향 그 자체 패턴입니다. 공통적인 내용들을 추상화하고, 이를 통해 동적으로 프로그램의 실행흐름을 변경시키는 패턴이다라고 생각해주시면 됩니다.

<aside> 💡 **[정리]** 한 클래스가 다양한 역할을 할 수 있고 이에 대한 전략을 만들어둔다. 이 중 한가지의 전략을 플레이타임에 실행할 수 있도록 로직을 구현한다.

</aside>

![[Pasted image 20240122210041.png]]

- (1안) 필드를 통해 구현하는 경우
    
    ```csharp
    using UnityEngine;
    
    namespace Chapter.Strategy {
        public class Drone : MonoBehaviour {
            
            // Ray parameters
      
te float _rayAngle = -45.0f;
            [SerializeField] private float _rayDistance = 15.0f;
    
            // Movement parameters
            public float speed = 1.0f;
            public float maxHeight = 5.0f;
            public float weavingDistance = 1.5f;
            public float fallbackDistance = 20.0f;
    
            void Start() {
                _rayDirection = 
                    transform.TransformDirection(Vector3.back) 
                    * _rayDistance;
                
                _rayDirection = 
                    Quaternion.Euler(_rayAngle, 0.0f, 0f) 
                    * _rayDirection;
    
    						StartCoroutine(Manuever());
            }
    
            void Update() {
                Debug.DrawRay(transform.position, 
                    _rayDirection, Color.blue);
                
                if (Physics.Raycast(
                    transform.position,
                    _rayDirection, out _hit, _rayDistance)) {
                    
                    if (_hit.collider) {
                        Debug.DrawRay(
                            transform.position, 
                            _rayDirection, Color.green);
                    }
                }
            }
    
    		IEnumerator Manuever(){
    			    while (true) {
                  time = 0;
                  Vector3 start = drone.transform.position;
                  Vector3 end = 
                      (isReverse) ? startPosition : endPosition;
    
                  while (time < speed) {
                      drone.transform.position = 
                          Vector3.Lerp(start, end, time / speed);
                      time += Time.deltaTime;
                      yield return null;
                  }
                  yield return new WaitForSeconds(1);
                  isReverse = !isReverse;
              }
    			}
        }
    }
    ```
    
- (2안) if문을 통해 구현하려는 경우
    
    ```csharp
    using UnityEngine;
    
    namespace Chapter.Strategy {
    
    		public enum DroneType {
    			Bopple, Weave, Fallback
    		}
    
        public class Drone : MonoBehaviour {
            
            // Ray parameters
            private RaycastHit _hit;
            private Vector3 _rayDirection;
            private float _rayAngle = -45.0f;
            private float _rayDistance = 15.0f;
    
            // Movement parameters
            public float speed = 1.0f;
            public float maxHeight = 5.0f;
            public float weavingDistance = 1.5f;
            public float fallbackDistance = 20.0f;
    
    				public DroneType type;
    
            void Start() {
    						switch(type){
    								case DroneType.Bopple:
    									_rayAngle = ~~;
    								case DroneType.Weave:
    									_rayAngle = ~~;
    						}
    /*
                _rayDirection = 
                    transform.TransformDirection(Vector3.back) 
                    * _rayDistance;
                
                _rayDirection = 
                    Quaternion.Euler(_rayAngle, 0.0f, 0f) 
                    * _rayDirection;
    */
    						StartCoroutine(Manuever());
            }
    
            void Update() {
                Debug.DrawRay(transform.position, 
                    _rayDirection, Color.blue);
                
                if (Physics.Raycast(
                    transform.position,
                    _rayDirection, out _hit, _rayDistance)) {
                    
                    if (_hit.collider) {
                        Debug.DrawRay(
                            transform.position, 
                            _rayDirection, Color.green);
                    }
                }
            }
    
    		IEnumerator Manuever(){
    			    while (true) {
                  time = 0;
                  Vector3 start = drone.transform.position;
                  Vector3 end = 
                      (isReverse) ? startPosition : endPosition;
    
                  while (time < speed) {
                      drone.transform.position = 
                          Vector3.Lerp(start, end, time / speed);
                      time += Time.deltaTime;
                      yield return null;
                  }
                  yield return new WaitForSeconds(1);
                  isReverse = !isReverse;
              }
    			}
        }
    }
    ```
    
- (3안) 전략 패턴을 통해 구현하는 경우
    
    전략 인터페이스
    
    ```csharp
    namespace Chapter.Strategy
    {
        public interface IManeuverBehaviour
        {
            void Maneuver(Drone drone);
        }
    }
    ```
    
    전략 구현부 (Bopple만)
    
    ```csharp
    using UnityEngine;
    using System.Collections;
    
    namespace Chapter.Strategy {
        public class BoppingManeuver : 
            MonoBehaviour, IManeuverBehaviour { 
            
            public void Maneuver(Drone drone) {
                StartCoroutine(Bopple(drone));
            }
    
            IEnumerator Bopple(Drone drone)
            {
                float time;
                bool isReverse = false;
                float speed = drone.speed;
                Vector3 startPosition = drone.transform.position;
                Vector3 endPosition = startPosition;
                endPosition.y = drone.maxHeight;
    
                while (true) {
                    time = 0;
                    Vector3 start = drone.transform.position;
                    Vector3 end = 
                        (isReverse) ? startPosition : endPosition;
    
                    while (time < speed) {
                        drone.transform.position = 
                            Vector3.Lerp(start, end, time / speed);
                        time += Time.deltaTime;
                        yield return null;
                    }
    								**// 변수만 바꾸는 수준에서 복잡한 조작이 가능하도록 구현 가능!**
    
                    yield return new WaitForSeconds(1);
                    isReverse = !isReverse;
                }
            }
        }
    }
    ```
    
    드론 구현부
    
    ```csharp
    using UnityEngine;
    
    namespace Chapter.Strategy {
        public class Drone : MonoBehaviour {
            
            // Ray parameters
            private RaycastHit _hit;
            private Vector3 _rayDirection;
            private float _rayAngle = -45.0f;
            private float _rayDistance = 15.0f;
    
            // Movement parameters
            public float speed = 1.0f;
            public float maxHeight = 5.0f;
            public float weavingDistance = 1.5f;
            public float fallbackDistance = 20.0f;
    
            void Start() {
                _rayDirection = 
                    transform.TransformDirection(Vector3.back) 
                    * _rayDistance;
                
                _rayDirection = 
                    Quaternion.Euler(_rayAngle, 0.0f, 0f) 
                    * _rayDirection;
            }
    
            public void ApplyStrategy(IManeuverBehaviour strategy) {
                strategy.Maneuver(this);
            }
    
            void Update() {
                Debug.DrawRay(transform.position, 
                    _rayDirection, Color.blue);
                
                if (Physics.Raycast(
                    transform.position,
                    _rayDirection, out _hit, _rayDistance)) {
                    
                    if (_hit.collider) {
                        Debug.DrawRay(
                            transform.position, 
                            _rayDirection, Color.green);
                    }
                }
            }
        }
    }
    ```
    
    전략 적용부
    
    ```csharp
    using UnityEngine;
    using System.Collections.Generic;
    
    namespace Chapter.Strategy {
        public class ClientStrategy : MonoBehaviour {
            
            private GameObject _drone;
            private List<IManeuverBehaviour> 
                _components = new List<IManeuverBehaviour>();
            
            private void SpawnDrone() {
                _drone = 
                    GameObject.CreatePrimitive(PrimitiveType.Cube);
                
                _drone.AddComponent<Drone>();
                
                _drone.transform.position = 
                    Random.insideUnitSphere * 10;
                
                ApplyRandomStrategies();
            }
    
            private void ApplyRandomStrategies() {
                _components.Add(
                    _drone.AddComponent<WeavingManeuver>());
                _components.Add(
                    _drone.AddComponent<BoppingManeuver>());
                _components.Add(
                    _drone.AddComponent<FallbackManeuver>());
                
                int index = Random.Range(0, _components.Count);
                
                _drone.GetComponent<Drone>().
                    ApplyStrategy(_components[index]);
            }
            
            void OnGUI() {
                if (GUILayout.Button("Spawn Drone")) {
                    SpawnDrone();
                }
            }
        }
    }
    ```
    

