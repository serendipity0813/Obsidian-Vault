### ì „ëµ íŒ¨í„´

ë‹¤ì–‘í•œ í–‰ë™ì„ í•  ìˆ˜ ìˆëŠ” ë“œë¡ ì´ ìˆë‹¤ê³  ìƒê°í•´ë´…ì‹œë‹¤. ì´ ë“œë¡ ì´ í•­ìƒ ë˜‘ê°™ì´ í”„ë¡œê·¸ë˜ë°í•œ ëŒ€ë¡œë§Œ ì›€ì§ì´ëŠ” ê²Œ ì•„ë‹ˆë¼, ì‹¤ì œ ì‹¤í–‰**(ëŸ°íƒ€ì„) ì¤‘ì—** ëœë¤ìœ¼ë¡œ í˜¹ì€ ìœ ì €ì˜ ì…ë ¥ì— ë”°ë¼ ì–´ë–¤ í–‰ë™ì´ ë‹¬ë¼ì§ˆ ì§€ êµ¬í˜„í•œë‹¤ê³  ìƒê°í•´ë´…ì‹œë‹¤.

ì¦‰, ê°ì²´ì§€í–¥ ê·¸ ìì²´ íŒ¨í„´ì…ë‹ˆë‹¤. ê³µí†µì ì¸ ë‚´ìš©ë“¤ì„ ì¶”ìƒí™”í•˜ê³ , ì´ë¥¼ í†µí•´ ë™ì ìœ¼ë¡œ í”„ë¡œê·¸ë¨ì˜ ì‹¤í–‰íë¦„ì„ ë³€ê²½ì‹œí‚¤ëŠ” íŒ¨í„´ì´ë‹¤ë¼ê³  ìƒê°í•´ì£¼ì‹œë©´ ë©ë‹ˆë‹¤.

<aside> ğŸ’¡ **[ì •ë¦¬]** í•œ í´ë˜ìŠ¤ê°€ ë‹¤ì–‘í•œ ì—­í• ì„ í•  ìˆ˜ ìˆê³  ì´ì— ëŒ€í•œ ì „ëµì„ ë§Œë“¤ì–´ë‘”ë‹¤. ì´ ì¤‘ í•œê°€ì§€ì˜ ì „ëµì„ í”Œë ˆì´íƒ€ì„ì— ì‹¤í–‰í•  ìˆ˜ ìˆë„ë¡ ë¡œì§ì„ êµ¬í˜„í•œë‹¤.

</aside>

![[Pasted image 20240122210041.png]]

- (1ì•ˆ) í•„ë“œë¥¼ í†µí•´ êµ¬í˜„í•˜ëŠ” ê²½ìš°
    
    ```csharp
    using UnityEngine;
    
    namespace Chapter.Strategy {
        public class Drone : MonoBehaviour {
            
            // Ray parameters
      
te float _rayAngle = -45.0f;
            [SerializeField] private float _rayDistance = 15.0f;
    
            // Movement parameters
            public float speed = 1.0f;
            public float maxHeight = 5.0f;
            public float weavingDistance = 1.5f;
            public float fallbackDistance = 20.0f;
    
            void Start() {
                _rayDirection = 
                    transform.TransformDirection(Vector3.back) 
                    * _rayDistance;
                
                _rayDirection = 
                    Quaternion.Euler(_rayAngle, 0.0f, 0f) 
                    * _rayDirection;
    
    						StartCoroutine(Manuever());
            }
    
            void Update() {
                Debug.DrawRay(transform.position, 
                    _rayDirection, Color.blue);
                
                if (Physics.Raycast(
                    transform.position,
                    _rayDirection, out _hit, _rayDistance)) {
                    
                    if (_hit.collider) {
                        Debug.DrawRay(
                            transform.position, 
                            _rayDirection, Color.green);
                    }
                }
            }
    
    		IEnumerator Manuever(){
    			    while (true) {
                  time = 0;
                  Vector3 start = drone.transform.position;
                  Vector3 end = 
                      (isReverse) ? startPosition : endPosition;
    
                  while (time < speed) {
                      drone.transform.position = 
                          Vector3.Lerp(start, end, time / speed);
                      time += Time.deltaTime;
                      yield return null;
                  }
                  yield return new WaitForSeconds(1);
                  isReverse = !isReverse;
              }
    			}
        }
    }
    ```
    
- (2ì•ˆ) ifë¬¸ì„ í†µí•´ êµ¬í˜„í•˜ë ¤ëŠ” ê²½ìš°
    
    ```csharp
    using UnityEngine;
    
    namespace Chapter.Strategy {
    
    		public enum DroneType {
    			Bopple, Weave, Fallback
    		}
    
        public class Drone : MonoBehaviour {
            
            // Ray parameters
            private RaycastHit _hit;
            private Vector3 _rayDirection;
            private float _rayAngle = -45.0f;
            private float _rayDistance = 15.0f;
    
            // Movement parameters
            public float speed = 1.0f;
            public float maxHeight = 5.0f;
            public float weavingDistance = 1.5f;
            public float fallbackDistance = 20.0f;
    
    				public DroneType type;
    
            void Start() {
    						switch(type){
    								case DroneType.Bopple:
    									_rayAngle = ~~;
    								case DroneType.Weave:
    									_rayAngle = ~~;
    						}
    /*
                _rayDirection = 
                    transform.TransformDirection(Vector3.back) 
                    * _rayDistance;
                
                _rayDirection = 
                    Quaternion.Euler(_rayAngle, 0.0f, 0f) 
                    * _rayDirection;
    */
    						StartCoroutine(Manuever());
            }
    
            void Update() {
                Debug.DrawRay(transform.position, 
                    _rayDirection, Color.blue);
                
                if (Physics.Raycast(
                    transform.position,
                    _rayDirection, out _hit, _rayDistance)) {
                    
                    if (_hit.collider) {
                        Debug.DrawRay(
                            transform.position, 
                            _rayDirection, Color.green);
                    }
                }
            }
    
    		IEnumerator Manuever(){
    			    while (true) {
                  time = 0;
                  Vector3 start = drone.transform.position;
                  Vector3 end = 
                      (isReverse) ? startPosition : endPosition;
    
                  while (time < speed) {
                      drone.transform.position = 
                          Vector3.Lerp(start, end, time / speed);
                      time += Time.deltaTime;
                      yield return null;
                  }
                  yield return new WaitForSeconds(1);
                  isReverse = !isReverse;
              }
    			}
        }
    }
    ```
    
- (3ì•ˆ) ì „ëµ íŒ¨í„´ì„ í†µí•´ êµ¬í˜„í•˜ëŠ” ê²½ìš°
    
    ì „ëµ ì¸í„°í˜ì´ìŠ¤
    
    ```csharp
    namespace Chapter.Strategy
    {
        public interface IManeuverBehaviour
        {
            void Maneuver(Drone drone);
        }
    }
    ```
    
    ì „ëµ êµ¬í˜„ë¶€ (Boppleë§Œ)
    
    ```csharp
    using UnityEngine;
    using System.Collections;
    
    namespace Chapter.Strategy {
        public class BoppingManeuver : 
            MonoBehaviour, IManeuverBehaviour { 
            
            public void Maneuver(Drone drone) {
                StartCoroutine(Bopple(drone));
            }
    
            IEnumerator Bopple(Drone drone)
            {
                float time;
                bool isReverse = false;
                float speed = drone.speed;
                Vector3 startPosition = drone.transform.position;
                Vector3 endPosition = startPosition;
                endPosition.y = drone.maxHeight;
    
                while (true) {
                    time = 0;
                    Vector3 start = drone.transform.position;
                    Vector3 end = 
                        (isReverse) ? startPosition : endPosition;
    
                    while (time < speed) {
                        drone.transform.position = 
                            Vector3.Lerp(start, end, time / speed);
                        time += Time.deltaTime;
                        yield return null;
                    }
    								**// ë³€ìˆ˜ë§Œ ë°”ê¾¸ëŠ” ìˆ˜ì¤€ì—ì„œ ë³µì¡í•œ ì¡°ì‘ì´ ê°€ëŠ¥í•˜ë„ë¡ êµ¬í˜„ ê°€ëŠ¥!**
    
                    yield return new WaitForSeconds(1);
                    isReverse = !isReverse;
                }
            }
        }
    }
    ```
    
    ë“œë¡  êµ¬í˜„ë¶€
    
    ```csharp
    using UnityEngine;
    
    namespace Chapter.Strategy {
        public class Drone : MonoBehaviour {
            
            // Ray parameters
            private RaycastHit _hit;
            private Vector3 _rayDirection;
            private float _rayAngle = -45.0f;
            private float _rayDistance = 15.0f;
    
            // Movement parameters
            public float speed = 1.0f;
            public float maxHeight = 5.0f;
            public float weavingDistance = 1.5f;
            public float fallbackDistance = 20.0f;
    
            void Start() {
                _rayDirection = 
                    transform.TransformDirection(Vector3.back) 
                    * _rayDistance;
                
                _rayDirection = 
                    Quaternion.Euler(_rayAngle, 0.0f, 0f) 
                    * _rayDirection;
            }
    
            public void ApplyStrategy(IManeuverBehaviour strategy) {
                strategy.Maneuver(this);
            }
    
            void Update() {
                Debug.DrawRay(transform.position, 
                    _rayDirection, Color.blue);
                
                if (Physics.Raycast(
                    transform.position,
                    _rayDirection, out _hit, _rayDistance)) {
                    
                    if (_hit.collider) {
                        Debug.DrawRay(
                            transform.position, 
                            _rayDirection, Color.green);
                    }
                }
            }
        }
    }
    ```
    
    ì „ëµ ì ìš©ë¶€
    
    ```csharp
    using UnityEngine;
    using System.Collections.Generic;
    
    namespace Chapter.Strategy {
        public class ClientStrategy : MonoBehaviour {
            
            private GameObject _drone;
            private List<IManeuverBehaviour> 
                _components = new List<IManeuverBehaviour>();
            
            private void SpawnDrone() {
                _drone = 
                    GameObject.CreatePrimitive(PrimitiveType.Cube);
                
                _drone.AddComponent<Drone>();
                
                _drone.transform.position = 
                    Random.insideUnitSphere * 10;
                
                ApplyRandomStrategies();
            }
    
            private void ApplyRandomStrategies() {
                _components.Add(
                    _drone.AddComponent<WeavingManeuver>());
                _components.Add(
                    _drone.AddComponent<BoppingManeuver>());
                _components.Add(
                    _drone.AddComponent<FallbackManeuver>());
                
                int index = Random.Range(0, _components.Count);
                
                _drone.GetComponent<Drone>().
                    ApplyStrategy(_components[index]);
            }
            
            void OnGUI() {
                if (GUILayout.Button("Spawn Drone")) {
                    SpawnDrone();
                }
            }
        }
    }
    ```
    

