 
#### 디자인 패턴 : 프로그램 개발에서 자주 나타나는 과제를 해결하기 위한 방법

- 모른다고 하늘이 무너지는 것은 아니다 / 꼭 이렇게 해야 한다는 것은 아님 / 기출문제와 성격이 비슷하다

>디자인 패턴은 코드의 아름다움을 추구하는 것이 아닌 코드의 변경성과 확장성을 위해 사용하는 것이다 - 중용을 지키자

  
## 대표적인 디자인 패턴 종류
--- 

**1. [[싱글톤]]
- 특정한 기능을 하는 오브젝트가 한 개만 존재해야 하게 하는 패턴

**2. [[오브젝트 풀]]
- 오브젝트의 재활용을 통해 효율적으로 오브젝트를 생성 및 회수하는 패턴

**3. 컴포넌트 패턴
- 독립적인 기능을 하는 다양한 기능들을 다양한 오브젝트에 붙이고 땔 수 있도록 하는 패턴

**4. 게임루프
- 오브젝트에 라이프사이클을 설정하고 이를 통해 실행할 행동들을  체계적으로 관리


## 자주 쓰이는 디자인 패턴들
---

#### 1. [[전략패턴]]

**실제 실행(런타임) 중 랜덤, 혹은 유저 입력에 따라 행동이 달라질지 구현(객체지향 그 자체)
- 각각의 상황에 따른 행동전략을 구현하는 것
- if 혹은 field 에서의 구현도 가능하지만 유지보수성이 떨어지고 다양한 구현이 어려워짐
- 전략 적용부분 / 인터페이스 / 드론의 행동 으로 나누어 구현하여 사용 


#### 2.[[명령패턴]] 

**메소드를 객체처럼 사용하는 것
- 함수 자체를 캡슐화 하여 생성자를 통해 호출하는 느낌?
- 변경이 용이하고 유지보수성이 좋아짐
- 추상클래스로 한번 감싸주고 하위 클래스에 명확한 행동을 구현해주는 방식예시
- 리플레이 시스템 - 결정론적 + 프레임시간 전제사항 필요

  

#### 3. [[메멘토 패턴]] 

**뒤로 돌아갈 수 있도록 설계하는 방법
- 1초 동안의 기록을 fixed 프레임 단위로 저장하고 추가 내용들은 이전 마지막 내용들을 지우고 새로운 내용들을 추가하는 방식 

  
#### 4. [[옵저버 패턴]] 

**버튼 입력시 특정 함수가 실행되도록 하거나 값 변경시 특정 이벤트 발생하도록 하는 식
- 1:1 - 함수호출 / 1:N - 옵저버 패턴 / N:N - 이벤트버스
-  구독한 후 구독 해제하기 전 사망시 문제가 생길 수 있음
- 죽었을 때 구독 해제하는 부분 구현 필요함


#### 5. [[이벤트 버스 패턴]]

**옵저버 패턴이 발행자와 구독자의 명확한 구도가 있다면 
이벤트 버스 패턴은 발행자, 구독자가 n명인 패턴
- hashset을 활용하여 이벤트가 중복 등록되는 걸 방지함
	-> hashset : VALUE가 없는 dictionary
- 게임시작 : 방장만 이벤트 실행 가능하니까 옵저버 패턴
	디스 : 누구나 실행 가능한 이벤트 버스 패턴
- 자유롭게 이벤트 호출, 등록이 가능하지만 체계가 없는 느낌


#### 6. [[프로토타입 패턴]]

**프로토 타입 : 원형이 될 수 있는 오브젝트를 만들고 조금씩 바꾼다
- Instantiate 의 원본이 프로토 타입 느낌
	-> 오브젝트를 상속받아야만 사용 가능하다
- 게임에서의 프로토타입 : 게임에서 가장 중요한 재미 요소만 구현한 후 개발 여부를 결정함
- 오브젝트 생성 공장느낌 / 오브젝트를 상속받지 않아도 가능

#### 7. [[빌더패턴]]

**오브젝트 생성을(객체의 초기화를) 체계적으로 하도록 도와주는 패턴
- 한번 객체를 생성할 때 생성자에 엄청 많은 파라미터가 들어가기도 하는데 그때 사용함
	-> 어떤 파라미터가 들어가는지 알기 어려움 
- 빌더를 생성하여 어떤 메소드가 들어갈지 미리 주문서를 만들어놓는 느낌
	-> 이 빌더를 디렉터가 관리함

**Fluent Builder
- 생산과정이 조금 더 직관적으로 보이는 패턴
-  하나를 빠트려도 작동은 됨 (null값이 들어가서)
	->나중에 후폭풍이 오는 단점



#### 8.[[팩토리 패턴]]

**객체를 생성하는 다른 클래스를 만들어 주는 것
- 객체의 생성 자체를 담당하는 다른 클래스를 따로 만들어 두는 방식



#### 9. [[더티플래그 패턴]]

**디자인 패턴으로 포함하지 않는 의견도 많지만 꽤 유용한 방법 / 최적화 방식

- 중복적인 연산을 효율하기에 좋은 방식
- 값 호출 전까지 해당 연산을 수행하지 않는 방식
- ex) 트랜스폼 업데이트 (배 위의 해적 위의 앵무새) 
- transform.(translate/rotate) -> transform.setpositionandrotation
- LINQ Lazy Evaluation (func, toarray 예시)


#### 10. [[상태패턴]]

- 유한상태기계 (fsm)
- 플래이어의 상태 종류를 인터페이스로 구현
- 각 상태마다 클래스로 구현하고 그 스태이트로 넘어갈 수 있는 조건이 되면 호출