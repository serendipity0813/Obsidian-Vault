## Object Pool

**게임에 참전하기 위해 준비중인 오브젝트 / 미리 만들어 둔 게임 오브젝트 집합**
- 프리펩 -> 인스턴스화 하면 오브젝트풀 진입 -> 활성화 하면 실제 오브젝트
- 게임 실행 중 동적으로 생성, 삭제하는 것 보다 효율적임**
- 메모리 관리, 성능 향상의 이점이 있음 / GarbageCollection 이 제일 중요함**
- 총알이나 적 캐릭터 생성 등에서 자주 사용**

프리팹 → 인스턴스화하고 꺼놓음 → 오브젝트풀 안 → 활성화 → 실제 게임오브젝트

오브젝트 풀은 미리 생성된 게임 오브젝트들을 관리하는 방식으로, 게임 실행 중에 오브젝트를 동적으로 생성하고 삭제하는 것보다 효율적입니다.

**[오브젝트 풀 활용 이유]**

- **성능 향상**: 오브젝트 생성 및 삭제는 비용(메모리 할당/해제 및 이로 인한 GC)이 많이 들기 때문에, 미리 생성된 오브젝트를 재활용하여 성능을 향상시킵니다.
- **메모리 관리**: 오브젝트 풀을 사용하면 게임 실행 중에 오브젝트를 반복적으로 생성하고 삭제하는 것보다 메모리를 효율적으로 관리할 수 있습니다.

**[오브젝트 풀의 활용 사례]**

- **총알**: 총알은 자주 생성되고 삭제되는 게임 오브젝트 중 하나입니다. 총알을 매번 생성하고 삭제하는 대신, 총알 오브젝트 풀을 사용하여 재활용할 수 있습니다.
- **적 캐릭터**: 적 캐릭터는 게임에서 자주 등장하는 오브젝트입니다. 많은 수의 적 캐릭터를 생성하고 제거하는 대신, 적 캐릭터 오브젝트 풀을 사용하여 효율적으로 관리할 수 있습니다.

오브젝트 풀은 게임 개발에서 유용한 도구로서, 성능 향상과 메모리 관리를 개선하고 일관성을 유지하는 데 도움이 됩니다.


![[Pasted image 20240114235552.png]]


**1. 미리 생성해두는 오브젝트 풀 (국룰)
- 씬 로딩시 오브젝트 풀 생성 마무리가 국룰
- start함수에서 정해진 수량만큼 일단 instantiate하고 setactive를 false
- 오브젝트가 죽어있으면 setActive로 주고 꽉차면 null 반환
- 처음에 더이상 필요하지 않을 만큼 미리 만들어둔다는 마인드
- 로딩 시간이 길어진다는 문제가 있다는 단점
    
    ```csharp
    public class ObjectPool : MonoBehaviour
    {
        public GameObject prefab;
        public int poolSize;
    
        private List<GameObject> objectPool;
    
        private void Start()
        {
            objectPool = new List<GameObject>();
    
            for (int i = 0; i < poolSize; i++)
            {
                GameObject obj = Instantiate(prefab, transform);
                obj.SetActive(false);
                objectPool.Add(obj);
            }
        }
    
        public GameObject GetObjectFromPool()
        {
            foreach (GameObject obj in objectPool)
            {
                if (!obj.activeInHierarchy)
                {
                    obj.SetActive(true);
                    return obj;
                }
            }
    
            return null;
        }
    }
    
    ```
    
    위의 코드는 Prewarmed 오브젝트 풀을 구현한 예시입니다. `prefab` 변수에 생성할 오브젝트의 프리팹을 지정하고, `poolSize` 변수에 풀에 생성할 오브젝트의 개수를 설정합니다. `Start()` 함수에서는 지정한 개수만큼 오브젝트를 생성하고 비활성화 상태로 풀에 추가합니다. `GetObjectFromPool()` 함수는 풀에서 비활성화된 오브젝트를 찾아 활성화 후 반환합니다.
    
- **제한이 있는 오브젝트 풀**
- 어떻게든 제한범위 내에서 버텨본다는 뜻
- 제한 범위가 넘으면 null이 아닌 제일 처음 생성된 오브젝트를 빼고 다시 재활용
- 몬스터 같은 경우에는 사용x / 이펙트 같은 경우에는 사용하기 좋음
    
    다음은 파티클이나 이펙트와 같이 제한된 오브젝트 풀에서 가장 오래된 게임 오브젝트를 비활성화하고 새로운 오브젝트를 활성화하는 방식을 구현한 예시입니다:
    
    ```csharp
    using System.Collections.Generic;
    using UnityEngine;
    
    public class ObjectPool : MonoBehaviour
    {
        public GameObject prefab;
        public int maxPoolSize;
    
        private Queue<GameObject> objectPool;
    
        private void Start()
        {
            objectPool = new Queue<GameObject>();
        }
    
        public GameObject GetObjectFromPool()
        {
            GameObject obj;
    
            if (objectPool.Count < maxPoolSize)
            {
                obj = Instantiate(prefab, transform);
                objectPool.Enqueue(obj);
            }
            else
            {
                obj = objectPool.Dequeue();
                obj.SetActive(false);
                obj.transform.position = transform.position; // 위치 재설정이 필요할 경우
                obj.SetActive(true);
                objectPool.Enqueue(obj);
            }
    
            return obj;
        }
    }
    
    ```
    
    이 코드는 오브젝트 풀이 **`maxPoolSize`**에 도달했을 때, 큐에서 가장 먼저 들어간 오브젝트 (즉, 가장 오래전에 생성된 오브젝트)를 재활용합니다. **`Queue`** 구조를 사용하여 가장 먼저 들어간 오브젝트를 쉽게 관리할 수 있습니다. 오브젝트가 필요할 때마다 큐에서 꺼내 재사용하고, 다시 큐의 끝에 추가합니다.
    
- **동적 오브젝트 풀 (국룰)
-  처음에 초기 숫자와 max 숫자(터질 것 같은 숫자) 선언해줌
- 초기 숫자 내부에서 해결되면 그냥 진행
- 만약 넘어가게 된다면 max와 비교한 후 add 해버림
	-> 추가발주 하는 느낌 / 1개씩? or 100개 그냥 해버리
- max숫자가 넘어가면 막아버리기
    
    ```csharp
    public class ObjectPool : MonoBehaviour
    {
        public GameObject prefab;
        public int initialPoolSize; // 100
        public int maxPoolSize; // 10000
    
        private List<GameObject> objectPool;
    
        private void Start()
        {
            objectPool = new List<GameObject>();
    
            for (int i = 0; i < initialPoolSize; i++)
            {
                GameObject obj = Instantiate(prefab, transform);
                obj.SetActive(false);
                objectPool.Add(obj);
            }
        }
    
        public GameObject GetObjectFromPool()
        {
            foreach (GameObject obj in objectPool)
            {
                if (!obj.activeInHierarchy)
                {
                    obj.SetActive(true);
                    return obj;
                }
            }
    
            if (objectPool.Count < maxPoolSize)
            {
                GameObject obj = Instantiate(prefab, transform);
                objectPool.Add(obj); 
                obj.SetActive(true);
                return obj;
            }
            else
            {
                // 풀에 더 이상 생성할 수 없음
                return null;
            }
        }
    }
    
    ```
    
    위의 코드는 동적 오브젝트 풀을 구현한 예시입니다. `prefab` 변수에 생성할 오브젝트의 프리팹을 지정하고, `initialPoolSize` 변수에 초기에 생성할 오브젝트의 개수를, `maxPoolSize` 변수에 풀에 생성할 오브젝트의 최대 개수를 설정합니다. `Start()` 함수에서는 초기 개수만큼 오브젝트를 생성하고 비활성화 상태로 풀에 추가합니다. `GetObjectFromPool()` 함수는 풀에서 비활성화된 오브젝트를 찾아 활성화 후 반환하며, 풀에 추가할 여유 공간이 없을 경우에는 추가적으로 오브젝트를 생성하여 반환합니다.
    

### 유니티 내장 ObjectPool

**유니티 2021이후 버전**에서는 유니티 내장 ObjectPool이 제공되며, 생성자가 다소 험악하게 생겼지만, 우리가 지금까지 배운 것을 총 복습하는 느낌으로 진행할 수 있습니다.

![](https://teamsparta.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fd8b62731-17a4-4963-8337-3ca2a9bcb9bb%2F96ac8431-eeec-43b7-9d58-adfc75d6527c%2FUntitled.png?table=block&id=b574f101-799b-465c-bfbe-2a011dd08ab7&spaceId=83c75a39-3aba-4ba4-a792-7aefe4b07895&width=2000&userId=&cache=v2)

```
func<gameobject> -> 입력값 없고 게임오브젝트 리턴
actionOnGet -> 풀에서 가져올 때 실행함수
actionOnRelease -> 풀로 반환할 때 실행할 함수
actionOnDestroy -> 파괴시 실행할 함수
actionOnCheck -> 이미 있는 걸 확인 / true 쓰기
defaultCapacity -> 초기 용량
maxSize -> 최대 용량
```


- 예시
    
    ```csharp
    using UnityEngine;
    using UnityEngine.Pool;
    
    public class BulletPoolExample : MonoBehaviour
    {
        public GameObject bulletPrefab;
    
        private ObjectPool<GameObject> bulletPool;
    
        private void Start()
        {
            bulletPool = new ObjectPool<GameObject>(
                createFunc: () => Instantiate(bulletPrefab), // 오브젝트 생성 방법
                actionOnGet: (obj) => obj.SetActive(true),   // 오브젝트를 풀에서 가져올 때 실행할 액션
                actionOnRelease: (obj) => obj.SetActive(false), // 오브젝트를 풀에 반환할 때 실행할 액션
                actionOnDestroy: (obj) => Destroy(obj),     // 오브젝트를 파괴할 때 실행할 액션
                defaultCapacity: 10,                        // 초기 용량
                maxSize: 20                                 // 최대 용량
            );
        }
    
        public GameObject GetBullet()
        {
            return bulletPool.Get();
        }
    
        public void ReturnBullet(GameObject bullet)
        {
            bulletPool.Release(bullet);
        }
    }
    ```
    

### 마무리
---

**오브젝트풀이 만능은 아님** 

- 꼭 전부 같은 오브젝트에만 쓰는 것은 아님**
- OnGet에서 로직을 추가하면 하나의 풀에서 여러 오브젝트 관리도 가능**
- 그룹화 하는 것은 좋은 전략 / 하나의 오브젝트에서 다양화를 주는 건 좋지만 여러가지 프리펩을 사용하는 것은 좋지 않다고 생각함


**언제 써야하나요?**

**1. 생성과 파괴가 자주 일어나는 경우에 사용하기**
**2. 오브젝트를 많이 생성하는 경우(최소 30 정도)**
**3. 오브젝트 생성관리를 체계적으로 하고 싶다**

