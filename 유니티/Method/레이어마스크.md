## LayerMask

유니티에서 레이어에 대한 처리를 훨씬 효율적으로 하는 방법으로 레이어마스크를 활용합니다.

유니티에서는 총 32개(0~31)의 레이어를 활용할 수 있으며, 이를 한번에 처리하기 위해 **정수형 변수의 각 비트(32비트)를 할당하여 처리**합니다. **1개의 변수를 여러 개의 bool값처럼 처리하는 방법!**

예를 들어, 카메라에서 특정 레이어에 있는 객체만 촬영하는 Culling Mask를 생각해봅시다. 이를 이렇게 구현할 수도 있습니다.

```csharp
// 1바이트인 bool로 저장하는 의사(pseudo)코드
bool[] layerList;
foreach(bool i in LayerList){ // bool : 1바이트
	if(i) Render();
}
```

하지만 이렇게 하는 경우, 32개의 데이터를 저장할 때 32바이트가 필요하며, 32개의 비교연산을 하게 되어 매우 불필요하게 연산량이 커질 수 있습니다.

그래서 이를 2진법으로 표현하여 훨씬 더 편리하게 효율적으로 처리할 수 있습니다.

**즉, 하나의 큰 수에 여러 개의 0과 1 값을 저장하는 기법이라고 생각하시면 됩니다.**

- **2진법 기초**
    
    우리가 서로 다른 출발점을 가지고 있기 때문에, 2진법에 대해서 설명드리겠습니다.
    
    2진법은 0~9로 숫자를 표현하는 10진법과 다르게, 0~1로 숫자를 표현하는 방법입니다. 컴퓨터는 전기 신호의 켜짐(1)과 꺼짐(0)을 이용해 정보를 처리하고 저장합니다.
    
    따라서 2진법은 컴퓨터가 이해하고 처리할 수 있는 가장 기본적인 데이터 표현 방식입니다.
    
    그리고 이렇게 2진법으로 표현한 수를 2진수라고 합니다.
    
    ![[Pasted image 20240122203232.png]]
    **[해보기]** (1) 34을 2진수로 나타내보세요.
    
    (2) (1)의 결과를 오른쪽으로 한 칸씩 밀어보세요. 값이 어떻게 변했을까요?
    
    ```csharp
    Debug.Log($"십진수 10을 이진수로 변경 : {Convert.ToString(10, 2)}")
    ```
    
    ```csharp
    class Program
    {
        static string DecimalToBinary(int decimalNumber)
        {
            if (decimalNumber == 0)
                return "0";
    
            string binaryString = "";
            while (decimalNumber > 0)
            {
                int remainder = decimalNumber % 2;
                binaryString = remainder + binaryString;
                decimalNumber = decimalNumber / 2;
            }
            return binaryString;
        }
    
        static void Main()
        {
            int decimalNumber = 15; // 변환하고 싶은 십진수
            string binaryString = DecimalToBinary(decimalNumber);
            Console.WriteLine("Binary Representation: " + binaryString);
        }
    }
    ```
    
- **비트 연산**
    
    1. 비트 옮기기 (shift) 비트를 왼쪽으로 옮긴다는 의미에서 비트 시프트(shift)연산은 << 처럼 나타내고, 오른쪽으로 옮기는 시프트연산은 >>처럼 나타냅니다. // 1 << 2 예를 들어 1 << 8은 아래와 같이 나타낼 수 있습니다.
    2. 
    ![[Pasted image 20240122203251.png]]
   
	```csharp
    // 8번 레이어 활성화
    // 8번 : 보스 6번 : 일반
    int layerMask = 1 << 8;
    layerMask |= 1 << 6; 
    
    // 사용 예시: 8번 레이어의 오브젝트만 감지하는 Raycast
    if (Physics.Raycast(ray, out hit, 100, layerMask)) {
        // 8번 레이어의 오브젝트와 충돌했을 때의 처리
    }
    ```
    
    1. 비트를 1로 만들기 (OR)
  ![[Pasted image 20240122203312.png]]
        OR연산은 한쪽이라도 1인 경우 1이 되도록 하는 연산입니다. 이를 통해 어떤 한 비트가 1이 되도록 할 수 있습니다.
        
        ```csharp
        // 8번과 10번 레이어 결합
        int layerMask = (1 << 8) | (1 << 10);
        101000000000
        // 사용 예시: 8번 또는 10번 레이어의 오브젝트만 감지하는 Raycast
        if (Physics.Raycast(ray, out hit, 100, layerMask)) {
            // 8번 또는 10번 레이어의 오브젝트와 충돌했을 때의 처리
        }
        ```
        
    2. 비트가 1인지 확인하기 (AND)
        
        사실 강의에서 한 코드보다는 아래와 같은 코드 구성이 일반적으로 더 많이 활용됩니다.
        
        AND는 A, B 모두 1이 아니면 0을 반환하므로, 자신이 1일때 상대가 1인지 아닌지를 판단할 수 있습니다.
        
   ![[Pasted image 20240122203322.png]]
        
        ```csharp
        bool isLayer8Included = (layerMask & (1 << 8)) != 0;
        
        // 사용 예시: layerMask에 8번 레이어가 포함되어 있는지 확인
        if (isLayer8Included) {
            // 8번 레이어가 포함된 경우의 처리
        }
        
        // 예시
        // 1000000000 & 1001010101 
        // => 1000000000 != 0 => true
        // 100000000 & 010101010 => 000000000 != 0 => false
        ```
        
    3. 비트 뒤집기(NOT)
        
        ```csharp
        // 8번 레이어 제외
        int layerMask = ~(1 << 8);
        
        // 사용 예시: 8번 레이어를 제외한 모든 레이어의 오브젝트를 감지하는 Raycast
        if (Physics.Raycast(ray, out hit, 100, layerMask)) {
            // 8번 레이어를 제외한 오브젝트와 충돌했을 때의 처리
        }
        ```
        
- **LayerMask 메소드들**
    
    - LayerMask.GetMask(params string[] layerNames); LayerName들을 넣어서 비트마스크를 만듭니다.
    
    ```csharp
    LayerMask mask = LayerMask.GetMask("Monster") | LayerMask.GetMask("Wall");
    // int mask = (1 << 8) | (1 << 9); 와 동일
    RaycastHit hit;
    if (Physics.Raycast(ray, out hit, 100.0f, mask))
    {
       Debug.Log(hit1.collider.gameObject.name);
    }
    ```
    
    - LayerMask.value
        
        비트마스크값을 도출합니다(실제 이진수를 십진수로 바꿔서 계산) 예) 1025 = 1024 + 1 **[QUIZ] LayerMask.value → 레이어 인덱스를 하려면 어떤 변환을 해야할까요?**
        
    - LayerMask.NameToLayer(string layerName)
        
        레이어의 이름을 통해 레이어의 인덱스(비트마스크값 아님)을 도출합니다. 예) 9
        
    - LayerMask.Contains(int layerIndex) LayerMask가 특정한 레이어 인덱스를 포함하고 있는지 확인합니다
        
- **비트마스크 상태이상 시스템**
    
    System.Flags를 사용해서 중첩 비트마스크를 부여할 수 있습니다.
    
    이를 활용해 아래와 같은 상태이상 시스템을 구현할 수 있습니다.
    
    ```csharp
    [System.Flags]
    public enum StatusEffects
    {
        None = 0,
        Poisoned = 1 << 0,  // 0001
        Burned = 1 << 1,    // 0010
        Frozen = 1 << 2,    // 0100
        Paralyzed = 1 << 3  // 1000
    }
    
    public class StatusEffectManager
    {
        private StatusEffects currentEffects = StatusEffects.None;
    
        public void AddEffect(StatusEffects effect)
        {
            currentEffects |= effect;
        }
    
        public void RemoveEffect(StatusEffects effect)
        {
            currentEffects &= ~effect;
        }
    
        public void ClearEffects()
        {
            currentEffects = StatusEffects.None;
        }
    
        public bool HasEffect(StatusEffects effect)
        {
    				// 0100 & 0100 => 0100 != 0000 -> true
            return (currentEffects & effect) != StatusEffects.None;
        }
    
        public void PrintEffects()
        {
            Console.WriteLine("Current Status Effects: " + currentEffects);
        }
    }
    
    class Program
    {
        static void Main()
        {
            StatusEffectManager manager = new StatusEffectManager();
    
            // 상태 이상 추가
            manager.AddEffect(StatusEffects.Poisoned);
            manager.AddEffect(StatusEffects.Frozen);
    
            // 현재 상태 이상 출력
            manager.PrintEffects(); // Poisoned, Frozen
    
            // 상태 이상 제거
            manager.RemoveEffect(StatusEffects.Poisoned);
    
            // 상태 이상 확인
            if (manager.HasEffect(StatusEffects.Frozen))
            {
                Console.WriteLine("The character is frozen.");
            }
    
            // 모든 상태 이상 제거
            manager.ClearEffects();
        }
    }
    ```