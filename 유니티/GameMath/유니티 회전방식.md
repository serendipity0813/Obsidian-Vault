## 게임수학 - 회전

**우리가 회전을 생각하는 방법 3가지**

1. 오일러각 - x, y, z축의 각각의 회전으로 표현하는 방식

2D - Z축으로 회전, X, Y축에서 이동 3D - X/Y/Z축으로 회전, X, Y, Z축에서 이동 (국룰 : XZ축 평면에서 이동 Y축에서 점프 : y-up)

**짐벌락** - [MAX를 활용한 짐벌락Gimbal-lock)설명 (youtube.com)](https://www.youtube.com/watch?v=yxMQKsab5TQ&t=321s)

2. 사원수(쿼터니언) - w, x, y, z의 네 가지 수로 회전을 표현하는 방식

게임 엔진에서는 주로 쿼터니언을 활용하여 회전하지만 **매우 비직관적이기 때문에** 개발자들은 오일러각을 쿼터니언으로 바꾸는 방식을 활용하고, 이러한 메소드를 제공한다. Quaternion.Identity // 회전이 없다

Quaternion.Euler ← 오일러각을 쿼터니언으로 변환하는 방식

Transform.eulerAngles ← 오일러각을 회전에 직접 반영하는 방식

문제 : **우리가 생각하는 어떤 특정한 회전을 적용하는 수많은 쿼터니언이 있다.**

- 회전 사용시 주의사항
    
    ```csharp
    void Update ()
    {
        var rot = transform.rotation; // Quaternion
        rot.x += Time.deltaTime * 10; // Quaternion은 크기가 1인 벡터라고 생각가능 단위사원수
        transform.rotation = rot;
    }
    ```
    
    ```csharp
    // rotation scripting mistake #2
    // Read, modify, then write the Euler values from a Quaternion.
    // Because these values are calculated from a Quaternion,
    // each new rotation might return very different Euler angles, which might suffer from gimbal lock.
    
    void Update ()
    {
        var angles = transform.rotation.eulerAngles;
        angles.x += Time.deltaTime * 10;
        transform.rotation = Quaternion.Euler(angles);
    }
    // Debug.Log 뭐가 나오고 있는지를 꼭 봐야됨
    ```
    
    그리고 다음은 스크립트에서 오일러 각을 **올바르게** 사용하는 예입니다.
    
    ```csharp
    // Rotation scripting with Euler angles correctly.
    // Store the Euler angle in a class variable, and only use it to
    // apply it as an Euler angle, but never rely on reading the Euler back.
    
    float x;
    void Update ()
    {
        x += Time.deltaTime * 10;
        transform.rotation = Quaternion.Euler(x,0,0);
    }
    ```
    
    ```csharp
    using UnityEngine;
    
    // demonstration of eulerAngles not returning the same values as assigned
    public class EulerAnglesProblemExample :MonoBehaviour
    {
        private void Start()
        {
    			Quaternion myRotation =Quaternion.identity;
            myRotation.eulerAngles = newVector3(150, 35, 45);
    
    			Debug.Log(myRotation.eulerAngles);
    
            // output is: (30.0, 215.0, 225.0)
        }
    }
    ```
    

3. 방향 벡터 - 특정한 방향을 바라보게 하거나, 특정한 방향과 축을 맞출 때 활용

- 예시 - LookRotation
    
    ```csharp
    public class ExampleClass : MonoBehaviour
    {
        public Transform target;
    
        void Update()
        {
            Vector3 relativePos = target.position - transform.position;
    
            // the second argument, upwards, defaults to Vector3.up
            Quaternion rotation = Quaternion.LookRotation(relativePos, Vector3.up);
            transform.rotation = rotation;
        }
    }
    ```
    
- 예시 - FromToRotation (벡터의 정렬)
    
    ```csharp
    rb.velocity = transform.forward * speed.z;
    Ray ray = new Ray(transform.position, transform.forward);
    Physics.Raycast(transform.position, transform.forward, out RaycastHit hit, 1f);
    if (hit.collider != null)
    {
        Instantiate(Effect, hit.point, Quaternion.FromToRotation(Vector3.up, hit.normal));
        Destroy(gameObject);
    }
    ```
    
