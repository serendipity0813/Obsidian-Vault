 
## 데이터의 저장

열심히 플레이 한 결과가 전부 다 날라가버린다면 그 게임을 하고 싶을까요?

데이터의 저장은 운영되고 있는 게임의 서비스 수명에 직접 영향을 주는 중요한 주제입니다.

## 데이터 직렬화
---

- 직렬화 - 객체를 쭉 늘어난 바이트 배열로 만든다(110101...)
- 역직렬화 -> 바이트 배열을 객체로 바꾸는 것
- 모든 클래스가 직렬화 가능한 건 아님 (ex. Transform 등)
  

![[Pasted image 20240122203848.png]]

우리가 프로그래밍한 복잡한 객체를 바이트들의 배열로 만들어버리는 작업을 직렬화라고 하며, **모든 클래스를 직렬화할 수 있는 것은 아닙니다**.


유니티에서는 아래와 같은 필드들에 대해 직렬화할 수 있다고 정의하고 있습니다.


### 왜 데이터를 파일에 저장하면 좋을까
-> 작업량이 줄고 1개의 클래스만 작업하면 된다, 버그 발생 가능성이 낮은 편이다

```csharp
switch(characterType){
	case CharacterType.Warrior:
		HP = 40;
		MP = 5;
		DEX = 10;
		
}
```

![[Pasted image 20240122203902.png]]

### 직렬화 가능 타입

![[Pasted image 20240122203941.png]]

⭐ 정리 : Serializable로 전체를 구성하고, 클래스 자체도 Serializable 어트리뷰트를 붙이면 직렬화 가능타입이 됩니다 ⭐

```csharp
[Serializable]
public class MyClass{
	public int a;
	public int b;
}

[Serializable]
public class MyBigClass{
	public MyClass my;
}

public class myCharacterData{
	// Transform 직접 넣는거 안됨
	public Vector3 position;
	public Quaternion rotation;
}
```

### **PlayerPrefs**

PlayerPrefs는 게임 세션 간에 **플레이어 환경설정**을 저장하는 클래스입니다. 이 클래스는 **문자열, 실수, 정수** 값을 사용자의 플랫폼 레지스트리에 저장할 수 있습니다.

유니티는 암호화하지 않고 로컬 레지스트리에 PlayerPrefs를 저장합니다. 민감한 데이터를 저장하는 데에는 적합하지 않습니다.

유니티는 애플리케이션이 실행되는 운영 체제에 따라 PlayerPrefs 데이터를 다르게 저장합니다. 이 페이지에 제공된 파일 경로에서 예제 회사 이름과 예제 제품 이름은 Unity의 플레이어 설정에서 설정한 이름입니다.

- 문자열, 실수, 정수 값을 플랫폼 레지스트리에 저장
- 보안에 전혀 문제가 되지 않고 영향도가 높지 않은 부분을 저장하면 좋은 선택이 될 수 있다
- 글자로 묶은 후 저장하고 id를 키로 하고 나머지 정보를 값으로 직렬화
	-> Playerprefs 에 넣어버린다
- 직렬화 방식, 역직렬화 방식을 직접 만들 수 있다
- Save 기능은 창밖으로 나가거나 하는 경우에도 저장해주기도 한다
	-> 하지만 순간 프레임드랍이 있을 수 있다 / 성능상의문제가 있으므로 굳이 할 필요는 없다 
- 파일 접근은 최소화하자
- 

![[Pasted image 20240122204014.png]]

- 예제 1
    
    ```csharp
    string userId = "user1234";
    string password = "password123";
    string name = "홍길동";
    int balance = 10000;
    
    string combinedInfo = password + "," + name + "," + balance.ToString();
    PlayerPrefs.SetString(userId, combinedInfo);
    PlayerPrefs.Save();
    ```
    
    ```csharp
    if(PlayerPrefs.HasKey(userId){ // ID 있음
    	string savedInfo = PlayerPrefs.GetString(userId);
    	string[] infoParts = savedInfo.Split(',');
    	
    	string loadedPassword = infoParts[0];
    	string loadedName = infoParts[1];
    	int loadedBalance = int.Parse(infoParts[2]);
    	
    	Debug.Log("비밀번호: " + loadedPassword);
    	Debug.Log("이름: " + loadedName);
    	Debug.Log("잔액: " + loadedBalance);
    }
    else {
    		// ID 없음
    }
    ```
    
- 예제 1+
    
    ```csharp
    [System.Serializable]
    public class UserData
    {
        public string userId;
        public string password;
        public string name;
        public int balance;
    
        public UserData(string userId, string password, string name, int balance)
        {
            this.userId = userId;
            this.password = password;
            this.name = name;
            this.balance = balance;
        }
    
        // 객체의 데이터를 하나의 문자열로 변환
        public string Serialize()
        {
            return userId + "," + password + "," + name + "," + balance.ToString();
        }
    
        // 문자열에서 객체의 데이터를 복원
        public static UserData Deserialize(string data)
        {
            string[] parts = data.Split(',');
            return new UserData(parts[0], parts[1], parts[2], int.Parse(parts[3]));
        }
    }
    
    UserData userData = new UserData("user1234", "password123", "홍길동", 10000);
    string serializedData = userData.Serialize();
    PlayerPrefs.SetString(userData.userId, serializedData);
    PlayerPrefs.Save();
    
    string serializedData = PlayerPrefs.GetString("user1234");
    UserData loadedUserData = UserData.Deserialize(serializedData);
    
    Debug.Log("비밀번호: " + loadedUserData.password);
    Debug.Log("이름: " + loadedUserData.name);
    Debug.Log("잔액: " + loadedUserData.balance);
    ```
    
- 예제 2
    
    ```csharp
    public void changeScore(int value)
    {
        this.nowScore += value;
        
    		// 최고점수 갱신
        if (nowScore > highScore)
        {
            **highScore = nowScore;
            PlayerPrefs.SetInt("HighScore", highScore);
        }
        // 점수 UI에 반영
    		updateScore();
    }
    ```
    
- Playerprefs.Save()?
    
![[Pasted image 20240122204035.png]]

### 데이터 저장에 많이 쓰이는 메소드/프로퍼티들

1. Application.persistentDataPath
-  앱을 지워도 사라지지 않는 경로
- Application.Datapath는 앱 업데이트시 날아가버리는 이슈 있으니 임시로 사용하는걸 권장
    [Unity - Scripting API: Application.persistentDataPath](https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html)
    
2. File.Exists
- 파일의 존재 여부를 파악하는 방법
- 파일 입출력에는 예외처리가 가장 중요
    [File.Exists(String) 메서드 (System.IO)](https://learn.microsoft.com/ko-kr/dotnet/api/system.io.file.exists?view=net-8.0)
    
3. File.ReadAllText
- 파일의 모든 텍스트를 문자열로 읽어서 string으로 반환
    [File.ReadAllText 메서드 (System.IO)](https://learn.microsoft.com/ko-kr/dotnet/api/system.io.file.readalltext?view=netframework-4.7.2)
    
4. File.WriteAllText
- 파일을 만들어서 글을 적어주고 닫아주는 친구
    [File.WriteAllText 메서드 (System.IO)](https://learn.microsoft.com/ko-kr/dotnet/api/system.io.file.writealltext?view=net-8.0)
    
### 데이터 저장에 많이 쓰이는 메소드/프로퍼티들
---

## **CSV**

CSV(Comma-Separated Values)는 데이터를 저장하고 교환하는 데 사용되는 간단한 파일 형식입니다. 이 형식은 각 데이터 항목이 쉼표로 구분되며, **각 줄**이 **하나**의 **데이터 레코드**를 나타냅니다. CSV 파일은 엑셀이나 다른 표 계산 소프트웨어에서 쉽게 읽고 쓸 수 있으며, 프로그래밍에서도 널리 사용됩니다.

- 쉼표로 구분되고 각 줄이 하나의 데이터 레코드
- 엑셀이나 메모장 등으로도 파일 확인이 가능
- 기획자와 소통하기 좋은 방안

  **ex) `csvFile = Resources/Load<TextAsset>(".File/MyFile");`
- for문 사용시 헤더줄 제외를 위해 1부터 쓰는 센스
- split(',') 등을 사용해서 데이터를 자르면서 읽음
- csv를 쓸 때 기획자분들이 많이 실수하는 것은?
	 -> 데이터에 ., 등을 넣어버리는 경우 : 대참사! 
- ,는 사용하지 못한다고 생각해야함 만약 ,가 필요하면 json으로 넘어가야 한다
- 

- 예제 1
    
    ```csharp
    [System.Serializable]
    public class Item
    {
        public int id;
        public string name;
        public int price;
        public string type;
    
        public Item(int id, string name, int price, string type)
        {
            this.id = id;
            this.name = name;
            this.price = price;
            this.type = type;
        }
    }
    ```
    
    ```csharp
    using System.Collections.Generic;
    using UnityEngine;
    
    public class CSVReader : MonoBehaviour
    {
        public TextAsset csvFile; // Unity Editor에서 할당
    
        void Start()
        {
    				csvFile = Resources.Load<TextAsset>("/File/myFile");
    
            List<Item> items = ReadCsv(csvFile.text);
            // 읽은 데이터 사용 예
            foreach (Item item in items)
            {
                Debug.Log($"아이템: {item.name}, 가격: {item.price}, 타입: {item.type}");
            }
        }
    
        List<Item> ReadCsv(string csvData)
        {
            List<Item> items = new List<Item>();
    
            string[] lines = csvData.Split('\\n');
            for (int i = 1; i < lines.Length; i++) // 헤더줄 제외!
            {
                if (lines[i].Trim() == "") continue;
    
                string[] fields = lines[i].Split(',');
                int id = int.Parse(fields[0]);
                string name = fields[1];
                int price = int.Parse(fields[2]);
                string type = fields[3];
    
                items.Add(new Item(id, name, price, type));
            }
    
            return items;
        }
    }
    ```
    

### JSON

JSON(JavaScript Object Notation)은 경량 데이터 교환 형식입니다. 유니티에서는 JSON을 사용하여 데이터를 저장하고 읽어올 수 있습니다. JSON은 사람과 기계 모두에게 읽기 쉽고 쓰기 쉬운 형식이며, 다양한 프로그래밍 언어에서 지원됩니다.

**dictionary 형식으로 저장되는 파일
- key / value 형식으로 저장됨
- 직관적으로 저장되고 읽는 것이 강점
- 중괄호의 지옥에 빠질 수 있다는 단점 -> 이쁘게 정리해주는 사이트 따로 있음
- ex) 서울2033게임이 json으로 되어있다고 함
- 

![[Pasted image 20240122204111.png]]

### 예제 1

```csharp
using UnityEngine;
using System.IO;

public class JsonDataManager : MonoBehaviour
{
    private string filePath;

    private void Awake()
    {
        filePath = Application.persistentDataPath + "/data.json";
    }

    public void SaveData(PlayerData data)
    {
        string jsonData = JsonUtility.ToJson(data, true);
        File.WriteAllText(filePath, jsonData);
    }

    public PlayerData LoadData()
    {
        if (File.Exists(filePath))
        {
            string jsonData = File.ReadAllText(filePath);
            return JsonUtility.FromJson<PlayerData>(jsonData);
        }
        else
        {
            Debug.LogError("Save file not found.");
            return null;
        }
    }
}

```

위 예제에서는 `JsonDataManager` 클래스를 사용하여 데이터를 JSON 형식으로 저장하고 로드하는 방법을 보여줍니다. `SaveData` 함수는 `PlayerData` 객체를 JSON 문자열로 변환하여 파일에 저장하고, `LoadData` 함수는 파일에서 JSON 문자열을 읽어와 `PlayerData` 객체로 변환하여 반환합니다.

### 예제 2

```csharp
using UnityEngine;

[System.Serializable]
public class PlayerData
{
    public string playerName;
    public int playerLevel;
    public float playerHealth;
}

public class Player : MonoBehaviour
{
    public PlayerData playerData;

    private void Start()
    {
        playerData = new PlayerData();
        playerData.playerName = "John";
        playerData.playerLevel = 10;
        playerData.playerHealth = 100.0f;

        SavePlayerData();
        LoadPlayerData();
    }

    private void SavePlayerData()
    {
        string jsonData = JsonUtility.ToJson(playerData);
        PlayerPrefs.SetString("PlayerData", jsonData);
        PlayerPrefs.Save();
    }

    private void LoadPlayerData()
    {
        if (PlayerPrefs.HasKey("PlayerData"))
        {
            string jsonData = PlayerPrefs.GetString("PlayerData");
            playerData = JsonUtility.FromJson<PlayerData>(jsonData);

            Debug.Log("Player Name: " + playerData.playerName);
            Debug.Log("Player Level: " + playerData.playerLevel);
            Debug.Log("Player Health: " + playerData.playerHealth);
        }
    }
}

```

위 예제에서는 `Player` 클래스를 사용하여 `PlayerData` 객체를 JSON 형식으로 저장하고 로드하는 방법을 보여줍니다. `Start` 함수에서는 `PlayerData` 객체를 생성하고 초기값을 설정한 후, `SavePlayerData` 함수를 호출하여 데이터를 저장하고 `LoadPlayerData` 함수를 호출하여 데이터를 로드합니다. 로드한 데이터는 `playerData` 변수에 저장되며, 필요에 따라 사용할 수 있습니다.

JSON을 사용하여 유니티에서 데이터를 저장하고 로드하는 것은 간편하고 효율적인 방법입니다. JSON 형식은 다양한 데이터 유형을 지원하며, 데이터를 읽고 쓰기 쉽게 처리할 수 있습니다. 이를 통해 게임 내에서 플레이어 정보, 게임 설정, 진행 상태 등을 관리할 수 있습니다.

### Scriptable Object

Scriptable Object은 유니티 엔진에서 사용되는 데이터 컨테이너입니다. 이를 통해 게임 오브젝트나 씬에 종속되지 않고 데이터를 저장하고 공유할 수 있습니다. Scriptable Object는 주로 게임의 리소스, 설정, 상태 등을 관리하는 데 사용됩니다.

**특징
- 특정한 게임 오브젝트나 씬에 종속되지 않고 데이터 저장이 가능하다 (파일 기반이므로)
- 글자 뿐만이 아닌 유니티 내부 컴포넌트 등도 저장이 가능
- 간단한 데이터 저장에서는 성능적으로 강점을 가지고 있다
- 유니티 에디터에서 데이터를 확인 및 수정이 가능하다

**사용법
- ScriptableObject를 상속받아서 사용
- CreateAssetMenu 해서 생성 가능하도록 추가해야함

  **단점
- 데이터 저장은 편집할 때나 런타임에 가능 / 에디터에서만 수정이 가능하고 배포된 빌드에서는 스크립터블오브젝트로 데이터 저장 x / 데이터를 수정하는 기능은 사용해서는 안된다 
- - 읽기만 하는 데이터로는 좋음, 수정이 필요한 데이터는 so를 사용x 권장
- 

![[Pasted image 20240122204130.png]]

![[Pasted image 20240122204143.png]]

사용법 - ScriptableObject 상속

![[Pasted image 20240122204153.png]]

- 예제 1
    
    ```csharp
    using UnityEngine;
    
    [CreateAssetMenu(fileName = "Data", menuName = "ScriptableObjects/SpawnManagerScriptableObject", order = 1)]
    public class SpawnManagerScriptableObject : ScriptableObject
    {
        public string prefabName;
    
        public int numberOfPrefabsToCreate;
        public Vector3[] spawnPoints;
    }
    ```
    
    ```csharp
    using UnityEngine;
    
    public class Spawner : MonoBehaviour
    {
        // The GameObject to instantiate.
        public GameObject entityToSpawn;
    
        // An instance of the ScriptableObject defined above.
        public SpawnManagerScriptableObject spawnManagerValues;
    
        // This will be appended to the name of the created entities and increment when each is created.
        int instanceNumber = 1;
    
        void Start()
        {
            SpawnEntities();
        }
    
        void SpawnEntities()
        {
            int currentSpawnPointIndex = 0;
    
            for (int i = 0; i < spawnManagerValues.numberOfPrefabsToCreate; i++)
            {
                // Creates an instance of the prefab at the current spawn point.
                GameObject currentEntity = Instantiate(entityToSpawn, spawnManagerValues.spawnPoints[currentSpawnPointIndex], Quaternion.identity);
    
                // Sets the name of the instantiated entity to be the string defined in the ScriptableObject and then appends it with a unique number. 
                currentEntity.name = spawnManagerValues.prefabName + instanceNumber;
    
                // Moves to the next spawn point index. If it goes out of range, it wraps back to the start.
                currentSpawnPointIndex = (currentSpawnPointIndex + 1) % spawnManagerValues.spawnPoints.Length;
    
                instanceNumber++;
            }
        }
    }
    ```
    
- 예제 2
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/83c75a39-3aba-4ba4-a792-7aefe4b07895/d471c61f-61d4-4120-abeb-44b42973fe8c/Untitled.png)
    
    ```csharp
    using UnityEngine;
    
    [CreateAssetMenu(fileName = "CharacterBaseStatsData", menuName = "ScriptableObjects/CharacterBaseStatsData", order = 1)]
    public class CharacterBaseStatsData : ScriptableObject
    {
        public int Hp;
        public int Defence;
        public int Damage;
        public int AttackSpeed;
        public int MoveSpeed;
    }
    ```
    

### Binary Formatter

**Binary Formatter**

Binary Formatter는 유니티에서 사용되는 직렬화 도구입니다. 이를 통해 객체를 이진 형식으로 직렬화하고, 이진 형식을 다시 객체로 역직렬화할 수 있습니다. Binary Formatter는 주로 파일 저장 및 로드에 사용되며, 데이터를 보다 효율적으로 관리하고 공유할 수 있습니다.

예를 들어, 게임에서 플레이어의 상태를 저장하고 로드해야 할 때 Binary Formatter를 사용할 수 있습니다. 플레이어의 정보를 객체로 표현하고, 이를 이진 형식으로 직렬화하여 파일에 저장합니다. 필요할 때마다 파일에서 이진 형식을 읽어와 역직렬화하여 플레이어의 정보를 복원합니다.

Binary Formatter를 사용하기 위해서는 직렬화할 클래스에 `[Serializable]` 속성을 추가해야 합니다. 또한, `FileStream`과 같은 파일 처리 클래스를 사용하여 파일을 생성하고 열어서 Binary Formatter를 이용해 데이터를 읽고 쓸 수 있습니다.

- 2진수로 데이터가 저장됨 / 읽기 힘들다
- 구조 수정에 어려움이 있을 수 있다 (필드가 추가되거나 등)
- 쓰는 이유는? 성능이 가장 좋기 때문

- 예제
    
    ```csharp
    using UnityEngine;
    using System.IO;
    using System.Runtime.Serialization.Formatters.Binary;
    
    [System.Serializable]
    public class PlayerData
    {
        public string playerName;
        public int playerLevel;
        public float playerHealth;
    }
    
    public class SaveLoadManager : MonoBehaviour
    {
        public PlayerData playerData;
    
        private string saveFilePath;
    
        private void Awake()
        {
            saveFilePath = Application.persistentDataPath + "/playerData.dat";
        }
    
        public void SavePlayerData()
        {
            BinaryFormatter binaryFormatter = new BinaryFormatter();
            FileStream fileStream = File.Create(saveFilePath);
    
            binaryFormatter.Serialize(fileStream, playerData);
            fileStream.Close();
        }
    
        public void LoadPlayerData()
        {
            if (File.Exists(saveFilePath))
            {
                BinaryFormatter binaryFormatter = new BinaryFormatter();
                FileStream fileStream = File.Open(saveFilePath, FileMode.Open);
    
                playerData = (PlayerData)binaryFormatter.Deserialize(fileStream);
                fileStream.Close();
            }
            else
            {
                Debug.Log("Save file not found.");
            }
        }
    }
    
    ```
    
    위 코드에서 `PlayerData` 클래스는 직렬화를 위해 `[Serializable]` 속성이 추가되었습니다. `SaveLoadManager` 클래스는 `playerData`를 이진 형식으로 직렬화하여 파일에 저장하고, 필요할 때 파일에서 읽어와 역직렬화하여 `playerData`를 복원합니다.
    
    Binary Formatter를 사용하면 유니티에서 데이터를 파일에 저장하고 로드하는 기능을 구현할 수 있습니다. 이를 통해 게임의 진행 상태, 플레이어 정보, 게임 설정 등을 보다 효율적으로 관리할 수 있습니다.
    

### 정리


- 간단한 데이터 처리 여부 -> 설정, 단축키, 튜토리얼 진행 여부 등 - PlayerPrefs
- 기획자와 협업에서 좋은 데이터 처리 - csv
- 직관적으로 보고 관리하기 좋은 방식 - json
- 쓰기, 변경기능 제외하고 복잡한 데이터 저장 -> SO
- 성능이 가장 중요한 데이터 -> binary


# [중요] 이러한 방식들은 대부분 핸드폰에 저장하는 방식

- 디바이스 저장이 아닌 서버에 저장해야 한다 (해킹판 등등의 문제)

![[Pasted image 20240122204211.png]]

[How to Hack il2cpp Games - MelonLoader Tutorial](https://www.youtube.com/watch?v=XH4lePNqiHc)